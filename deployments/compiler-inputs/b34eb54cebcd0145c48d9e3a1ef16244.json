{
	"solcVersion": "0.8.23",
	"solcLongVersion": "0.8.23",
	"id": "b34eb54cebcd0145c48d9e3a1ef16244",
	"input": {
		"language": "Solidity",
		"settings": {
			"viaIR": false,
			"optimizer": {
				"runs": 200,
				"enabled": true
			},
			"metadata": {
				"useLiteralContent": false,
				"bytecodeHash": "ipfs",
				"appendCBOR": true
			},
			"outputSelection": {
				"lib/forge-std/lib/ds-test/src/test.sol": {
					"*": []
				},
				"lib/forge-std/src/Base.sol": {
					"*": []
				},
				"lib/forge-std/src/Script.sol": {
					"*": []
				},
				"lib/forge-std/src/StdAssertions.sol": {
					"*": []
				},
				"lib/forge-std/src/StdChains.sol": {
					"*": []
				},
				"lib/forge-std/src/StdCheats.sol": {
					"*": []
				},
				"lib/forge-std/src/StdError.sol": {
					"*": []
				},
				"lib/forge-std/src/StdInvariant.sol": {
					"*": []
				},
				"lib/forge-std/src/StdJson.sol": {
					"*": []
				},
				"lib/forge-std/src/StdMath.sol": {
					"*": []
				},
				"lib/forge-std/src/StdStorage.sol": {
					"*": []
				},
				"lib/forge-std/src/StdStyle.sol": {
					"*": []
				},
				"lib/forge-std/src/StdUtils.sol": {
					"*": []
				},
				"lib/forge-std/src/Test.sol": {
					"*": []
				},
				"lib/forge-std/src/Vm.sol": {
					"*": []
				},
				"lib/forge-std/src/console.sol": {
					"*": []
				},
				"lib/forge-std/src/console2.sol": {
					"*": []
				},
				"lib/forge-std/src/interfaces/IMulticall3.sol": {
					"*": []
				},
				"lib/forge-std/src/mocks/MockERC20.sol": {
					"*": []
				},
				"lib/forge-std/src/mocks/MockERC721.sol": {
					"*": []
				},
				"lib/forge-std/src/safeconsole.sol": {
					"*": []
				},
				"lib/sphinx/packages/contracts/contracts/core/SphinxDataTypes.sol": {
					"*": []
				},
				"lib/sphinx/packages/contracts/contracts/core/interfaces/ISphinxModule.sol": {
					"*": []
				},
				"lib/sphinx/packages/contracts/contracts/core/interfaces/ISphinxModuleProxyFactory.sol": {
					"*": []
				},
				"lib/sphinx/packages/contracts/contracts/forge-std/src/StdUtils.sol": {
					"*": []
				},
				"lib/sphinx/packages/contracts/contracts/forge-std/src/Vm.sol": {
					"*": []
				},
				"lib/sphinx/packages/contracts/contracts/forge-std/src/interfaces/IERC165.sol": {
					"*": []
				},
				"lib/sphinx/packages/contracts/contracts/forge-std/src/interfaces/IERC20.sol": {
					"*": []
				},
				"lib/sphinx/packages/contracts/contracts/forge-std/src/interfaces/IERC721.sol": {
					"*": []
				},
				"lib/sphinx/packages/contracts/contracts/forge-std/src/interfaces/IMulticall3.sol": {
					"*": []
				},
				"lib/sphinx/packages/contracts/contracts/forge-std/src/mocks/MockERC20.sol": {
					"*": []
				},
				"lib/sphinx/packages/contracts/contracts/forge-std/src/mocks/MockERC721.sol": {
					"*": []
				},
				"lib/sphinx/packages/contracts/contracts/foundry/Sphinx.sol": {
					"*": []
				},
				"lib/sphinx/packages/contracts/contracts/foundry/SphinxConstants.sol": {
					"*": []
				},
				"lib/sphinx/packages/contracts/contracts/foundry/SphinxForkCheck.sol": {
					"*": []
				},
				"lib/sphinx/packages/contracts/contracts/foundry/SphinxPlugin.sol": {
					"*": []
				},
				"lib/sphinx/packages/contracts/contracts/foundry/SphinxPluginTypes.sol": {
					"*": []
				},
				"lib/sphinx/packages/contracts/contracts/foundry/SphinxUtils.sol": {
					"*": []
				},
				"lib/sphinx/packages/contracts/contracts/foundry/interfaces/ICreateCall.sol": {
					"*": []
				},
				"lib/sphinx/packages/contracts/contracts/foundry/interfaces/IEnum.sol": {
					"*": []
				},
				"lib/sphinx/packages/contracts/contracts/foundry/interfaces/IGnosisSafe.sol": {
					"*": []
				},
				"lib/sphinx/packages/contracts/contracts/foundry/interfaces/IGnosisSafeProxy.sol": {
					"*": []
				},
				"lib/sphinx/packages/contracts/contracts/foundry/interfaces/IGnosisSafeProxyFactory.sol": {
					"*": []
				},
				"lib/sphinx/packages/contracts/contracts/foundry/interfaces/IMultiSend.sol": {
					"*": []
				},
				"node_modules/@bananapus/permission-ids/src/JBPermissionIds.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/access/Ownable.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/governance/utils/IVotes.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/governance/utils/Votes.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/interfaces/IERC5267.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/interfaces/IERC5805.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/interfaces/IERC6372.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/metatx/ERC2771Context.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/metatx/ERC2771Forwarder.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/proxy/Clones.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/Address.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/Context.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/Nonces.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/ShortStrings.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/StorageSlot.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/Strings.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/math/Math.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/structs/Checkpoints.sol": {
					"*": []
				},
				"node_modules/@openzeppelin/contracts/utils/types/Time.sol": {
					"*": []
				},
				"node_modules/@prb/math/src/Common.sol": {
					"*": []
				},
				"node_modules/@prb/math/src/UD60x18.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/sd1x18/Casting.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/sd1x18/Constants.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/sd1x18/Errors.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/sd1x18/ValueType.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/sd59x18/Casting.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/sd59x18/Constants.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/sd59x18/Errors.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/sd59x18/Helpers.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/sd59x18/Math.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/sd59x18/ValueType.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/ud2x18/Casting.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/ud2x18/Constants.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/ud2x18/Errors.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/ud2x18/ValueType.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/ud60x18/Casting.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/ud60x18/Constants.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/ud60x18/Conversions.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/ud60x18/Errors.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/ud60x18/Helpers.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/ud60x18/Math.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@prb/math/src/ud60x18/ValueType.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"node_modules/@uniswap/permit2/src/interfaces/IAllowanceTransfer.sol": {
					"*": []
				},
				"node_modules/@uniswap/permit2/src/interfaces/IEIP712.sol": {
					"*": []
				},
				"node_modules/@uniswap/permit2/src/interfaces/IPermit2.sol": {
					"*": []
				},
				"node_modules/@uniswap/permit2/src/interfaces/ISignatureTransfer.sol": {
					"*": []
				},
				"node_modules/@uniswap/permit2/test/utils/DeployPermit2.sol": {
					"*": []
				},
				"script/Deploy.s.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"script/helpers/CoreDeploymentLib.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/JBController.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/JBDeadline.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/JBDirectory.sol": {
					"*": []
				},
				"src/JBERC20.sol": {
					"*": []
				},
				"src/JBFeelessAddresses.sol": {
					"*": []
				},
				"src/JBFundAccessLimits.sol": {
					"*": []
				},
				"src/JBMultiTerminal.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/JBPermissions.sol": {
					"*": []
				},
				"src/JBPrices.sol": {
					"*": []
				},
				"src/JBProjects.sol": {
					"*": []
				},
				"src/JBRulesets.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/JBSplits.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/JBTerminalStore.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/JBTokens.sol": {
					"*": []
				},
				"src/abstract/JBControlled.sol": {
					"*": []
				},
				"src/abstract/JBPermissioned.sol": {
					"*": []
				},
				"src/enums/JBApprovalStatus.sol": {
					"*": []
				},
				"src/interfaces/IJBControlled.sol": {
					"*": []
				},
				"src/interfaces/IJBController.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/interfaces/IJBDirectory.sol": {
					"*": []
				},
				"src/interfaces/IJBDirectoryAccessControl.sol": {
					"*": []
				},
				"src/interfaces/IJBFeeTerminal.sol": {
					"*": []
				},
				"src/interfaces/IJBFeelessAddresses.sol": {
					"*": []
				},
				"src/interfaces/IJBFundAccessLimits.sol": {
					"*": []
				},
				"src/interfaces/IJBMigratable.sol": {
					"*": []
				},
				"src/interfaces/IJBMultiTerminal.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/interfaces/IJBPayHook.sol": {
					"*": []
				},
				"src/interfaces/IJBPayoutTerminal.sol": {
					"*": []
				},
				"src/interfaces/IJBPermissioned.sol": {
					"*": []
				},
				"src/interfaces/IJBPermissions.sol": {
					"*": []
				},
				"src/interfaces/IJBPermitTerminal.sol": {
					"*": []
				},
				"src/interfaces/IJBPriceFeed.sol": {
					"*": []
				},
				"src/interfaces/IJBPrices.sol": {
					"*": []
				},
				"src/interfaces/IJBProjectUriRegistry.sol": {
					"*": []
				},
				"src/interfaces/IJBProjects.sol": {
					"*": []
				},
				"src/interfaces/IJBRedeemHook.sol": {
					"*": []
				},
				"src/interfaces/IJBRedeemTerminal.sol": {
					"*": []
				},
				"src/interfaces/IJBRulesetApprovalHook.sol": {
					"*": []
				},
				"src/interfaces/IJBRulesetDataHook.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/interfaces/IJBRulesets.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/interfaces/IJBSplitHook.sol": {
					"*": []
				},
				"src/interfaces/IJBSplits.sol": {
					"*": []
				},
				"src/interfaces/IJBTerminal.sol": {
					"*": []
				},
				"src/interfaces/IJBTerminalStore.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/interfaces/IJBToken.sol": {
					"*": []
				},
				"src/interfaces/IJBTokenUriResolver.sol": {
					"*": []
				},
				"src/interfaces/IJBTokens.sol": {
					"*": []
				},
				"src/libraries/JBConstants.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/libraries/JBCurrencyIds.sol": {
					"*": []
				},
				"src/libraries/JBFees.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/libraries/JBFixedPointNumber.sol": {
					"*": []
				},
				"src/libraries/JBMetadataResolver.sol": {
					"*": []
				},
				"src/libraries/JBRedemptionFormula.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/libraries/JBRedemptions.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/libraries/JBRulesetMetadataResolver.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/libraries/JBSplitGroupIds.sol": {
					"*": []
				},
				"src/structs/JBAccountingContext.sol": {
					"*": []
				},
				"src/structs/JBAfterPayRecordedContext.sol": {
					"*": []
				},
				"src/structs/JBAfterRedeemRecordedContext.sol": {
					"*": []
				},
				"src/structs/JBBeforePayRecordedContext.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/structs/JBBeforeRedeemRecordedContext.sol": {
					"*": []
				},
				"src/structs/JBCurrencyAmount.sol": {
					"*": []
				},
				"src/structs/JBFee.sol": {
					"*": []
				},
				"src/structs/JBFundAccessLimitGroup.sol": {
					"*": []
				},
				"src/structs/JBPayHookSpecification.sol": {
					"*": []
				},
				"src/structs/JBPermissionsData.sol": {
					"*": []
				},
				"src/structs/JBRedeemHookSpecification.sol": {
					"*": []
				},
				"src/structs/JBRuleset.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/structs/JBRulesetConfig.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/structs/JBRulesetMetadata.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/structs/JBRulesetWeightCache.sol": {
					"*": []
				},
				"src/structs/JBRulesetWithMetadata.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"src/structs/JBSingleAllowance.sol": {
					"*": []
				},
				"src/structs/JBSplit.sol": {
					"*": []
				},
				"src/structs/JBSplitGroup.sol": {
					"*": []
				},
				"src/structs/JBSplitHookContext.sol": {
					"*": []
				},
				"src/structs/JBTerminalConfig.sol": {
					"*": []
				},
				"src/structs/JBTokenAmount.sol": {
					"*": []
				},
				"test/TestAccessToFunds.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/TestFees.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/TestInterfaceSupport.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/TestJBERC20Inheritance.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/TestLaunchProject.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/TestMetaTx.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/TestMetadataParserLib.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/TestMintTokensOf.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/TestMultipleAccessLimits.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/TestPayBurnRedeemFlow.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/TestPayHooks.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/TestPermissions.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/TestPermit2Terminal.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/TestRedeem.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/TestRedeemHooks.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/TestRulesetQueueing.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/TestRulesetWeightCaching.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/TestSplits.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/TestTokenFlow.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/helpers/JBTest.sol": {
					"*": []
				},
				"test/helpers/MetadataResolverHelper.sol": {
					"*": []
				},
				"test/helpers/TestBaseWorkflow.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/mock/ERC2771ForwarderMock.sol": {
					"*": []
				},
				"test/mock/MockERC20.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/mock/MockMaliciousSplitHook.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/mock/MockPriceFeed.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBController/JBControllerSetup.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBController/TestBurnTokensOf.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBController/TestClaimTokensFor.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBController/TestDeployErc20For.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBController/TestLaunchProjectFor.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBController/TestLaunchRulesetsFor.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBController/TestMigrateController.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBController/TestMintTokensOfUnits.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBController/TestPayReservedTokenToTerminal.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBController/TestReceiveMigrationFrom.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBController/TestRulesetViews.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBController/TestSendReservedTokensToSplitsOf.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBController/TestSetSplitGroupsOf.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBController/TestSetTokenFor.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBController/TestSetUriOf.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBController/TestTransferCreditsFrom.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBDirectory/JBDirectorySetup.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBDirectory/TestPrimaryTerminalOf.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBDirectory/TestSetControllerOf.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBDirectory/TestSetPrimaryTerminalOf.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBDirectory/TestSetTerminalsOf.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBERC20/JBERC20Setup.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBERC20/SigUtils.sol": {
					"*": []
				},
				"test/units/static/JBERC20/TestInitialize.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBERC20/TestName.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBERC20/TestNonces.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBERC20/TestSymbol.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBFeelessAdresses/JBFeelessSetup.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBFeelessAdresses/TestInterfaces.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBFeelessAdresses/TestSetFeelessAddress.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBFixedPointNumber/TestAdjustDecimals.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBFundAccessLimits/JBFundAccessSetup.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBFundAccessLimits/TestPayoutLimitOf.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBFundAccessLimits/TestPayoutLimitsOf.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBFundAccessLimits/TestSetFundAccessLimitsFor.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBFundAccessLimits/TestSurplusAllowanceOf.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBFundAccessLimits/TestSurplusAllowancesOf.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBMetadataResolver/TestGetDataFor.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBMultiTerminal/JBMultiTerminalSetup.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBMultiTerminal/TestAccountingContextsOf.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBMultiTerminal/TestAddAccountingContextsFor.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBMultiTerminal/TestAddToBalanceOf.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBMultiTerminal/TestExecutePayout.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBMultiTerminal/TestExecuteProcessFee.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBMultiTerminal/TestMigrateBalanceOf.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBMultiTerminal/TestPay.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBMultiTerminal/TestProcessHeldFeesOf.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBMultiTerminal/TestRedeemTokensOf.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBMultiTerminal/TestSendPayoutsOf.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBMultiTerminal/TestUseAllowanceOf.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBPermissions/JBPermissionsSetup.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBPermissions/TestHasPermission.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBPermissions/TestHasPermissions.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBPermissions/TestSetPermissionsFor.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBPrices/JBPricesSetup.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBPrices/TestAddPriceFeedFor.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBPrices/TestPricePerUnitOf.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBProjects/JBProjectsSetup.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBProjects/TestCreateFor.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBProjects/TestInitialProject.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBProjects/TestInterfaces.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBProjects/TestSetResolver.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBProjects/TestTokenUri.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBRulesetMetadataResolver/TestSetRedemptionRateTo.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBRulesets/JBRulesetsSetup.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBRulesets/TestCurrentApprovalStatusForLatestRulesetOf.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBRulesets/TestCurrentOf.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBRulesets/TestGetRulesetOf.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBRulesets/TestLatestQueuedRulesetOf.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBRulesets/TestRulesets.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBRulesets/TestRulesetsOf.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBRulesets/TestUpcomingRulesetOf.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBRulesets/TestUpdateRulesetWeightCache.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBSplits/JBSplitsSetup.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBSplits/TestSetSplitGroupsOf.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBSplits/TestSplitsOf.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBTerminalStore/JBTerminalStoreSetup.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBTerminalStore/TestCurrentReclaimableSurplusOf.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBTerminalStore/TestCurrentSurplusOf.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBTerminalStore/TestCurrentTotalSurplusOf.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBTerminalStore/TestRecordPaymentFrom.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBTerminalStore/TestRecordPayoutFor.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBTerminalStore/TestRecordRedemptionFor.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBTerminalStore/TestRecordTerminalMigration.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBTerminalStore/TestRecordUsedAllowanceOf.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBTokens/JBTokensSetup.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBTokens/TestBurnFrom.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBTokens/TestClaimTokensFor.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBTokens/TestDeployERC20ForUnits.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBTokens/TestMintFor.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBTokens/TestSetTokenFor.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBTokens/TestTotalBalanceOf.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBTokens/TestTotalSupplyOf.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				},
				"test/units/static/JBTokens/TestTransferCreditsFrom.sol": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				}
			},
			"evmVersion": "paris",
			"libraries": {},
			"remappings": [
				"@sphinx-labs/contracts/=lib/sphinx/packages/contracts/contracts/foundry/",
				"@bananapus/=node_modules/@bananapus/",
				"@chainlink/=node_modules/@chainlink/",
				"@eth-optimism/=node_modules/@eth-optimism/",
				"@openzeppelin/=node_modules/@openzeppelin/",
				"@prb/=node_modules/@prb/",
				"@scroll-tech/=node_modules/@scroll-tech/",
				"@uniswap/=node_modules/@uniswap/",
				"ds-test/=lib/forge-std/lib/ds-test/src/",
				"forge-std/=lib/forge-std/src/",
				"hardhat/=node_modules/hardhat/",
				"solmate/=node_modules/solmate/",
				"sphinx/=lib/sphinx/"
			]
		},
		"sources": {
			"node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
			},
			"src/JBSplits.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {JBControlled} from \"./abstract/JBControlled.sol\";\nimport {IJBDirectory} from \"./interfaces/IJBDirectory.sol\";\nimport {IJBSplitHook} from \"./interfaces/IJBSplitHook.sol\";\nimport {IJBSplits} from \"./interfaces/IJBSplits.sol\";\nimport {JBConstants} from \"./libraries/JBConstants.sol\";\nimport {JBSplit} from \"./structs/JBSplit.sol\";\nimport {JBSplitGroup} from \"./structs/JBSplitGroup.sol\";\n\n/// @notice Stores and manages splits for each project.\ncontract JBSplits is JBControlled, IJBSplits {\n    //*********************************************************************//\n    // --------------------------- custom errors ------------------------- //\n    //*********************************************************************//\n    error INVALID_SPLIT_PERCENT();\n    error INVALID_TOTAL_PERCENT();\n    error PREVIOUS_LOCKED_SPLITS_NOT_INCLUDED();\n\n    //*********************************************************************//\n    // ------------------------- public constants ------------------------ //\n    //*********************************************************************//\n\n    /// @notice The ID of the ruleset that will be checked if nothing was found in the provided rulesetId.\n    uint256 public constant override FALLBACK_RULESET_ID = 0;\n\n    //*********************************************************************//\n    // --------------------- internal stored properties ------------------ //\n    //*********************************************************************//\n\n    /// @notice The number of splits currently stored in a group given a project ID, ruleset ID, and group ID.\n    /// @custom:param projectId The ID of the project the split applies to.\n    /// @custom:param rulesetId The ID of the ruleset that the group is specified within.\n    /// @custom:param groupId The ID of the group to count this splits of.\n    mapping(uint256 projectId => mapping(uint256 rulesetId => mapping(uint256 groupId => uint256))) internal\n        _splitCountOf;\n\n    /// @notice Packed split data given the split's project, ruleset, and group IDs, as well as the split's index within\n    /// that group.\n    /// @dev `preferAddToBalance` in bit 0, `percent` in bits 1-32, `projectId` in bits 33-88, and `beneficiary` in bits\n    /// 89-248\n    /// @custom:param projectId The ID of the project that the split applies to.\n    /// @custom:param rulesetId The ID of the ruleset that the group is in.\n    /// @custom:param groupId The ID of the group the split is in.\n    /// @custom:param index The split's index within the group (in the order that the split were set).\n    /// @custom:return The split's `preferAddToBalance`, `percent`, `projectId`, and `beneficiary` packed into one\n    /// `uint256`.\n    mapping(\n        uint256 projectId => mapping(uint256 rulesetId => mapping(uint256 groupId => mapping(uint256 index => uint256)))\n    ) internal _packedSplitParts1Of;\n\n    /// @notice More packed split data given the split's project, ruleset, and group IDs, as well as the split's index\n    /// within that group.\n    /// @dev `lockedUntil` in bits 0-47, `hook` address in bits 48-207.\n    /// @dev This packed data is often 0.\n    /// @custom:param projectId The ID of the project that the ruleset applies to.\n    /// @custom:param rulesetId The ID of the ruleset that the group is in.\n    /// @custom:param groupId The ID of the group the split is in.\n    /// @custom:param index The split's index within the group (in the order that the split were set).\n    /// @custom:return The split's `lockedUntil` and `hook` packed into one `uint256`.\n    mapping(\n        uint256 projectId => mapping(uint256 rulesetId => mapping(uint256 groupId => mapping(uint256 index => uint256)))\n    ) internal _packedSplitParts2Of;\n\n    //*********************************************************************//\n    // ------------------------- external views -------------------------- //\n    //*********************************************************************//\n\n    /// @notice Get the split structs for the specified project ID, within the specified ruleset, for the specified\n    /// group. The splits stored at ruleset 0 are used by default during a ruleset if the splits for the specific\n    /// ruleset aren't set.\n    /// @dev If splits aren't found at the given `rulesetId`, they'll be sought in the FALLBACK_RULESET_ID of 0.\n    /// @param projectId The ID of the project to get splits for.\n    /// @param rulesetId An identifier within which the returned splits should be considered active.\n    /// @param groupId The identifying group of the splits.\n    /// @return splits An array of all splits for the project.\n    function splitsOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        uint256 groupId\n    )\n        external\n        view\n        override\n        returns (JBSplit[] memory splits)\n    {\n        splits = _getStructsFor(projectId, rulesetId, groupId);\n\n        // Use the default splits if there aren't any for the ruleset.\n        if (splits.length == 0) {\n            splits = _getStructsFor({projectId: projectId, rulesetId: FALLBACK_RULESET_ID, groupId: groupId});\n        }\n    }\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param directory A contract storing directories of terminals and controllers for each project.\n    constructor(IJBDirectory directory) JBControlled(directory) {}\n\n    //*********************************************************************//\n    // ---------------------- external transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice Sets a project's split groups.\n    /// @dev Only a project's controller can set its splits.\n    /// @dev The new split groups must include any currently set splits that are locked.\n    /// @param projectId The ID of the project to set the split groups of.\n    /// @param rulesetId The ID of the ruleset the split groups should be active in. Send\n    /// 0 to set the default split that'll be active if no ruleset has specific splits set. The default's default is the\n    /// project's owner.\n    /// @param splitGroups An array of split groups to set.\n    function setSplitGroupsOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        JBSplitGroup[] calldata splitGroups\n    )\n        external\n        override\n        onlyControllerOf(projectId)\n    {\n        // Keep a reference to the number of split groups.\n        uint256 numberOfSplitGroups = splitGroups.length;\n\n        // Set each grouped splits.\n        for (uint256 i; i < numberOfSplitGroups; i++) {\n            // Get a reference to the grouped split being iterated on.\n            JBSplitGroup memory splitGroup = splitGroups[i];\n\n            // Set the splits for the group.\n            _setSplitsOf(projectId, rulesetId, splitGroup.groupId, splitGroup.splits);\n        }\n    }\n\n    //*********************************************************************//\n    // --------------------- internal helper functions ------------------- //\n    //*********************************************************************//\n\n    /// @notice Sets the splits for a group given a project, ruleset, and group ID.\n    /// @dev The new splits must include any currently set splits that are locked.\n    /// @dev The sum of the split `percent`s within one group must be less than 100%.\n    /// @param projectId The ID of the project splits are being set for.\n    /// @param rulesetId The ID of the ruleset the splits should be considered active within.\n    /// @param groupId The ID of the group to set the splits within.\n    /// @param splits An array of splits to set.\n    function _setSplitsOf(uint256 projectId, uint256 rulesetId, uint256 groupId, JBSplit[] memory splits) internal {\n        // Get a reference to the current split structs within the project, ruleset, and group.\n        JBSplit[] memory currentSplits = _getStructsFor(projectId, rulesetId, groupId);\n\n        // Keep a reference to the current number of splits within the group.\n        uint256 numberOfCurrentSplits = currentSplits.length;\n\n        // Check to see if all locked splits are included in the array of splits which is being set.\n        for (uint256 i; i < numberOfCurrentSplits; i++) {\n            // If not locked, continue.\n            if (block.timestamp < currentSplits[i].lockedUntil && !_includesLockedSplits(splits, currentSplits[i])) {\n                revert PREVIOUS_LOCKED_SPLITS_NOT_INCLUDED();\n            }\n        }\n\n        // Add up all the `percent`s to make sure their total is under 100%.\n        uint256 percentTotal;\n\n        // Keep a reference to the number of splits to set.\n        uint256 numberOfSplits = splits.length;\n\n        for (uint256 i; i < numberOfSplits; i++) {\n            // The percent should be greater than 0.\n            if (splits[i].percent == 0) revert INVALID_SPLIT_PERCENT();\n\n            // Add to the `percent` total.\n            percentTotal = percentTotal + splits[i].percent;\n\n            // Ensure the total does not exceed 100%.\n            if (percentTotal > JBConstants.SPLITS_TOTAL_PERCENT) revert INVALID_TOTAL_PERCENT();\n\n            uint256 packedSplitParts1;\n\n            // Pack `preferAddToBalance` in bit 0.\n            if (splits[i].preferAddToBalance) packedSplitParts1 = 1;\n            // Pack `percent` in bits 1-32.\n            packedSplitParts1 |= splits[i].percent << 1;\n            // Pack `projectId` in bits 33-88.\n            packedSplitParts1 |= splits[i].projectId << 33;\n            // Pack `beneficiary` in bits 89-248.\n            packedSplitParts1 |= uint256(uint160(address(splits[i].beneficiary))) << 89;\n\n            // Store the first split part.\n            _packedSplitParts1Of[projectId][rulesetId][groupId][i] = packedSplitParts1;\n\n            // If there's data to store in the second packed split part, pack and store.\n            if (splits[i].lockedUntil > 0 || splits[i].hook != IJBSplitHook(address(0))) {\n                // Pack `lockedUntil` in bits 0-47.\n                uint256 packedSplitParts2 = uint48(splits[i].lockedUntil);\n                // Pack `hook` in bits 48-207.\n                packedSplitParts2 |= uint256(uint160(address(splits[i].hook))) << 48;\n\n                // Store the second split part.\n                _packedSplitParts2Of[projectId][rulesetId][groupId][i] = packedSplitParts2;\n            } else if (_packedSplitParts2Of[projectId][rulesetId][groupId][i] > 0) {\n                // If there's a value stored in the indexed position, delete it.\n                delete _packedSplitParts2Of[projectId][rulesetId][groupId][i];\n            }\n\n            emit SetSplit(projectId, rulesetId, groupId, splits[i], msg.sender);\n        }\n\n        // Store the number of splits for the project, ruleset, and group.\n        _splitCountOf[projectId][rulesetId][groupId] = numberOfSplits;\n    }\n\n    /// @notice Determine if the provided splits array includes the locked split.\n    /// @param splits The array of splits to check within.\n    /// @param lockedSplit The locked split.\n    /// @return A flag indicating if the `lockedSplit` is contained in the `splits`.\n    function _includesLockedSplits(JBSplit[] memory splits, JBSplit memory lockedSplit) internal pure returns (bool) {\n        // Keep a reference to the number of splits.\n        uint256 numberOfSplits = splits.length;\n\n        for (uint256 i; i < numberOfSplits; i++) {\n            // Check for sameness.\n            if (\n                splits[i].percent == lockedSplit.percent && splits[i].beneficiary == lockedSplit.beneficiary\n                    && splits[i].hook == lockedSplit.hook && splits[i].projectId == lockedSplit.projectId\n                    && splits[i].preferAddToBalance == lockedSplit.preferAddToBalance\n                // Allow the lock to be extended.\n                && splits[i].lockedUntil >= lockedSplit.lockedUntil\n            ) return true;\n        }\n\n        return false;\n    }\n\n    /// @notice Unpack an array of `JBSplit` structs for all of the splits in a group, given project, ruleset, and group\n    /// IDs.\n    /// @param projectId The ID of the project the splits belong to.\n    /// @param rulesetId The ID of the ruleset the group of splits should be considered active within.\n    /// @param groupId The ID of the group to get the splits structs of.\n    /// @return splits The split structs, as an array of `JBSplit`s.\n    function _getStructsFor(\n        uint256 projectId,\n        uint256 rulesetId,\n        uint256 groupId\n    )\n        internal\n        view\n        returns (JBSplit[] memory)\n    {\n        // Get a reference to the number of splits that need to be added to the returned array.\n        uint256 splitCount = _splitCountOf[projectId][rulesetId][groupId];\n\n        // Initialize an array to be returned that has the appropriate length.\n        JBSplit[] memory splits = new JBSplit[](splitCount);\n\n        // Loop through each split and unpack the values into structs.\n        for (uint256 i; i < splitCount; i++) {\n            // Get a reference to the first part of the split's packed data.\n            uint256 packedSplitPart1 = _packedSplitParts1Of[projectId][rulesetId][groupId][i];\n\n            // Populate the split struct.\n            JBSplit memory split;\n\n            // `preferAddToBalance` in bit 0.\n            split.preferAddToBalance = packedSplitPart1 & 1 == 1;\n            // `percent` in bits 1-32.\n            split.percent = uint32(packedSplitPart1 >> 1);\n            // `projectId` in bits 33-88.\n            split.projectId = uint56(packedSplitPart1 >> 33);\n            // `beneficiary` in bits 89-248.\n            split.beneficiary = payable(address(uint160(packedSplitPart1 >> 89)));\n\n            // Get a reference to the second part of the split's packed data.\n            uint256 packedSplitPart2 = _packedSplitParts2Of[projectId][rulesetId][groupId][i];\n\n            // If there's anything in it, unpack.\n            if (packedSplitPart2 > 0) {\n                // `lockedUntil` in bits 0-47.\n                split.lockedUntil = uint48(packedSplitPart2);\n                // `hook` in bits 48-207.\n                split.hook = IJBSplitHook(address(uint160(packedSplitPart2 >> 48)));\n            }\n\n            // Add the split to the value being returned.\n            splits[i] = split;\n        }\n\n        return splits;\n    }\n}\n"
			},
			"src/abstract/JBControlled.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBControlled} from \"./../interfaces/IJBControlled.sol\";\nimport {IJBDirectory} from \"./../interfaces/IJBDirectory.sol\";\n\n/// @notice Provides a modifier for contracts with functionality that can only be accessed by a project's controller.\nabstract contract JBControlled is IJBControlled {\n    //*********************************************************************//\n    // --------------------------- custom errors -------------------------- //\n    //*********************************************************************//\n    error CONTROLLER_UNAUTHORIZED();\n\n    //*********************************************************************//\n    // ---------------------------- modifiers ---------------------------- //\n    //*********************************************************************//\n\n    /// @notice Only allows the controller of the specified project to proceed.\n    /// @param projectId The ID of the project.\n    modifier onlyControllerOf(uint256 projectId) {\n        _onlyControllerOf(projectId);\n        _;\n    }\n\n    //*********************************************************************//\n    // ---------------- public immutable stored properties --------------- //\n    //*********************************************************************//\n\n    /// @notice The directory of terminals and controllers for projects.\n    IJBDirectory public immutable override DIRECTORY;\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param directory A contract storing directories of terminals and controllers for each project.\n    constructor(IJBDirectory directory) {\n        DIRECTORY = directory;\n    }\n\n    /// @notice Only allows the controller of the specified project to proceed.\n    function _onlyControllerOf(uint256 projectId) internal view {\n        if (address(DIRECTORY.controllerOf(projectId)) != msg.sender) {\n            revert CONTROLLER_UNAUTHORIZED();\n        }\n    }\n}\n"
			},
			"src/interfaces/IJBControlled.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBDirectory} from \"./IJBDirectory.sol\";\n\ninterface IJBControlled {\n    function DIRECTORY() external view returns (IJBDirectory);\n}\n"
			},
			"src/interfaces/IJBDirectory.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IJBProjects} from \"./IJBProjects.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\n\ninterface IJBDirectory {\n    event SetController(uint256 indexed projectId, IERC165 indexed controller, address caller);\n\n    event AddTerminal(uint256 indexed projectId, IJBTerminal indexed terminal, address caller);\n\n    event SetTerminals(uint256 indexed projectId, IJBTerminal[] terminals, address caller);\n\n    event SetPrimaryTerminal(\n        uint256 indexed projectId, address indexed token, IJBTerminal indexed terminal, address caller\n    );\n\n    event SetIsAllowedToSetFirstController(address indexed addr, bool indexed flag, address caller);\n\n    function PROJECTS() external view returns (IJBProjects);\n\n    function controllerOf(uint256 projectId) external view returns (IERC165);\n\n    function isAllowedToSetFirstController(address account) external view returns (bool);\n\n    function terminalsOf(uint256 projectId) external view returns (IJBTerminal[] memory);\n\n    function isTerminalOf(uint256 projectId, IJBTerminal terminal) external view returns (bool);\n\n    function primaryTerminalOf(uint256 projectId, address token) external view returns (IJBTerminal);\n\n    function setControllerOf(uint256 projectId, IERC165 controller) external;\n\n    function setTerminalsOf(uint256 projectId, IJBTerminal[] calldata terminals) external;\n\n    function setPrimaryTerminalOf(uint256 projectId, address token, IJBTerminal terminal) external;\n\n    function setIsAllowedToSetFirstController(address account, bool flag) external;\n}\n"
			},
			"src/interfaces/IJBPayHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBAfterPayRecordedContext} from \"./../structs/JBAfterPayRecordedContext.sol\";\n\n/// @notice Hook called after a terminal's `pay(...)` logic completes (if passed by the ruleset's data hook).\ninterface IJBPayHook is IERC165 {\n    /// @notice This function is called by the terminal's `pay(...)` function after the payment has been recorded in the\n    /// terminal store.\n    /// @dev Critical business logic should be protected by appropriate access control.\n    /// @param context The context passed in by the terminal, as a `JBAfterPayRecordedContext` struct.\n    function afterPayRecordedWith(JBAfterPayRecordedContext calldata context) external payable;\n}\n"
			},
			"src/interfaces/IJBProjects.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport {IJBTokenUriResolver} from \"./IJBTokenUriResolver.sol\";\n\ninterface IJBProjects is IERC721 {\n    event Create(uint256 indexed projectId, address indexed owner, address caller);\n\n    event SetTokenUriResolver(IJBTokenUriResolver indexed resolver, address caller);\n\n    function count() external view returns (uint256);\n\n    function tokenUriResolver() external view returns (IJBTokenUriResolver);\n\n    function createFor(address owner) external returns (uint256 projectId);\n\n    function setTokenUriResolver(IJBTokenUriResolver newResolver) external;\n}\n"
			},
			"src/interfaces/IJBSplitHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBSplitHookContext} from \"../structs/JBSplitHookContext.sol\";\n\n/// @title Split hook\n/// @notice Allows processing a single split with custom logic.\n/// @dev The split hook's address should be set as the `hook` in the relevant split.\ninterface IJBSplitHook is IERC165 {\n    /// @notice If a split has a split hook, payment terminals and controllers call this function while processing the\n    /// split.\n    /// @dev Critical business logic should be protected by appropriate access control. The tokens and/or native tokens\n    /// are optimistically transferred to the split hook when this function is called.\n    /// @param context The context passed by the terminal/controller to the split hook as a `JBSplitHookContext` struct:\n    function processSplitWith(JBSplitHookContext calldata context) external payable;\n}\n"
			},
			"src/interfaces/IJBSplits.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBSplit} from \"./../structs/JBSplit.sol\";\nimport {JBSplitGroup} from \"./../structs/JBSplitGroup.sol\";\nimport {IJBProjects} from \"./IJBProjects.sol\";\n\ninterface IJBSplits {\n    event SetSplit(\n        uint256 indexed projectId, uint256 indexed rulesetId, uint256 indexed groupId, JBSplit split, address caller\n    );\n\n    function FALLBACK_RULESET_ID() external view returns (uint256);\n\n    function splitsOf(uint256 projectId, uint256 rulesetId, uint256 groupId) external view returns (JBSplit[] memory);\n\n    function setSplitGroupsOf(uint256 projectId, uint256 rulesetId, JBSplitGroup[] memory splitGroups) external;\n}\n"
			},
			"src/interfaces/IJBTerminal.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBAccountingContext} from \"../structs/JBAccountingContext.sol\";\nimport {JBAfterPayRecordedContext} from \"../structs/JBAfterPayRecordedContext.sol\";\nimport {IJBPayHook} from \"../interfaces/IJBPayHook.sol\";\n\n/// @notice A terminal that accepts payments and can be migrated.\ninterface IJBTerminal is IERC165 {\n    event MigrateTerminal(\n        uint256 indexed projectId, address indexed token, IJBTerminal indexed to, uint256 amount, address caller\n    );\n\n    event AddToBalance(\n        uint256 indexed projectId, uint256 amount, uint256 unlockedFees, string memo, bytes metadata, address caller\n    );\n\n    event SetAccountingContext(uint256 indexed projectId, JBAccountingContext context, address caller);\n\n    event Pay(\n        uint256 indexed rulesetId,\n        uint256 indexed rulesetCycleNumber,\n        uint256 indexed projectId,\n        address payer,\n        address beneficiary,\n        uint256 amount,\n        uint256 beneficiaryTokenCount,\n        string memo,\n        bytes metadata,\n        address caller\n    );\n\n    event HookAfterRecordPay(\n        IJBPayHook indexed hook, JBAfterPayRecordedContext context, uint256 specificationAmount, address caller\n    );\n\n    function accountingContextForTokenOf(\n        uint256 projectId,\n        address token\n    )\n        external\n        view\n        returns (JBAccountingContext memory);\n\n    function accountingContextsOf(uint256 projectId) external view returns (JBAccountingContext[] memory);\n\n    function currentSurplusOf(uint256 projectId, uint256 decimals, uint256 currency) external view returns (uint256);\n\n    function migrateBalanceOf(uint256 projectId, address token, IJBTerminal to) external returns (uint256 balance);\n\n    function addAccountingContextsFor(uint256 projectId, JBAccountingContext[] calldata accountingContexts) external;\n\n    function pay(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        address beneficiary,\n        uint256 minReturnedTokens,\n        string calldata memo,\n        bytes calldata metadata\n    )\n        external\n        payable\n        returns (uint256 beneficiaryTokenCount);\n\n    function addToBalanceOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        bool shouldReturnHeldFees,\n        string calldata memo,\n        bytes calldata metadata\n    )\n        external\n        payable;\n}\n"
			},
			"src/interfaces/IJBTokenUriResolver.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBTokenUriResolver {\n    function getUri(uint256 projectId) external view returns (string memory tokenUri);\n}\n"
			},
			"src/libraries/JBConstants.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Global constants used across Juicebox contracts.\nlibrary JBConstants {\n    /// @notice Each chain's native token address in Juicebox is represented by\n    /// 0x000000000000000000000000000000000000EEEe.\n    address public constant NATIVE_TOKEN = address(0x000000000000000000000000000000000000EEEe);\n    uint16 public constant MAX_RESERVED_PERCENT = 10_000;\n    uint16 public constant MAX_REDEMPTION_RATE = 10_000;\n    uint32 public constant MAX_DECAY_PERCENT = 1_000_000_000;\n    uint32 public constant SPLITS_TOTAL_PERCENT = 1_000_000_000;\n    uint16 public constant MAX_FEE = 1000;\n}\n"
			},
			"src/structs/JBAccountingContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member token The address of the token that accounting is being done with.\n/// @custom:member decimals The number of decimals expected in that token's fixed point accounting.\n/// @custom:member currency The currency that the token is priced in terms of. By convention, this is\n/// `uint32(uint160(tokenAddress))` for tokens, or a constant ID from e.g. `JBCurrencyIds` for other currencies.\nstruct JBAccountingContext {\n    address token;\n    uint8 decimals;\n    uint32 currency;\n}\n"
			},
			"src/structs/JBAfterPayRecordedContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTokenAmount} from \"./JBTokenAmount.sol\";\n\n/// @custom:member payer The address the payment originated from.\n/// @custom:member projectId The ID of the project being paid.\n/// @custom:member rulesetId The ID of the ruleset the payment is being made during.\n/// @custom:member amount The payment's token amount. Includes the token being paid, the value, the number of decimals\n/// included, and the currency of the amount.\n/// @custom:member forwardedAmount The token amount being forwarded to the pay hook. Includes the token\n/// being paid, the value, the number of decimals included, and the currency of the amount.\n/// @custom:member weight The current ruleset's weight (used to determine how many tokens should be minted).\n/// @custom:member projectTokenCount The number of project tokens minted for the beneficiary.\n/// @custom:member beneficiary The address which receives any tokens this payment yields.\n/// @custom:member hookMetadata Extra data specified by the data hook, which is sent to the pay hook.\n/// @custom:member payerMetadata Extra data specified by the payer, which is sent to the pay hook.\nstruct JBAfterPayRecordedContext {\n    address payer;\n    uint256 projectId;\n    uint256 rulesetId;\n    JBTokenAmount amount;\n    JBTokenAmount forwardedAmount;\n    uint256 weight;\n    uint256 projectTokenCount;\n    address beneficiary;\n    bytes hookMetadata;\n    bytes payerMetadata;\n}\n"
			},
			"src/structs/JBSplit.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBSplitHook} from \"./../interfaces/IJBSplitHook.sol\";\n\n/// @notice Splits are used to send a percentage of a total token amount to a specific contract, project, or address.\n/// Splits are used to send payouts and reserved tokens.\n/// @dev 1. If a non-zero split hook contract is specified, this split's tokens are sent there along with this split's\n/// properties.\n/// @dev 2. Otherwise, if a non-zero project ID is specified, this split's tokens are used to `pay` it through its\n/// terminal if possible, or sent to the project's owner if not. If this payment yields tokens, those go to the split's\n/// `beneficiary`.\n/// @dev 3. Otherwise, this split's tokens are sent directly to the `beneficiary`.\n/// @dev To summarize, this split's tokens are sent according to the following priority: `split hook` > `projectId` >\n/// `beneficiary`.\n/// @custom:member preferAddToBalance If this split were to `pay` a project through its terminal, this flag indicates\n/// whether it should prefer using the terminal's `addToBalance` function instead.\n/// @custom:member percent The percent of the total token amount that this split sends. This number is out of\n/// `JBConstants.SPLITS_TOTAL_PERCENT`.\n/// @custom:member projectId The ID of a project to `pay`, if applicable. Resulting tokens will be routed to the\n/// `beneficiary`.\n/// @custom:member beneficiary Receives this split's tokens if the `hook` and `projectId` are zero. If the `projectId`\n/// is specified, the `beneficiary` receives any project tokens minted by this split.\n/// @custom:member lockedUntil The split cannot be changed until this timestamp. The `lockedUntil` timestamp can be\n/// increased while a split is locked. If `lockedUntil` is zero, this split can be changed at any time.\n/// @custom:member hook A contract which will receive this split's tokens and properties, and can define custom\n/// behavior.\nstruct JBSplit {\n    bool preferAddToBalance;\n    uint32 percent;\n    uint56 projectId;\n    address payable beneficiary;\n    uint48 lockedUntil;\n    IJBSplitHook hook;\n}\n"
			},
			"src/structs/JBSplitGroup.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBSplit} from \"./JBSplit.sol\";\n\n/// @custom:member groupId An identifier for the group. By convention, this ID is `uint256(uint160(tokenAddress))` for\n/// payouts and `1` for reserved tokens.\n/// @custom:member splits The splits in the group.\nstruct JBSplitGroup {\n    uint256 groupId;\n    JBSplit[] splits;\n}\n"
			},
			"src/structs/JBSplitHookContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBSplit} from \"./JBSplit.sol\";\n\n/// @custom:member token The token being sent to the split hook.\n/// @custom:member amount The amount being sent to the split hook, as a fixed point number.\n/// @custom:member decimals The number of decimals in the amount.\n/// @custom:member projectId The project the split belongs to.\n/// @custom:member groupId The group the split belongs to. By convention, this ID is `uint256(uint160(tokenAddress))`\n/// for payouts and `1` for reserved tokens.\n/// @custom:member split The split which specified the hook.\nstruct JBSplitHookContext {\n    address token;\n    uint256 amount;\n    uint256 decimals;\n    uint256 projectId;\n    uint256 groupId;\n    JBSplit split;\n}\n"
			},
			"src/structs/JBTokenAmount.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member token The token the payment was made in.\n/// @custom:member decimals The number of decimals included in the value fixed point number.\n/// @custom:member currency The currency. By convention, this is `uint32(uint160(tokenAddress))` for tokens, or a\n/// constant ID from e.g. `JBCurrencyIds` for other currencies.\n/// @custom:member value The amount of tokens that was paid, as a fixed point number.\nstruct JBTokenAmount {\n    address token;\n    uint8 decimals;\n    uint32 currency;\n    uint256 value;\n}\n"
			},
			"node_modules/@prb/math/src/Common.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\n// Common.sol\n//\n// Common mathematical functions used in both SD59x18 and UD60x18. Note that these global functions do not\n// always operate with SD59x18 and UD60x18 numbers.\n\n/*//////////////////////////////////////////////////////////////////////////\n                                CUSTOM ERRORS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Thrown when the resultant value in {mulDiv} overflows uint256.\nerror PRBMath_MulDiv_Overflow(uint256 x, uint256 y, uint256 denominator);\n\n/// @notice Thrown when the resultant value in {mulDiv18} overflows uint256.\nerror PRBMath_MulDiv18_Overflow(uint256 x, uint256 y);\n\n/// @notice Thrown when one of the inputs passed to {mulDivSigned} is `type(int256).min`.\nerror PRBMath_MulDivSigned_InputTooSmall();\n\n/// @notice Thrown when the resultant value in {mulDivSigned} overflows int256.\nerror PRBMath_MulDivSigned_Overflow(int256 x, int256 y);\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    CONSTANTS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @dev The maximum value a uint128 number can have.\nuint128 constant MAX_UINT128 = type(uint128).max;\n\n/// @dev The maximum value a uint40 number can have.\nuint40 constant MAX_UINT40 = type(uint40).max;\n\n/// @dev The unit number, which the decimal precision of the fixed-point types.\nuint256 constant UNIT = 1e18;\n\n/// @dev The unit number inverted mod 2^256.\nuint256 constant UNIT_INVERSE = 78156646155174841979727994598816262306175212592076161876661_508869554232690281;\n\n/// @dev The the largest power of two that divides the decimal value of `UNIT`. The logarithm of this value is the least significant\n/// bit in the binary representation of `UNIT`.\nuint256 constant UNIT_LPOTD = 262144;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    FUNCTIONS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Calculates the binary exponent of x using the binary fraction method.\n/// @dev Has to use 192.64-bit fixed-point numbers. See https://ethereum.stackexchange.com/a/96594/24693.\n/// @param x The exponent as an unsigned 192.64-bit fixed-point number.\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\n/// @custom:smtchecker abstract-function-nondet\nfunction exp2(uint256 x) pure returns (uint256 result) {\n    unchecked {\n        // Start from 0.5 in the 192.64-bit fixed-point format.\n        result = 0x800000000000000000000000000000000000000000000000;\n\n        // The following logic multiplies the result by $\\sqrt{2^{-i}}$ when the bit at position i is 1. Key points:\n        //\n        // 1. Intermediate results will not overflow, as the starting point is 2^191 and all magic factors are under 2^65.\n        // 2. The rationale for organizing the if statements into groups of 8 is gas savings. If the result of performing\n        // a bitwise AND operation between x and any value in the array [0x80; 0x40; 0x20; 0x10; 0x08; 0x04; 0x02; 0x01] is 1,\n        // we know that `x & 0xFF` is also 1.\n        if (x & 0xFF00000000000000 > 0) {\n            if (x & 0x8000000000000000 > 0) {\n                result = (result * 0x16A09E667F3BCC909) >> 64;\n            }\n            if (x & 0x4000000000000000 > 0) {\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\n            }\n            if (x & 0x2000000000000000 > 0) {\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\n            }\n            if (x & 0x1000000000000000 > 0) {\n                result = (result * 0x10B5586CF9890F62A) >> 64;\n            }\n            if (x & 0x800000000000000 > 0) {\n                result = (result * 0x1059B0D31585743AE) >> 64;\n            }\n            if (x & 0x400000000000000 > 0) {\n                result = (result * 0x102C9A3E778060EE7) >> 64;\n            }\n            if (x & 0x200000000000000 > 0) {\n                result = (result * 0x10163DA9FB33356D8) >> 64;\n            }\n            if (x & 0x100000000000000 > 0) {\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\n            }\n        }\n\n        if (x & 0xFF000000000000 > 0) {\n            if (x & 0x80000000000000 > 0) {\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\n            }\n            if (x & 0x40000000000000 > 0) {\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\n            }\n            if (x & 0x20000000000000 > 0) {\n                result = (result * 0x100162F3904051FA1) >> 64;\n            }\n            if (x & 0x10000000000000 > 0) {\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\n            }\n            if (x & 0x8000000000000 > 0) {\n                result = (result * 0x100058BA01FB9F96D) >> 64;\n            }\n            if (x & 0x4000000000000 > 0) {\n                result = (result * 0x10002C5CC37DA9492) >> 64;\n            }\n            if (x & 0x2000000000000 > 0) {\n                result = (result * 0x1000162E525EE0547) >> 64;\n            }\n            if (x & 0x1000000000000 > 0) {\n                result = (result * 0x10000B17255775C04) >> 64;\n            }\n        }\n\n        if (x & 0xFF0000000000 > 0) {\n            if (x & 0x800000000000 > 0) {\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\n            }\n            if (x & 0x400000000000 > 0) {\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\n            }\n            if (x & 0x200000000000 > 0) {\n                result = (result * 0x10000162E43F4F831) >> 64;\n            }\n            if (x & 0x100000000000 > 0) {\n                result = (result * 0x100000B1721BCFC9A) >> 64;\n            }\n            if (x & 0x80000000000 > 0) {\n                result = (result * 0x10000058B90CF1E6E) >> 64;\n            }\n            if (x & 0x40000000000 > 0) {\n                result = (result * 0x1000002C5C863B73F) >> 64;\n            }\n            if (x & 0x20000000000 > 0) {\n                result = (result * 0x100000162E430E5A2) >> 64;\n            }\n            if (x & 0x10000000000 > 0) {\n                result = (result * 0x1000000B172183551) >> 64;\n            }\n        }\n\n        if (x & 0xFF00000000 > 0) {\n            if (x & 0x8000000000 > 0) {\n                result = (result * 0x100000058B90C0B49) >> 64;\n            }\n            if (x & 0x4000000000 > 0) {\n                result = (result * 0x10000002C5C8601CC) >> 64;\n            }\n            if (x & 0x2000000000 > 0) {\n                result = (result * 0x1000000162E42FFF0) >> 64;\n            }\n            if (x & 0x1000000000 > 0) {\n                result = (result * 0x10000000B17217FBB) >> 64;\n            }\n            if (x & 0x800000000 > 0) {\n                result = (result * 0x1000000058B90BFCE) >> 64;\n            }\n            if (x & 0x400000000 > 0) {\n                result = (result * 0x100000002C5C85FE3) >> 64;\n            }\n            if (x & 0x200000000 > 0) {\n                result = (result * 0x10000000162E42FF1) >> 64;\n            }\n            if (x & 0x100000000 > 0) {\n                result = (result * 0x100000000B17217F8) >> 64;\n            }\n        }\n\n        if (x & 0xFF000000 > 0) {\n            if (x & 0x80000000 > 0) {\n                result = (result * 0x10000000058B90BFC) >> 64;\n            }\n            if (x & 0x40000000 > 0) {\n                result = (result * 0x1000000002C5C85FE) >> 64;\n            }\n            if (x & 0x20000000 > 0) {\n                result = (result * 0x100000000162E42FF) >> 64;\n            }\n            if (x & 0x10000000 > 0) {\n                result = (result * 0x1000000000B17217F) >> 64;\n            }\n            if (x & 0x8000000 > 0) {\n                result = (result * 0x100000000058B90C0) >> 64;\n            }\n            if (x & 0x4000000 > 0) {\n                result = (result * 0x10000000002C5C860) >> 64;\n            }\n            if (x & 0x2000000 > 0) {\n                result = (result * 0x1000000000162E430) >> 64;\n            }\n            if (x & 0x1000000 > 0) {\n                result = (result * 0x10000000000B17218) >> 64;\n            }\n        }\n\n        if (x & 0xFF0000 > 0) {\n            if (x & 0x800000 > 0) {\n                result = (result * 0x1000000000058B90C) >> 64;\n            }\n            if (x & 0x400000 > 0) {\n                result = (result * 0x100000000002C5C86) >> 64;\n            }\n            if (x & 0x200000 > 0) {\n                result = (result * 0x10000000000162E43) >> 64;\n            }\n            if (x & 0x100000 > 0) {\n                result = (result * 0x100000000000B1721) >> 64;\n            }\n            if (x & 0x80000 > 0) {\n                result = (result * 0x10000000000058B91) >> 64;\n            }\n            if (x & 0x40000 > 0) {\n                result = (result * 0x1000000000002C5C8) >> 64;\n            }\n            if (x & 0x20000 > 0) {\n                result = (result * 0x100000000000162E4) >> 64;\n            }\n            if (x & 0x10000 > 0) {\n                result = (result * 0x1000000000000B172) >> 64;\n            }\n        }\n\n        if (x & 0xFF00 > 0) {\n            if (x & 0x8000 > 0) {\n                result = (result * 0x100000000000058B9) >> 64;\n            }\n            if (x & 0x4000 > 0) {\n                result = (result * 0x10000000000002C5D) >> 64;\n            }\n            if (x & 0x2000 > 0) {\n                result = (result * 0x1000000000000162E) >> 64;\n            }\n            if (x & 0x1000 > 0) {\n                result = (result * 0x10000000000000B17) >> 64;\n            }\n            if (x & 0x800 > 0) {\n                result = (result * 0x1000000000000058C) >> 64;\n            }\n            if (x & 0x400 > 0) {\n                result = (result * 0x100000000000002C6) >> 64;\n            }\n            if (x & 0x200 > 0) {\n                result = (result * 0x10000000000000163) >> 64;\n            }\n            if (x & 0x100 > 0) {\n                result = (result * 0x100000000000000B1) >> 64;\n            }\n        }\n\n        if (x & 0xFF > 0) {\n            if (x & 0x80 > 0) {\n                result = (result * 0x10000000000000059) >> 64;\n            }\n            if (x & 0x40 > 0) {\n                result = (result * 0x1000000000000002C) >> 64;\n            }\n            if (x & 0x20 > 0) {\n                result = (result * 0x10000000000000016) >> 64;\n            }\n            if (x & 0x10 > 0) {\n                result = (result * 0x1000000000000000B) >> 64;\n            }\n            if (x & 0x8 > 0) {\n                result = (result * 0x10000000000000006) >> 64;\n            }\n            if (x & 0x4 > 0) {\n                result = (result * 0x10000000000000003) >> 64;\n            }\n            if (x & 0x2 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n            if (x & 0x1 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n        }\n\n        // In the code snippet below, two operations are executed simultaneously:\n        //\n        // 1. The result is multiplied by $(2^n + 1)$, where $2^n$ represents the integer part, and the additional 1\n        // accounts for the initial guess of 0.5. This is achieved by subtracting from 191 instead of 192.\n        // 2. The result is then converted to an unsigned 60.18-decimal fixed-point format.\n        //\n        // The underlying logic is based on the relationship $2^{191-ip} = 2^{ip} / 2^{191}$, where $ip$ denotes the,\n        // integer part, $2^n$.\n        result *= UNIT;\n        result >>= (191 - (x >> 64));\n    }\n}\n\n/// @notice Finds the zero-based index of the first 1 in the binary representation of x.\n///\n/// @dev See the note on \"msb\" in this Wikipedia article: https://en.wikipedia.org/wiki/Find_first_set\n///\n/// Each step in this implementation is equivalent to this high-level code:\n///\n/// ```solidity\n/// if (x >= 2 ** 128) {\n///     x >>= 128;\n///     result += 128;\n/// }\n/// ```\n///\n/// Where 128 is replaced with each respective power of two factor. See the full high-level implementation here:\n/// https://gist.github.com/PaulRBerg/f932f8693f2733e30c4d479e8e980948\n///\n/// The Yul instructions used below are:\n///\n/// - \"gt\" is \"greater than\"\n/// - \"or\" is the OR bitwise operator\n/// - \"shl\" is \"shift left\"\n/// - \"shr\" is \"shift right\"\n///\n/// @param x The uint256 number for which to find the index of the most significant bit.\n/// @return result The index of the most significant bit as a uint256.\n/// @custom:smtchecker abstract-function-nondet\nfunction msb(uint256 x) pure returns (uint256 result) {\n    // 2^128\n    assembly (\"memory-safe\") {\n        let factor := shl(7, gt(x, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^64\n    assembly (\"memory-safe\") {\n        let factor := shl(6, gt(x, 0xFFFFFFFFFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^32\n    assembly (\"memory-safe\") {\n        let factor := shl(5, gt(x, 0xFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^16\n    assembly (\"memory-safe\") {\n        let factor := shl(4, gt(x, 0xFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^8\n    assembly (\"memory-safe\") {\n        let factor := shl(3, gt(x, 0xFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^4\n    assembly (\"memory-safe\") {\n        let factor := shl(2, gt(x, 0xF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^2\n    assembly (\"memory-safe\") {\n        let factor := shl(1, gt(x, 0x3))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^1\n    // No need to shift x any more.\n    assembly (\"memory-safe\") {\n        let factor := gt(x, 0x1)\n        result := or(result, factor)\n    }\n}\n\n/// @notice Calculates x*ydenominator with 512-bit precision.\n///\n/// @dev Credits to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n///\n/// Notes:\n/// - The result is rounded toward zero.\n///\n/// Requirements:\n/// - The denominator must not be zero.\n/// - The result must fit in uint256.\n///\n/// @param x The multiplicand as a uint256.\n/// @param y The multiplier as a uint256.\n/// @param denominator The divisor as a uint256.\n/// @return result The result as a uint256.\n/// @custom:smtchecker abstract-function-nondet\nfunction mulDiv(uint256 x, uint256 y, uint256 denominator) pure returns (uint256 result) {\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n    // use the Chinese Remainder Theorem to reconstruct the 512-bit result. The result is stored in two 256\n    // variables such that product = prod1 * 2^256 + prod0.\n    uint256 prod0; // Least significant 256 bits of the product\n    uint256 prod1; // Most significant 256 bits of the product\n    assembly (\"memory-safe\") {\n        let mm := mulmod(x, y, not(0))\n        prod0 := mul(x, y)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    // Handle non-overflow cases, 256 by 256 division.\n    if (prod1 == 0) {\n        unchecked {\n            return prod0 / denominator;\n        }\n    }\n\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\n    if (prod1 >= denominator) {\n        revert PRBMath_MulDiv_Overflow(x, y, denominator);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n    // 512 by 256 division\n    ////////////////////////////////////////////////////////////////////////////\n\n    // Make division exact by subtracting the remainder from [prod1 prod0].\n    uint256 remainder;\n    assembly (\"memory-safe\") {\n        // Compute remainder using the mulmod Yul instruction.\n        remainder := mulmod(x, y, denominator)\n\n        // Subtract 256 bit number from 512-bit number.\n        prod1 := sub(prod1, gt(remainder, prod0))\n        prod0 := sub(prod0, remainder)\n    }\n\n    unchecked {\n        // Calculate the largest power of two divisor of the denominator using the unary operator ~. This operation cannot overflow\n        // because the denominator cannot be zero at this point in the function execution. The result is always >= 1.\n        // For more detail, see https://cs.stackexchange.com/q/138556/92363.\n        uint256 lpotdod = denominator & (~denominator + 1);\n        uint256 flippedLpotdod;\n\n        assembly (\"memory-safe\") {\n            // Factor powers of two out of denominator.\n            denominator := div(denominator, lpotdod)\n\n            // Divide [prod1 prod0] by lpotdod.\n            prod0 := div(prod0, lpotdod)\n\n            // Get the flipped value `2^256 / lpotdod`. If the `lpotdod` is zero, the flipped value is one.\n            // `sub(0, lpotdod)` produces the two's complement version of `lpotdod`, which is equivalent to flipping all the bits.\n            // However, `div` interprets this value as an unsigned value: https://ethereum.stackexchange.com/q/147168/24693\n            flippedLpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n        }\n\n        // Shift in bits from prod1 into prod0.\n        prod0 |= prod1 * flippedLpotdod;\n\n        // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n        // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n        // four bits. That is, denominator * inv = 1 mod 2^4.\n        uint256 inverse = (3 * denominator) ^ 2;\n\n        // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n        // in modular arithmetic, doubling the correct bits in each step.\n        inverse *= 2 - denominator * inverse; // inverse mod 2^8\n        inverse *= 2 - denominator * inverse; // inverse mod 2^16\n        inverse *= 2 - denominator * inverse; // inverse mod 2^32\n        inverse *= 2 - denominator * inverse; // inverse mod 2^64\n        inverse *= 2 - denominator * inverse; // inverse mod 2^128\n        inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n        // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n        // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n        // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inverse;\n    }\n}\n\n/// @notice Calculates x*y1e18 with 512-bit precision.\n///\n/// @dev A variant of {mulDiv} with constant folding, i.e. in which the denominator is hard coded to 1e18.\n///\n/// Notes:\n/// - The body is purposely left uncommented; to understand how this works, see the documentation in {mulDiv}.\n/// - The result is rounded toward zero.\n/// - We take as an axiom that the result cannot be `MAX_UINT256` when x and y solve the following system of equations:\n///\n/// $$\n/// \\begin{cases}\n///     x * y = MAX\\_UINT256 * UNIT \\\\\n///     (x * y) \\% UNIT \\geq \\frac{UNIT}{2}\n/// \\end{cases}\n/// $$\n///\n/// Requirements:\n/// - Refer to the requirements in {mulDiv}.\n/// - The result must fit in uint256.\n///\n/// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n/// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\n/// @custom:smtchecker abstract-function-nondet\nfunction mulDiv18(uint256 x, uint256 y) pure returns (uint256 result) {\n    uint256 prod0;\n    uint256 prod1;\n    assembly (\"memory-safe\") {\n        let mm := mulmod(x, y, not(0))\n        prod0 := mul(x, y)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    if (prod1 == 0) {\n        unchecked {\n            return prod0 / UNIT;\n        }\n    }\n\n    if (prod1 >= UNIT) {\n        revert PRBMath_MulDiv18_Overflow(x, y);\n    }\n\n    uint256 remainder;\n    assembly (\"memory-safe\") {\n        remainder := mulmod(x, y, UNIT)\n        result :=\n            mul(\n                or(\n                    div(sub(prod0, remainder), UNIT_LPOTD),\n                    mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, UNIT_LPOTD), UNIT_LPOTD), 1))\n                ),\n                UNIT_INVERSE\n            )\n    }\n}\n\n/// @notice Calculates x*ydenominator with 512-bit precision.\n///\n/// @dev This is an extension of {mulDiv} for signed numbers, which works by computing the signs and the absolute values separately.\n///\n/// Notes:\n/// - The result is rounded toward zero.\n///\n/// Requirements:\n/// - Refer to the requirements in {mulDiv}.\n/// - None of the inputs can be `type(int256).min`.\n/// - The result must fit in int256.\n///\n/// @param x The multiplicand as an int256.\n/// @param y The multiplier as an int256.\n/// @param denominator The divisor as an int256.\n/// @return result The result as an int256.\n/// @custom:smtchecker abstract-function-nondet\nfunction mulDivSigned(int256 x, int256 y, int256 denominator) pure returns (int256 result) {\n    if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\n        revert PRBMath_MulDivSigned_InputTooSmall();\n    }\n\n    // Get hold of the absolute values of x, y and the denominator.\n    uint256 xAbs;\n    uint256 yAbs;\n    uint256 dAbs;\n    unchecked {\n        xAbs = x < 0 ? uint256(-x) : uint256(x);\n        yAbs = y < 0 ? uint256(-y) : uint256(y);\n        dAbs = denominator < 0 ? uint256(-denominator) : uint256(denominator);\n    }\n\n    // Compute the absolute value of x*ydenominator. The result must fit in int256.\n    uint256 resultAbs = mulDiv(xAbs, yAbs, dAbs);\n    if (resultAbs > uint256(type(int256).max)) {\n        revert PRBMath_MulDivSigned_Overflow(x, y);\n    }\n\n    // Get the signs of x, y and the denominator.\n    uint256 sx;\n    uint256 sy;\n    uint256 sd;\n    assembly (\"memory-safe\") {\n        // \"sgt\" is the \"signed greater than\" assembly instruction and \"sub(0,1)\" is -1 in two's complement.\n        sx := sgt(x, sub(0, 1))\n        sy := sgt(y, sub(0, 1))\n        sd := sgt(denominator, sub(0, 1))\n    }\n\n    // XOR over sx, sy and sd. What this does is to check whether there are 1 or 3 negative signs in the inputs.\n    // If there are, the result should be negative. Otherwise, it should be positive.\n    unchecked {\n        result = sx ^ sy ^ sd == 0 ? -int256(resultAbs) : int256(resultAbs);\n    }\n}\n\n/// @notice Calculates the square root of x using the Babylonian method.\n///\n/// @dev See https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n///\n/// Notes:\n/// - If x is not a perfect square, the result is rounded down.\n/// - Credits to OpenZeppelin for the explanations in comments below.\n///\n/// @param x The uint256 number for which to calculate the square root.\n/// @return result The result as a uint256.\n/// @custom:smtchecker abstract-function-nondet\nfunction sqrt(uint256 x) pure returns (uint256 result) {\n    if (x == 0) {\n        return 0;\n    }\n\n    // For our first guess, we calculate the biggest power of 2 which is smaller than the square root of x.\n    //\n    // We know that the \"msb\" (most significant bit) of x is a power of 2 such that we have:\n    //\n    // $$\n    // msb(x) <= x <= 2*msb(x)$\n    // $$\n    //\n    // We write $msb(x)$ as $2^k$, and we get:\n    //\n    // $$\n    // k = log_2(x)\n    // $$\n    //\n    // Thus, we can write the initial inequality as:\n    //\n    // $$\n    // 2^{log_2(x)} <= x <= 2*2^{log_2(x)+1} \\\\\n    // sqrt(2^k) <= sqrt(x) < sqrt(2^{k+1}) \\\\\n    // 2^{k/2} <= sqrt(x) < 2^{(k+1)/2} <= 2^{(k/2)+1}\n    // $$\n    //\n    // Consequently, $2^{log_2(x) /2} is a good first approximation of sqrt(x) with at least one correct bit.\n    uint256 xAux = uint256(x);\n    result = 1;\n    if (xAux >= 2 ** 128) {\n        xAux >>= 128;\n        result <<= 64;\n    }\n    if (xAux >= 2 ** 64) {\n        xAux >>= 64;\n        result <<= 32;\n    }\n    if (xAux >= 2 ** 32) {\n        xAux >>= 32;\n        result <<= 16;\n    }\n    if (xAux >= 2 ** 16) {\n        xAux >>= 16;\n        result <<= 8;\n    }\n    if (xAux >= 2 ** 8) {\n        xAux >>= 8;\n        result <<= 4;\n    }\n    if (xAux >= 2 ** 4) {\n        xAux >>= 4;\n        result <<= 2;\n    }\n    if (xAux >= 2 ** 2) {\n        result <<= 1;\n    }\n\n    // At this point, `result` is an estimation with at least one bit of precision. We know the true value has at\n    // most 128 bits, since it is the square root of a uint256. Newton's method converges quadratically (precision\n    // doubles at every iteration). We thus need at most 7 iteration to turn our partial result with one bit of\n    // precision into the expected uint128 result.\n    unchecked {\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n\n        // If x is not a perfect square, round the result toward zero.\n        uint256 roundedResult = x / result;\n        if (result >= roundedResult) {\n            result = roundedResult;\n        }\n    }\n}\n"
			},
			"src/JBRulesets.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {mulDiv} from \"@prb/math/src/Common.sol\";\n\nimport {JBControlled} from \"./abstract/JBControlled.sol\";\nimport {JBApprovalStatus} from \"./enums/JBApprovalStatus.sol\";\nimport {IJBDirectory} from \"./interfaces/IJBDirectory.sol\";\nimport {IJBRulesetApprovalHook} from \"./interfaces/IJBRulesetApprovalHook.sol\";\nimport {IJBRulesets} from \"./interfaces/IJBRulesets.sol\";\nimport {JBConstants} from \"./libraries/JBConstants.sol\";\nimport {JBRuleset} from \"./structs/JBRuleset.sol\";\nimport {JBRulesetWeightCache} from \"./structs/JBRulesetWeightCache.sol\";\n\n/// @notice Manages rulesets and queuing.\n/// @dev Rulesets dictate how a project behaves for a period of time. To learn more about their functionality, see the\n/// `JBRuleset` data structure.\n/// @dev Throughout this contract, `rulesetId` is an identifier for each ruleset. The `rulesetId` is the unix timestamp\n/// when the ruleset was initialized.\n/// @dev `approvable` means a ruleset which may or may not be approved.\ncontract JBRulesets is JBControlled, IJBRulesets {\n    //*********************************************************************//\n    // --------------------------- custom errors ------------------------- //\n    //*********************************************************************//\n    error INVALID_RULESET_APPROVAL_HOOK();\n    error INVALID_DECAY_PERCENT();\n    error INVALID_RULESET_DURATION();\n    error INVALID_RULESET_END_TIME();\n    error INVALID_WEIGHT();\n\n    //*********************************************************************//\n    // ------------------------- internal constants ----------------------- //\n    //*********************************************************************//\n\n    /// @notice The maximum number of decay percent multiples that can be cached at a time.\n    uint256 internal constant _MAX_DECAY_MULTIPLE_CACHE_THRESHOLD = 50_000;\n\n    /// @notice The number of decay percent multiples before a cached value is sought.\n    uint256 internal constant _DECAY_MULTIPLE_CACHE_LOOKUP_THRESHOLD = 1000;\n\n    //*********************************************************************//\n    // --------------------- public stored properties -------------------- //\n    //*********************************************************************//\n\n    /// @notice The ID of the ruleset with the latest start time for a specific project, whether the ruleset has been\n    /// approved or not.\n    /// @dev If a project has multiple rulesets queued, the `latestRulesetIdOf` will be the last one. This is the\n    /// \"changeable\" cycle.\n    /// @custom:param projectId The ID of the project to get the latest ruleset ID of.\n    /// @return latestRulesetIdOf The `rulesetId` of the project's latest ruleset.\n    mapping(uint256 projectId => uint256) public override latestRulesetIdOf;\n\n    //*********************************************************************//\n    // --------------------- internal stored properties ------------------- //\n    //*********************************************************************//\n\n    /// @notice The user-defined properties of each ruleset, packed into one storage slot.\n    /// @custom:param projectId The ID of the project to get the user-defined properties of.\n    /// @custom:param rulesetId The ID of the ruleset to get the user-defined properties of.\n    mapping(uint256 projectId => mapping(uint256 rulesetId => uint256)) internal _packedUserPropertiesOf;\n\n    /// @notice The mechanism-added properties to manage and schedule each ruleset, packed into one storage slot.\n    /// @custom:param projectId The ID of the project to get the intrinsic properties of.\n    /// @custom:param rulesetId The ID of the ruleset to get the intrinsic properties of.\n    mapping(uint256 projectId => mapping(uint256 rulesetId => uint256)) internal _packedIntrinsicPropertiesOf;\n\n    /// @notice The metadata for each ruleset, packed into one storage slot.\n    /// @custom:param projectId The ID of the project to get metadata of.\n    /// @custom:param rulesetId The ID of the ruleset to get metadata of.\n    mapping(uint256 projectId => mapping(uint256 rulesetId => uint256)) internal _metadataOf;\n\n    /// @notice Cached weight values to derive rulesets from.\n    /// @custom:param projectId The ID of the project to which the cache applies.\n    /// @custom:param rulesetId The ID of the ruleset to which the cache applies.\n    mapping(uint256 projectId => mapping(uint256 rulesetId => JBRulesetWeightCache)) internal _weightCacheOf;\n\n    //*********************************************************************//\n    // ------------------------- external views -------------------------- //\n    //*********************************************************************//\n\n    /// @notice Get the ruleset struct for a given `rulesetId` and `projectId`.\n    /// @param projectId The ID of the project to which the ruleset belongs.\n    /// @param rulesetId The ID of the ruleset to get the struct of.\n    /// @return ruleset The ruleset struct.\n    function getRulesetOf(\n        uint256 projectId,\n        uint256 rulesetId\n    )\n        external\n        view\n        override\n        returns (JBRuleset memory ruleset)\n    {\n        return _getStructFor(projectId, rulesetId);\n    }\n\n    /// @notice The latest ruleset queued for a project. Returns the ruleset's struct and its current approval status.\n    /// @dev Returns struct and status for the ruleset initialized furthest in the future (at the end of the rulset\n    /// queue).\n    /// @param projectId The ID of the project to get the latest queued ruleset of.\n    /// @return ruleset The project's latest queued ruleset's struct.\n    /// @return approvalStatus The approval hook's status for the ruleset.\n    function latestQueuedOf(uint256 projectId)\n        external\n        view\n        override\n        returns (JBRuleset memory ruleset, JBApprovalStatus approvalStatus)\n    {\n        // Get a reference to the latest ruleset's ID.\n        uint256 rulesetId = latestRulesetIdOf[projectId];\n\n        // Resolve the struct for the latest ruleset.\n        ruleset = _getStructFor(projectId, rulesetId);\n\n        // Resolve the approval status.\n        approvalStatus = _approvalStatusOf({\n            projectId: projectId,\n            rulesetId: ruleset.id,\n            start: ruleset.start,\n            approvalHookRulesetId: ruleset.basedOnId\n        });\n    }\n\n    /// @notice Get an array of a project's rulesets up to a maximum array size, sorted from latest to earliest.\n    /// @param projectId The ID of the project to get the rulesets of.\n    /// @param startingId The ID of the ruleset to begin with. This will be the latest ruleset in the result. If 0 is\n    /// passed, the project's latest ruleset will be used.\n    /// @param size The maximum number of rulesets to return.\n    /// @return rulesets The rulesets as an array of `JBRuleset` structs.\n    function rulesetsOf(\n        uint256 projectId,\n        uint256 startingId,\n        uint256 size\n    )\n        external\n        view\n        override\n        returns (JBRuleset[] memory rulesets)\n    {\n        // If no starting ID was provided, set it to the latest ruleset's ID.\n        if (startingId == 0) startingId = latestRulesetIdOf[projectId];\n\n        // Keep a reference to the number of rulesets being returned.\n        uint256 count = 0;\n\n        // Keep a reference to the starting ruleset.\n        JBRuleset memory ruleset = _getStructFor(projectId, startingId);\n\n        // First, count the number of rulesets to include in the result by iterating backwards from the starting\n        // ruleset.\n        while (ruleset.id != 0 && count < size) {\n            // Increment the counter.\n            count++;\n\n            // Iterate to the ruleset it was based on.\n            ruleset = _getStructFor(projectId, ruleset.basedOnId);\n        }\n\n        // Keep a reference to the array of rulesets that'll be populated.\n        rulesets = new JBRuleset[](count);\n\n        // Return an empty array if there are no rulesets to return.\n        if (count == 0) {\n            return rulesets;\n        }\n\n        // Reset the ruleset being iterated on to the starting ruleset.\n        ruleset = _getStructFor(projectId, startingId);\n\n        // Set the counter.\n        uint256 i;\n\n        // Populate the array of rulesets to return.\n        while (i < count) {\n            // Add the ruleset to the array.\n            rulesets[i++] = ruleset;\n\n            // Get the ruleset it was based on if needed.\n            if (i != count) ruleset = _getStructFor(projectId, ruleset.basedOnId);\n        }\n    }\n\n    /// @notice The ruleset that's up next for a project.\n    /// @dev If an upcoming ruleset is not found for the project, returns an empty ruleset with all properties set to 0.\n    /// @param projectId The ID of the project to get the upcoming ruleset of.\n    /// @return ruleset The struct for the project's upcoming ruleset.\n    function upcomingOf(uint256 projectId) external view override returns (JBRuleset memory ruleset) {\n        // If the project does not have a latest ruleset, return an empty struct.\n        // slither-disable-next-line incorrect-equality\n        if (latestRulesetIdOf[projectId] == 0) return _getStructFor(0, 0);\n\n        // Get a reference to the upcoming approvable ruleset's ID.\n        uint256 upcomingApprovableRulesetId = _upcomingApprovableRulesetIdOf(projectId);\n\n        // Keep a reference to its approval status.\n        JBApprovalStatus approvalStatus;\n\n        // If an upcoming approvable ruleset has been queued, and it's approval status is Approved or ApprovalExpected,\n        // return its ruleset struct\n        if (upcomingApprovableRulesetId != 0) {\n            ruleset = _getStructFor(projectId, upcomingApprovableRulesetId);\n\n            // Get a reference to the approval status.\n            approvalStatus = _approvalStatusOf(projectId, ruleset);\n\n            // If the approval hook is empty, expects approval, or has approved the ruleset, return it.\n            if (\n                approvalStatus == JBApprovalStatus.Approved || approvalStatus == JBApprovalStatus.ApprovalExpected\n                    || approvalStatus == JBApprovalStatus.Empty\n            ) return ruleset;\n\n            // Resolve the ruleset for the ruleset the upcoming approvable ruleset was based on.\n            ruleset = _getStructFor(projectId, ruleset.basedOnId);\n        } else {\n            // Resolve the ruleset for the latest queued ruleset.\n            ruleset = _getStructFor(projectId, latestRulesetIdOf[projectId]);\n\n            // If the latest ruleset starts in the future, it must start in the distant future\n            // Since its not the upcoming approvable ruleset. In this case, base the upcoming ruleset on the base\n            // ruleset.\n            while (ruleset.start > block.timestamp) {\n                ruleset = _getStructFor(projectId, ruleset.basedOnId);\n            }\n        }\n\n        // There's no queued if the current has a duration of 0.\n        if (ruleset.duration == 0) return _getStructFor(0, 0);\n\n        // Get a reference to the approval status.\n        approvalStatus = _approvalStatusOf(projectId, ruleset);\n\n        // Check to see if this ruleset's approval hook hasn't failed.\n        // If so, return a ruleset based on it.\n        if (approvalStatus == JBApprovalStatus.Approved || approvalStatus == JBApprovalStatus.Empty) {\n            return _simulateCycledRulesetBasedOn({projectId: projectId, baseRuleset: ruleset, allowMidRuleset: false});\n        }\n\n        // Get the ruleset of its base ruleset, which carries the last approved configuration.\n        ruleset = _getStructFor(projectId, ruleset.basedOnId);\n\n        // There's no queued if the base, which must still be the current, has a duration of 0.\n        if (ruleset.duration == 0) return _getStructFor(0, 0);\n\n        // Return a simulated cycled ruleset.\n        return _simulateCycledRulesetBasedOn({projectId: projectId, baseRuleset: ruleset, allowMidRuleset: false});\n    }\n\n    /// @notice The ruleset that is currently active for the specified project.\n    /// @dev If a current ruleset of the project is not found, returns an empty ruleset with all properties set to 0.\n    /// @param projectId The ID of the project to get the current ruleset of.\n    /// @return ruleset The project's current ruleset.\n    function currentOf(uint256 projectId) external view override returns (JBRuleset memory ruleset) {\n        // If the project does not have a ruleset, return an empty struct.\n        // slither-disable-next-line incorrect-equality\n        if (latestRulesetIdOf[projectId] == 0) return _getStructFor(0, 0);\n\n        // Get a reference to the currently approvable ruleset's ID.\n        uint256 rulesetId = _currentlyApprovableRulesetIdOf(projectId);\n\n        // If a currently approvable ruleset exists...\n        if (rulesetId != 0) {\n            // Resolve the struct for the currently approvable ruleset.\n            ruleset = _getStructFor(projectId, rulesetId);\n\n            // Get a reference to the approval status.\n            JBApprovalStatus approvalStatus = _approvalStatusOf(projectId, ruleset);\n\n            // Check to see if this ruleset's approval hook is approved if it exists.\n            // If so, return it.\n            if (approvalStatus == JBApprovalStatus.Approved || approvalStatus == JBApprovalStatus.Empty) {\n                return ruleset;\n            }\n\n            // If it hasn't been approved, set the ruleset configuration to be the configuration of the ruleset that\n            // it's based on,\n            // which carries the last approved configuration.\n            rulesetId = ruleset.basedOnId;\n\n            // Keep a reference to its ruleset.\n            ruleset = _getStructFor(projectId, rulesetId);\n        } else {\n            // No upcoming ruleset found that is currently approvable,\n            // so use the latest ruleset ID.\n            rulesetId = latestRulesetIdOf[projectId];\n\n            // Get the struct for the latest ID.\n            ruleset = _getStructFor(projectId, rulesetId);\n\n            // Get a reference to the approval status.\n            JBApprovalStatus approvalStatus = _approvalStatusOf(projectId, ruleset);\n\n            // While the ruleset has a approval hook that isn't approved or if it hasn't yet started, get a reference to\n            // the ruleset that the latest is based on, which has the latest approved configuration.\n            while (\n                (approvalStatus != JBApprovalStatus.Approved && approvalStatus != JBApprovalStatus.Empty)\n                    || block.timestamp < ruleset.start\n            ) {\n                rulesetId = ruleset.basedOnId;\n                ruleset = _getStructFor(projectId, rulesetId);\n                approvalStatus = _approvalStatusOf(projectId, ruleset);\n            }\n        }\n\n        // If the base has no duration, it's still the current one.\n        if (ruleset.duration == 0) return ruleset;\n\n        // Return a simulation of the current ruleset.\n        return _simulateCycledRulesetBasedOn({projectId: projectId, baseRuleset: ruleset, allowMidRuleset: true});\n    }\n\n    /// @notice The current approval status of a given project's latest ruleset.\n    /// @param projectId The ID of the project to check the approval status of.\n    /// @return The project's current approval status.\n    function currentApprovalStatusForLatestRulesetOf(uint256 projectId)\n        external\n        view\n        override\n        returns (JBApprovalStatus)\n    {\n        // Get a reference to the latest ruleset ID.\n        uint256 rulesetId = latestRulesetIdOf[projectId];\n\n        // Resolve the struct for the latest ruleset.\n        JBRuleset memory ruleset = _getStructFor(projectId, rulesetId);\n\n        return _approvalStatusOf({\n            projectId: projectId,\n            rulesetId: ruleset.id,\n            start: ruleset.start,\n            approvalHookRulesetId: ruleset.basedOnId\n        });\n    }\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param directory A contract storing directories of terminals and controllers for each project.\n    // solhint-disable-next-line no-empty-blocks\n    constructor(IJBDirectory directory) JBControlled(directory) {}\n\n    //*********************************************************************//\n    // ---------------------- external transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice Queues the upcoming approvable ruleset for the specified project.\n    /// @dev Only a project's current controller can queue its rulesets.\n    /// @param projectId The ID of the project to queue the ruleset for.\n    /// @param duration The number of seconds the ruleset lasts for, after which a new ruleset starts.\n    /// - A `duration` of 0 means this ruleset will remain active until the project owner queues a new ruleset. That new\n    /// ruleset will start immediately.\n    /// - A ruleset with a non-zero `duration` applies until the duration ends  any newly queued rulesets will be\n    /// *queued* to take effect afterwards.\n    /// - If a duration ends and no new rulesets are queued, the ruleset rolls over to a new ruleset with the same rules\n    /// (except for a new `start` timestamp and a decayed `weight`).\n    /// @param weight A fixed point number with 18 decimals that contracts can use to base arbitrary calculations on.\n    /// Payment terminals generally use this to determine how many tokens should be minted when the project is paid.\n    /// @param decayPercent A fraction (out of `JBConstants.MAX_DECAY_PERCENT`) to reduce the next ruleset's `weight`\n    /// by.\n    /// - If a ruleset specifies a non-zero `weight`, the `decayPercent` does not apply.\n    /// - If the `decayPercent` is 0, the `weight` stays the same.\n    /// - If the `decayPercent` is 10% of `JBConstants.MAX_DECAY_PERCENT`, next ruleset's `weight` will be 90% of the\n    /// current\n    /// one.\n    /// @param approvalHook A contract which dictates whether a proposed ruleset should be accepted or rejected. It can\n    /// be used to constrain a project owner's ability to change ruleset parameters over time.\n    /// @param metadata Arbitrary extra data to associate with this ruleset. This metadata is not used by `JBRulesets`.\n    /// @param mustStartAtOrAfter The earliest time the ruleset can start. The ruleset cannot start before this\n    /// timestamp.\n    /// @return The struct of the new ruleset.\n    function queueFor(\n        uint256 projectId,\n        uint256 duration,\n        uint256 weight,\n        uint256 decayPercent,\n        IJBRulesetApprovalHook approvalHook,\n        uint256 metadata,\n        uint256 mustStartAtOrAfter\n    )\n        external\n        override\n        onlyControllerOf(projectId)\n        returns (JBRuleset memory)\n    {\n        // Duration must fit in a uint32.\n        if (duration > type(uint32).max) revert INVALID_RULESET_DURATION();\n\n        // Decay rate must be less than or equal to 100%.\n        if (decayPercent > JBConstants.MAX_DECAY_PERCENT) {\n            revert INVALID_DECAY_PERCENT();\n        }\n\n        // Weight must fit into a uint112.\n        if (weight > type(uint112).max) revert INVALID_WEIGHT();\n\n        // If the start date is not set, set it to be the current timestamp.\n        if (mustStartAtOrAfter == 0) {\n            mustStartAtOrAfter = block.timestamp;\n        }\n\n        // Make sure the min start date fits in a uint48, and that the start date of the following ruleset will also fit\n        // within the max.\n        if (mustStartAtOrAfter + duration > type(uint48).max) {\n            revert INVALID_RULESET_END_TIME();\n        }\n\n        // Approval hook should be a valid contract, supporting the correct interface\n        if (approvalHook != IJBRulesetApprovalHook(address(0))) {\n            // Revert if there isn't a contract at the address\n            if (address(approvalHook).code.length == 0) revert INVALID_RULESET_APPROVAL_HOOK();\n\n            // Make sure the approval hook supports the expected interface.\n            try approvalHook.supportsInterface(type(IJBRulesetApprovalHook).interfaceId) returns (bool doesSupport) {\n                if (!doesSupport) revert INVALID_RULESET_APPROVAL_HOOK(); // Contract exists at the address but with the\n                    // wrong interface\n            } catch {\n                revert INVALID_RULESET_APPROVAL_HOOK(); // No ERC165 support\n            }\n        }\n\n        // Get a reference to the latest ruleset's ID.\n        uint256 latestId = latestRulesetIdOf[projectId];\n\n        // The new rulesetId timestamp is now, or an increment from now if the current timestamp is taken.\n        uint256 rulesetId = latestId >= block.timestamp ? latestId + 1 : block.timestamp;\n\n        // Set up the ruleset by configuring intrinsic properties.\n        _configureIntrinsicPropertiesFor(projectId, rulesetId, weight, mustStartAtOrAfter);\n\n        // Efficiently stores the ruleset's user-defined properties.\n        // If all user config properties are zero, no need to store anything as the default value will have the same\n        // outcome.\n        if (approvalHook != IJBRulesetApprovalHook(address(0)) || duration > 0 || decayPercent > 0) {\n            // approval hook in bits 0-159 bytes.\n            uint256 packed = uint160(address(approvalHook));\n\n            // duration in bits 160-191 bytes.\n            packed |= duration << 160;\n\n            // decayPercent in bits 192-223 bytes.\n            packed |= decayPercent << 192;\n\n            // Set in storage.\n            _packedUserPropertiesOf[projectId][rulesetId] = packed;\n        }\n\n        // Set the metadata if needed.\n        if (metadata > 0) _metadataOf[projectId][rulesetId] = metadata;\n\n        emit RulesetQueued(\n            rulesetId, projectId, duration, weight, decayPercent, approvalHook, metadata, mustStartAtOrAfter, msg.sender\n        );\n\n        // Return the struct for the new ruleset's ID.\n        return _getStructFor(projectId, rulesetId);\n    }\n\n    /// @notice Cache the value of the ruleset weight.\n    /// @param projectId The ID of the project having its ruleset weight cached.\n    function updateRulesetWeightCache(uint256 projectId) external override {\n        // Keep a reference to the struct for the latest queued ruleset.\n        // The cached value will be based on this struct.\n        JBRuleset memory latestQueuedRuleset = _getStructFor(projectId, latestRulesetIdOf[projectId]);\n\n        // Nothing to cache if the latest ruleset doesn't have a duration or a decay percent.\n        if (latestQueuedRuleset.duration == 0 || latestQueuedRuleset.decayPercent == 0) return;\n\n        // Get a reference to the current cache.\n        JBRulesetWeightCache storage cache = _weightCacheOf[projectId][latestQueuedRuleset.id];\n\n        // Determine the largest start timestamp the cache can be filled to.\n        uint256 maxStart = latestQueuedRuleset.start\n            + (cache.decayMultiple + _MAX_DECAY_MULTIPLE_CACHE_THRESHOLD) * latestQueuedRuleset.duration;\n\n        // Determine the start timestamp to derive a weight from for the cache.\n        uint256 start = block.timestamp < maxStart ? block.timestamp : maxStart;\n\n        // The difference between the start of the latest queued ruleset and the start of the ruleset we're caching the\n        // weight of.\n        uint256 startDistance = start - latestQueuedRuleset.start;\n\n        // Calculate the decay multiple.\n        uint168 decayMultiple;\n        unchecked {\n            decayMultiple = uint168(startDistance / latestQueuedRuleset.duration);\n        }\n\n        // Store the new values.\n        cache.weight =\n            uint112(_deriveWeightFrom({projectId: projectId, baseRuleset: latestQueuedRuleset, start: start}));\n        cache.decayMultiple = decayMultiple;\n    }\n\n    //*********************************************************************//\n    // --------------------- internal helper functions ------------------- //\n    //*********************************************************************//\n\n    /// @notice Updates the latest ruleset for this project if it exists. If there is no ruleset, initializes one.\n    /// @param projectId The ID of the project to update the latest ruleset for.\n    /// @param rulesetId The timestamp of when the ruleset was queued.\n    /// @param weight The weight to store in the queued ruleset.\n    /// @param mustStartAtOrAfter The earliest time the ruleset can start. The ruleset cannot start before this\n    /// timestamp.\n    function _configureIntrinsicPropertiesFor(\n        uint256 projectId,\n        uint256 rulesetId,\n        uint256 weight,\n        uint256 mustStartAtOrAfter\n    )\n        internal\n    {\n        // Keep a reference to the project's latest ruleset's ID.\n        uint256 latestId = latestRulesetIdOf[projectId];\n\n        // If the project doesn't have a ruleset yet, initialize one.\n        // slither-disable-next-line incorrect-equality\n        if (latestId == 0) {\n            // Use an empty ruleset as the base.\n            return _initializeRulesetFor({\n                projectId: projectId,\n                baseRuleset: _getStructFor(0, 0),\n                rulesetId: rulesetId,\n                mustStartAtOrAfter: mustStartAtOrAfter,\n                weight: weight\n            });\n        }\n\n        // Get a reference to the latest ruleset's struct.\n        JBRuleset memory baseRuleset = _getStructFor(projectId, latestId);\n\n        // Get a reference to the approval status.\n        JBApprovalStatus approvalStatus = _approvalStatusOf(projectId, baseRuleset);\n\n        // If the base ruleset has started but wasn't approved if a approval hook exists\n        // OR it hasn't started but is currently approved\n        // OR it hasn't started but it is likely to be approved and takes place before the proposed one,\n        // set the struct to be the ruleset it's based on, which carries the latest approved ruleset.\n        if (\n            (\n                block.timestamp >= baseRuleset.start && approvalStatus != JBApprovalStatus.Approved\n                    && approvalStatus != JBApprovalStatus.Empty\n            )\n                || (\n                    block.timestamp < baseRuleset.start && mustStartAtOrAfter < baseRuleset.start + baseRuleset.duration\n                        && approvalStatus != JBApprovalStatus.Approved\n                )\n                || (\n                    block.timestamp < baseRuleset.start && mustStartAtOrAfter >= baseRuleset.start + baseRuleset.duration\n                        && approvalStatus != JBApprovalStatus.Approved && approvalStatus != JBApprovalStatus.ApprovalExpected\n                        && approvalStatus != JBApprovalStatus.Empty\n                )\n        ) {\n            baseRuleset = _getStructFor(projectId, baseRuleset.basedOnId);\n        }\n\n        // The time when the duration of the base ruleset's approval hook has finished.\n        // If the provided ruleset has no approval hook, return 0 (no constraint on start time).\n        uint256 timestampAfterApprovalHook = baseRuleset.approvalHook == IJBRulesetApprovalHook(address(0))\n            ? 0\n            : rulesetId + baseRuleset.approvalHook.DURATION();\n\n        _initializeRulesetFor({\n            projectId: projectId,\n            baseRuleset: baseRuleset,\n            rulesetId: rulesetId,\n            // Can only start after the approval hook.\n            mustStartAtOrAfter: timestampAfterApprovalHook > mustStartAtOrAfter\n                ? timestampAfterApprovalHook\n                : mustStartAtOrAfter,\n            weight: weight\n        });\n    }\n\n    /// @notice Initializes a ruleset with the specified properties.\n    /// @param projectId The ID of the project to initialize the ruleset for.\n    /// @param baseRuleset The ruleset struct to base the newly initialized one on.\n    /// @param rulesetId The `rulesetId` for the ruleset being initialized.\n    /// @param mustStartAtOrAfter The earliest time the ruleset can start. The ruleset cannot start before this\n    /// timestamp.\n    /// @param weight The weight to give the newly initialized ruleset.\n    function _initializeRulesetFor(\n        uint256 projectId,\n        JBRuleset memory baseRuleset,\n        uint256 rulesetId,\n        uint256 mustStartAtOrAfter,\n        uint256 weight\n    )\n        internal\n    {\n        // If there is no base, initialize a first ruleset.\n        if (baseRuleset.cycleNumber == 0) {\n            // Set fresh intrinsic properties.\n            _packAndStoreIntrinsicPropertiesOf({\n                rulesetId: rulesetId,\n                projectId: projectId,\n                rulesetCycleNumber: 1,\n                weight: weight,\n                basedOnId: baseRuleset.id,\n                start: mustStartAtOrAfter\n            });\n        } else {\n            // Derive the correct next start time from the base.\n            uint256 start = _deriveStartFrom(baseRuleset, mustStartAtOrAfter);\n\n            // A weight of 1 is treated as a weight of 0.\n            // This is to allow a weight of 0 (default) to represent inheriting the decayed weight of the previous\n            // ruleset.\n            weight = weight > 0 ? (weight == 1 ? 0 : weight) : _deriveWeightFrom(projectId, baseRuleset, start);\n\n            // Derive the correct ruleset cycle number.\n            uint256 rulesetCycleNumber = _deriveCycleNumberFrom(baseRuleset, start);\n\n            // Update the intrinsic properties.\n            _packAndStoreIntrinsicPropertiesOf({\n                rulesetId: rulesetId,\n                projectId: projectId,\n                rulesetCycleNumber: rulesetCycleNumber,\n                weight: weight,\n                basedOnId: baseRuleset.id,\n                start: start\n            });\n        }\n\n        // Set the project's latest ruleset configuration.\n        latestRulesetIdOf[projectId] = rulesetId;\n\n        emit RulesetInitialized(rulesetId, projectId, baseRuleset.id);\n    }\n\n    /// @notice Efficiently stores the provided intrinsic properties of a ruleset.\n    /// @param rulesetId The `rulesetId` of the ruleset to pack and store for.\n    /// @param projectId The ID of the project the ruleset belongs to.\n    /// @param rulesetCycleNumber The cycle number of the ruleset.\n    /// @param weight The weight of the ruleset.\n    /// @param basedOnId The `rulesetId` of the ruleset this ruleset was based on.\n    /// @param start The start time of this ruleset.\n    function _packAndStoreIntrinsicPropertiesOf(\n        uint256 rulesetId,\n        uint256 projectId,\n        uint256 rulesetCycleNumber,\n        uint256 weight,\n        uint256 basedOnId,\n        uint256 start\n    )\n        internal\n    {\n        // `weight` in bits 0-111.\n        uint256 packed = weight;\n\n        // `basedOnId` in bits 112-159.\n        packed |= basedOnId << 112;\n\n        // `start` in bits 160-207.\n        packed |= start << 160;\n\n        // cycle number in bits 208-255.\n        packed |= rulesetCycleNumber << 208;\n\n        // Store the packed value.\n        _packedIntrinsicPropertiesOf[projectId][rulesetId] = packed;\n    }\n\n    /// @notice The ruleset up next for a project, if one exists, whether or not that ruleset has been approved.\n    /// @dev A value of 0 is returned if no ruleset was found.\n    /// @dev Assumes the project has a `latestRulesetIdOf` value.\n    /// @param projectId The ID of the project to check for an upcoming approvable ruleset.\n    /// @return rulesetId The `rulesetId` of the upcoming approvable ruleset if one exists, or 0 if one doesn't exist.\n    function _upcomingApprovableRulesetIdOf(uint256 projectId) internal view returns (uint256 rulesetId) {\n        // Get a reference to the ID of the project's latest ruleset.\n        rulesetId = latestRulesetIdOf[projectId];\n\n        // Get the struct for the latest ruleset.\n        JBRuleset memory ruleset = _getStructFor(projectId, rulesetId);\n\n        // There is no upcoming ruleset if the latest ruleset has already started.\n        if (block.timestamp >= ruleset.start) return 0;\n\n        // If this is the first ruleset, it is queued.\n        if (ruleset.cycleNumber == 1) return rulesetId;\n\n        // Get a reference to the ID of the ruleset the latest ruleset was based on.\n        uint256 basedOnId = ruleset.basedOnId;\n\n        // Get the necessary properties for the base ruleset.\n        JBRuleset memory baseRuleset;\n\n        // Find the base ruleset that is not still queued.\n        while (true) {\n            baseRuleset = _getStructFor(projectId, basedOnId);\n\n            // If the base ruleset starts in the future,\n            if (block.timestamp < baseRuleset.start) {\n                // Set the `rulesetId` to the one found.\n                rulesetId = baseRuleset.id;\n                // Check the ruleset it was based on in the next iteration.\n                basedOnId = baseRuleset.basedOnId;\n            } else {\n                // Break out of the loop when a base ruleset which has already started is found.\n                break;\n            }\n        }\n\n        // Get the ruleset struct for the ID found.\n        ruleset = _getStructFor(projectId, rulesetId);\n\n        // If the latest ruleset doesn't start until after another base ruleset return 0.\n        if (baseRuleset.duration != 0 && block.timestamp < ruleset.start - baseRuleset.duration) {\n            return 0;\n        }\n    }\n\n    /// @notice The ID of the ruleset which has started and hasn't expired yet, whether or not it has been approved, for\n    /// a given project. If approved, this is the active ruleset.\n    /// @dev A value of 0 is returned if no ruleset was found.\n    /// @dev Assumes the project has a latest ruleset.\n    /// @param projectId The ID of the project to check for a currently approvable ruleset.\n    /// @return The ID of a currently approvable ruleset if one exists, or 0 if one doesn't exist.\n    function _currentlyApprovableRulesetIdOf(uint256 projectId) internal view returns (uint256) {\n        // Get a reference to the project's latest ruleset.\n        uint256 rulesetId = latestRulesetIdOf[projectId];\n\n        // Get the struct for the latest ruleset.\n        JBRuleset memory ruleset = _getStructFor(projectId, rulesetId);\n\n        // Loop through all most recently queued rulesets until an approvable one is found, or we've proven one can't\n        // exist.\n        do {\n            // If the latest ruleset is expired, return an empty ruleset.\n            // A ruleset with a duration of 0 cannot expire.\n            if (ruleset.duration != 0 && block.timestamp >= ruleset.start + ruleset.duration) {\n                return 0;\n            }\n\n            // Return the ruleset's `rulesetId` if it has started.\n            if (block.timestamp >= ruleset.start) {\n                return ruleset.id;\n            }\n\n            ruleset = _getStructFor(projectId, ruleset.basedOnId);\n        } while (ruleset.cycleNumber != 0);\n\n        return 0;\n    }\n\n    /// @notice A simulated view of the ruleset that would be created if the provided one cycled over (if the project\n    /// doesn't queue a new ruleset).\n    /// @dev Returns an empty ruleset if a ruleset can't be simulated based on the provided one.\n    /// @dev Assumes a simulated ruleset will never be based on a ruleset with a duration of 0.\n    /// @param projectId The ID of the project of the ruleset.\n    /// @param baseRuleset The ruleset that the simulated ruleset should be based on.\n    /// @param allowMidRuleset A flag indicating if the simulated ruleset is allowed to already be mid ruleset.\n    /// @return A simulated ruleset struct: the next ruleset by default. This will be overwritten if a new ruleset is\n    /// queued for the project.\n    function _simulateCycledRulesetBasedOn(\n        uint256 projectId,\n        JBRuleset memory baseRuleset,\n        bool allowMidRuleset\n    )\n        internal\n        view\n        returns (JBRuleset memory)\n    {\n        // Get the distance from the current time to the start of the next possible ruleset.\n        // If the simulated ruleset must not yet have started, the start time of the simulated ruleset must be in the\n        // future.\n        uint256 mustStartAtOrAfter = !allowMidRuleset ? block.timestamp + 1 : block.timestamp - baseRuleset.duration + 1;\n\n        // Calculate what the start time should be.\n        uint256 start = _deriveStartFrom(baseRuleset, mustStartAtOrAfter);\n\n        // Calculate what the cycle number should be.\n        uint256 rulesetCycleNumber = _deriveCycleNumberFrom(baseRuleset, start);\n\n        return JBRuleset({\n            cycleNumber: uint48(rulesetCycleNumber),\n            id: baseRuleset.id,\n            basedOnId: baseRuleset.basedOnId,\n            start: uint48(start),\n            duration: baseRuleset.duration,\n            weight: uint112(_deriveWeightFrom(projectId, baseRuleset, start)),\n            decayPercent: baseRuleset.decayPercent,\n            approvalHook: baseRuleset.approvalHook,\n            metadata: baseRuleset.metadata\n        });\n    }\n\n    /// @notice The date that is the nearest multiple of the base ruleset's duration from the start of the next cycle.\n    /// @param baseRuleset The ruleset to base the calculation on (the previous ruleset).\n    /// @param mustStartAtOrAfter The earliest time the next ruleset can start. The ruleset cannot start before this\n    /// timestamp.\n    /// @return start The next start time.\n    function _deriveStartFrom(\n        JBRuleset memory baseRuleset,\n        uint256 mustStartAtOrAfter\n    )\n        internal\n        pure\n        returns (uint256 start)\n    {\n        // A subsequent ruleset to one with a duration of 0 should start as soon as possible.\n        if (baseRuleset.duration == 0) return mustStartAtOrAfter;\n\n        // The time when the ruleset immediately after the specified ruleset starts.\n        uint256 nextImmediateStart = baseRuleset.start + baseRuleset.duration;\n\n        // If the next immediate start is now or in the future, return it.\n        if (nextImmediateStart >= mustStartAtOrAfter) {\n            return nextImmediateStart;\n        }\n\n        // The amount of seconds since the `mustStartAtOrAfter` time which results in a start time that might satisfy\n        // the specified limits.\n        // slither-disable-next-line weak-prng\n        uint256 timeFromImmediateStartMultiple = (mustStartAtOrAfter - nextImmediateStart) % baseRuleset.duration;\n\n        // A reference to the first possible start timestamp.\n        start = mustStartAtOrAfter - timeFromImmediateStartMultiple;\n\n        // Add increments of duration as necessary to satisfy the threshold.\n        while (mustStartAtOrAfter > start) {\n            start = start + baseRuleset.duration;\n        }\n    }\n\n    /// @notice The accumulated weight change since the specified ruleset.\n    /// @param projectId The ID of the project to which the ruleset weights apply.\n    /// @param baseRuleset The ruleset to base the calculation on (the previous ruleset).\n    /// @param start The start time of the ruleset to derive a weight for.\n    /// @return weight The derived weight, as a fixed point number with 18 decimals.\n    function _deriveWeightFrom(\n        uint256 projectId,\n        JBRuleset memory baseRuleset,\n        uint256 start\n    )\n        internal\n        view\n        returns (uint256 weight)\n    {\n        // A subsequent ruleset to one with a duration of 0 should have the next possible weight.\n        if (baseRuleset.duration == 0) {\n            return mulDiv(\n                baseRuleset.weight,\n                JBConstants.MAX_DECAY_PERCENT - baseRuleset.decayPercent,\n                JBConstants.MAX_DECAY_PERCENT\n            );\n        }\n\n        // The weight should be based off the base ruleset's weight.\n        weight = baseRuleset.weight;\n\n        // If the decay is 0, the weight doesn't change.\n        if (baseRuleset.decayPercent == 0) return weight;\n\n        // The difference between the start of the base ruleset and the proposed start.\n        uint256 startDistance = start - baseRuleset.start;\n\n        // Apply the base ruleset's decay percent for each ruleset that has passed.\n        uint256 decayMultiple;\n        unchecked {\n            decayMultiple = startDistance / baseRuleset.duration; // Non-null duration is excluded above\n        }\n\n        // Check the cache if needed.\n        if (decayMultiple > _DECAY_MULTIPLE_CACHE_LOOKUP_THRESHOLD) {\n            // Get a cached weight for the rulesetId.\n            JBRulesetWeightCache memory cache = _weightCacheOf[projectId][baseRuleset.id];\n\n            // If a cached value is available, use it.\n            if (cache.decayMultiple > 0) {\n                // Set the starting weight to be the cached value.\n                weight = cache.weight;\n\n                // Set the decay multiple to be the difference between the cached value and the total decay multiple\n                // that should be applied.\n                decayMultiple -= cache.decayMultiple;\n            }\n        }\n\n        for (uint256 i; i < decayMultiple; i++) {\n            // The number of times to apply the decay percent.\n            // Base the new weight on the specified ruleset's weight.\n            weight =\n                mulDiv(weight, JBConstants.MAX_DECAY_PERCENT - baseRuleset.decayPercent, JBConstants.MAX_DECAY_PERCENT);\n\n            // The calculation doesn't need to continue if the weight is 0.\n            if (weight == 0) break;\n        }\n    }\n\n    /// @notice The cycle number of the next ruleset given the specified ruleset.\n    /// @dev Each time a ruleset starts, whether it was queued or cycled over, the cycle number is incremented by 1.\n    /// @param baseRuleset The previously queued ruleset, to base the calculation on.\n    /// @param start The start time of the ruleset to derive a cycle number for.\n    /// @return The ruleset's cycle number.\n    function _deriveCycleNumberFrom(JBRuleset memory baseRuleset, uint256 start) internal pure returns (uint256) {\n        // A subsequent ruleset to one with a duration of 0 should be the next number.\n        if (baseRuleset.duration == 0) {\n            return baseRuleset.cycleNumber + 1;\n        }\n\n        // The difference between the start of the base ruleset and the proposed start.\n        uint256 startDistance = start - baseRuleset.start;\n\n        // Find the number of base rulesets that fit in the start distance.\n        return baseRuleset.cycleNumber + (startDistance / baseRuleset.duration);\n    }\n\n    /// @notice The approval status of a given project and ruleset struct according to the relevant approval hook.\n    /// @param projectId The ID of the project that the ruleset belongs to.\n    /// @param ruleset The ruleset to get an approval flag for.\n    /// @return The approval status of the project's ruleset.\n    function _approvalStatusOf(uint256 projectId, JBRuleset memory ruleset) internal view returns (JBApprovalStatus) {\n        return _approvalStatusOf({\n            projectId: projectId,\n            rulesetId: ruleset.id,\n            start: ruleset.start,\n            approvalHookRulesetId: ruleset.basedOnId\n        });\n    }\n\n    /// @notice The approval status of a given ruleset (ID) for a given project (ID).\n    /// @param projectId The ID of the project the ruleset belongs to.\n    /// @param rulesetId The ID of the ruleset to get the approval status of.\n    /// @param start The start time of the ruleset to get the approval status of.\n    /// @param approvalHookRulesetId The ID of the ruleset with the approval hook that should be checked against.\n    /// @return The approval status of the project.\n    function _approvalStatusOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        uint256 start,\n        uint256 approvalHookRulesetId\n    )\n        internal\n        view\n        returns (JBApprovalStatus)\n    {\n        // If there is no ruleset ID to check the approval hook of, the approval hook is empty.\n        if (approvalHookRulesetId == 0) return JBApprovalStatus.Empty;\n\n        // Get the struct of the ruleset with the approval hook.\n        JBRuleset memory approvalHookRuleset = _getStructFor(projectId, approvalHookRulesetId);\n\n        // If there is no approval hook, it's considered empty.\n        if (approvalHookRuleset.approvalHook == IJBRulesetApprovalHook(address(0))) {\n            return JBApprovalStatus.Empty;\n        }\n\n        // Return the approval hook's approval status.\n        return approvalHookRuleset.approvalHook.approvalStatusOf(projectId, rulesetId, start);\n    }\n\n    /// @notice Unpack a ruleset's packed stored values into an easy-to-work-with ruleset struct.\n    /// @param projectId The ID of the project the ruleset belongs to.\n    /// @param rulesetId The ID of the ruleset to get the full struct for.\n    /// @return ruleset A ruleset struct.\n    function _getStructFor(uint256 projectId, uint256 rulesetId) internal view returns (JBRuleset memory ruleset) {\n        // Return an empty ruleset if the specified `rulesetId` is 0.\n        // slither-disable-next-line incorrect-equality\n        if (rulesetId == 0) return ruleset;\n\n        ruleset.id = uint48(rulesetId);\n\n        uint256 packedIntrinsicProperties = _packedIntrinsicPropertiesOf[projectId][rulesetId];\n\n        // `weight` in bits 0-111 bits.\n        ruleset.weight = uint112(packedIntrinsicProperties);\n        // `basedOnId` in bits 112-159 bits.\n        ruleset.basedOnId = uint48(packedIntrinsicProperties >> 112);\n        // `start` in bits 160-207 bits.\n        ruleset.start = uint48(packedIntrinsicProperties >> 160);\n        // `cycleNumber` in bits 208-255 bits.\n        ruleset.cycleNumber = uint48(packedIntrinsicProperties >> 208);\n\n        uint256 packedUserProperties = _packedUserPropertiesOf[projectId][rulesetId];\n\n        // approval hook in bits 0-159 bits.\n        ruleset.approvalHook = IJBRulesetApprovalHook(address(uint160(packedUserProperties)));\n        // `duration` in bits 160-191 bits.\n        ruleset.duration = uint32(packedUserProperties >> 160);\n        // decay percent in bits 192-223 bits.\n        ruleset.decayPercent = uint32(packedUserProperties >> 192);\n\n        ruleset.metadata = _metadataOf[projectId][rulesetId];\n    }\n}\n"
			},
			"src/enums/JBApprovalStatus.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice A ruleset's approval status in a ruleset approval hook.\nenum JBApprovalStatus {\n    Empty,\n    Upcoming,\n    Active,\n    ApprovalExpected,\n    Approved,\n    Failed\n}\n"
			},
			"src/interfaces/IJBRulesetApprovalHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBApprovalStatus} from \"./../enums/JBApprovalStatus.sol\";\n\n/// @notice `IJBRulesetApprovalHook`s are used to determine whether the next ruleset in the ruleset queue is approved or\n/// rejected.\n/// @dev Project rulesets are stored in a queue. Rulesets take effect after the previous ruleset in the queue ends, and\n/// only if they are approved by the previous ruleset's approval hook.\ninterface IJBRulesetApprovalHook is IERC165 {\n    function DURATION() external view returns (uint256);\n\n    function approvalStatusOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        uint256 start\n    )\n        external\n        view\n        returns (JBApprovalStatus);\n}\n"
			},
			"src/interfaces/IJBRulesets.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBApprovalStatus} from \"./../enums/JBApprovalStatus.sol\";\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {IJBRulesetApprovalHook} from \"./IJBRulesetApprovalHook.sol\";\n\ninterface IJBRulesets {\n    event RulesetQueued(\n        uint256 indexed rulesetId,\n        uint256 indexed projectId,\n        uint256 duration,\n        uint256 weight,\n        uint256 decayPercent,\n        IJBRulesetApprovalHook hook,\n        uint256 metadata,\n        uint256 mustStartAtOrAfter,\n        address caller\n    );\n\n    event RulesetInitialized(uint256 indexed rulesetId, uint256 indexed projectId, uint256 indexed basedOnId);\n\n    function latestRulesetIdOf(uint256 projectId) external view returns (uint256);\n\n    function getRulesetOf(uint256 projectId, uint256 rulesetId) external view returns (JBRuleset memory);\n\n    function latestQueuedOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory ruleset, JBApprovalStatus approvalStatus);\n\n    function rulesetsOf(\n        uint256 projectId,\n        uint256 startingId,\n        uint256 size\n    )\n        external\n        view\n        returns (JBRuleset[] memory rulesets);\n\n    function upcomingOf(uint256 projectId) external view returns (JBRuleset memory ruleset);\n\n    function currentOf(uint256 projectId) external view returns (JBRuleset memory ruleset);\n\n    function currentApprovalStatusForLatestRulesetOf(uint256 projectId) external view returns (JBApprovalStatus);\n\n    function queueFor(\n        uint256 projectId,\n        uint256 duration,\n        uint256 weight,\n        uint256 decayPercent,\n        IJBRulesetApprovalHook approvalHook,\n        uint256 metadata,\n        uint256 mustStartAtOrAfter\n    )\n        external\n        returns (JBRuleset memory ruleset);\n\n    function updateRulesetWeightCache(uint256 projectId) external;\n}\n"
			},
			"src/structs/JBRuleset.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBRulesetApprovalHook} from \"./../interfaces/IJBRulesetApprovalHook.sol\";\n\n/// @dev `JBRuleset` timestamps are unix timestamps (seconds since 00:00 January 1st, 1970 UTC).\n/// @custom:member cycleNumber The ruleset's cycle number. Each ruleset's `cycleNumber` is the previous ruleset's\n/// `cycleNumber` plus one. Each project's first ruleset has a `cycleNumber` of 1.\n/// @custom:member id The ruleset's ID, which is a timestamp of when this ruleset's rules were initialized. The\n/// `rulesetId` stays the same for rulesets that automatically cycle over from a manually queued ruleset.\n/// @custom:member basedOnId The `rulesetId` of the ruleset which was active when this ruleset was created.\n/// @custom:member start The timestamp from which this ruleset is considered active.\n/// @custom:member duration The number of seconds the ruleset lasts for. After this duration, a new ruleset will start.\n/// The project owner can queue new rulesets at any time, which will take effect once the current ruleset's duration is\n/// over. If the `duration` is 0, newly queued rulesets will take effect immediately. If a ruleset ends and there are no\n/// new rulesets queued, the current ruleset cycles over to another one with the same properties but a new `start`\n/// timestamp and a `weight` reduced by the ruleset's `decayPercent`.\n/// @custom:member weight A fixed point number with 18 decimals which is typically used by payment terminals to\n/// determine how many tokens should be minted when a payment is received. This can be used by other contracts for\n/// arbitrary calculations.\n/// @custom:member decayPercent The percentage by which to reduce the `weight` each time a new ruleset starts. `weight`\n/// is\n/// a percentage out of `JBConstants.MAX_DECAY_PERCENT`. If it's 0, the next ruleset will have the same `weight` by\n/// default. If it's 90%, the next ruleset's `weight` will be 10% smaller. If a ruleset explicitly sets a new `weight`,\n/// the `decayPercent` doesn't apply.\n/// @custom:member approvalHook An address of a contract that says whether a queued ruleset should be approved or\n/// rejected. If a\n/// ruleset is rejected, it won't go into effect. An approval hook can be used to create rules which dictate how a\n/// project owner can change their ruleset over time.\n/// @custom:member metadata Extra data associated with a ruleset which can be used by other contracts.\nstruct JBRuleset {\n    uint48 cycleNumber;\n    uint48 id;\n    uint48 basedOnId;\n    uint48 start;\n    uint32 duration;\n    uint112 weight;\n    uint32 decayPercent;\n    IJBRulesetApprovalHook approvalHook;\n    uint256 metadata;\n}\n"
			},
			"src/structs/JBRulesetWeightCache.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member weight The cached weight value.\n/// @custom:member decayMultiple The decay multiple that produces the given weight.\nstruct JBRulesetWeightCache {\n    uint112 weight;\n    uint168 decayMultiple;\n}\n"
			},
			"node_modules/@bananapus/permission-ids/src/JBPermissionIds.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Permission IDs for `JBPermissions`, used throughout the Bananapus ecosystem. See\n/// [`JBPermissions`](https://github.com/Bananapus/nana-core/blob/main/src/JBPermissions.sol)\n/// @dev `JBPermissions` allows one address to grant another address permission to call functions in Juicebox contracts\n/// on their behalf. Each ID in `JBPermissionIds` grants access to a specific set of these functions.\nlibrary JBPermissionIds {\n    uint8 internal constant ROOT = 1; // All permissions across every contract. Very dangerous. BE CAREFUL!\n\n    /* Used by `nana-core`: https://github.com/Bananapus/nana-core */\n    uint8 internal constant QUEUE_RULESETS = 2; // Permission to call `JBController.queueRulesetsOf` and\n        // `JBController.launchRulesetsFor`.\n    uint8 internal constant REDEEM_TOKENS = 3; // Permission to call `JBMultiTerminal.redeemTokensOf`.\n    uint8 internal constant SEND_PAYOUTS = 4; // Permission to call `JBMultiTerminal.sendPayoutsOf`.\n    uint8 internal constant MIGRATE_TERMINAL = 5; // Permission to call `JBMultiTerminal.migrateBalanceOf`.\n    uint8 internal constant SET_PROJECT_URI = 6; // Permission to call `JBController.setUriOf`.\n    uint8 internal constant DEPLOY_ERC20 = 7; // Permission to call `JBController.deployERC20For`.\n    uint8 internal constant SET_TOKEN = 8; // Permission to call `JBController.setTokenFor`.\n    uint8 internal constant MINT_TOKENS = 9; // Permission to call `JBController.mintTokensOf`.\n    uint8 internal constant BURN_TOKENS = 10; // Permission to call `JBController.burnTokensOf`.\n    uint8 internal constant CLAIM_TOKENS = 11; // Permission to call `JBController.claimTokensFor`.\n    uint8 internal constant TRANSFER_CREDITS = 12; // Permission to call `JBController.transferCreditsFrom`.\n    uint8 internal constant SET_CONTROLLER = 13; // Permission to call `JBDirectory.setControllerOf`.\n    uint8 internal constant SET_TERMINALS = 14; // Permission to call `JBDirectory.setTerminalsOf`.\n    // Be careful - `SET_TERMINALS` can be used to remove the primary terminal.\n    uint8 internal constant SET_PRIMARY_TERMINAL = 15; // Permission to call `JBDirectory.setPrimaryTerminalOf`.\n    uint8 internal constant USE_ALLOWANCE = 16; // Permission to call `JBMultiTerminal.useAllowanceOf`.\n    uint8 internal constant SET_SPLIT_GROUPS = 17; // Permission to call `JBController.setSplitGroupsOf`.\n    uint8 internal constant ADD_PRICE_FEED = 18; // Permission to call `JBPrices.addPriceFeedFor`.\n    uint8 internal constant ADD_ACCOUNTING_CONTEXTS = 19; // Permission to call\n        // `JBMultiTerminal.addAccountingContextsFor`.\n\n    /* Used by `nana-721-hook`: https://github.com/Bananapus/nana-721-hook */\n    uint8 internal constant ADJUST_721_TIERS = 20; // Permission to call `JB721TiersHook.adjustTiers`.\n    uint8 internal constant SET_721_METADATA = 21; // Permission to call `JB721TiersHook.setMetadata`.\n    uint8 internal constant MINT_721 = 22; // Permission to call `JB721TiersHook.mintFor`.\n\n    /* Used by `nana-buyback-hook`: https://github.com/Bananapus/nana-buyback-hook */\n    uint8 internal constant SET_BUYBACK_TWAP = 23; // Permission to call `JBBuybackHook.setTwapWindowOf` and\n        // `JBBuybackHook.setTwapSlippageToleranceOf`.\n    uint8 internal constant SET_BUYBACK_POOL = 24; // Permission to call `JBBuybackHook.setPoolFor`.\n\n    /* Used by `nana-swap-terminal`: https://github.com/Bananapus/nana-swap-terminal */\n    uint8 internal constant ADD_SWAP_TERMINAL_POOL = 25; // Permission to call `JBSwapTerminal.addDefaultPool`.\n    uint8 internal constant ADD_SWAP_TERMINAL_TWAP_PARAMS = 26; // Permission to call\n        // `JBSwapTerminal.addTwapParamsFor`.\n\n    /* Used by `nana-suckers`: https://github.com/Bananapus/nana-suckers */\n    uint8 internal constant MAP_SUCKER_TOKEN = 27; // Permission to call `BPSucker.mapToken`.\n    uint8 internal constant DEPLOY_SUCKERS = 28; // Permission to call `BPSuckerRegistry.deploySuckersFor`.\n}\n"
			},
			"node_modules/@openzeppelin/contracts/metatx/ERC2771Context.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (metatx/ERC2771Context.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Context variant with ERC2771 support.\n *\n * WARNING: Avoid using this pattern in contracts that rely in a specific calldata length as they'll\n * be affected by any forwarder whose `msg.data` is suffixed with the `from` address according to the ERC2771\n * specification adding the address size in bytes (20) to the calldata size. An example of an unexpected\n * behavior could be an unintended fallback (or another function) invocation while trying to invoke the `receive`\n * function only accessible if `msg.data.length == 0`.\n *\n * WARNING: The usage of `delegatecall` in this contract is dangerous and may result in context corruption.\n * Any forwarded request to this contract triggering a `delegatecall` to itself will result in an invalid {_msgSender}\n * recovery.\n */\nabstract contract ERC2771Context is Context {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable _trustedForwarder;\n\n    /**\n     * @dev Initializes the contract with a trusted forwarder, which will be able to\n     * invoke functions on this contract on behalf of other accounts.\n     *\n     * NOTE: The trusted forwarder can be replaced by overriding {trustedForwarder}.\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address trustedForwarder_) {\n        _trustedForwarder = trustedForwarder_;\n    }\n\n    /**\n     * @dev Returns the address of the trusted forwarder.\n     */\n    function trustedForwarder() public view virtual returns (address) {\n        return _trustedForwarder;\n    }\n\n    /**\n     * @dev Indicates whether any particular address is the trusted forwarder.\n     */\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\n        return forwarder == trustedForwarder();\n    }\n\n    /**\n     * @dev Override for `msg.sender`. Defaults to the original `msg.sender` whenever\n     * a call is not performed by the trusted forwarder or the calldata length is less than\n     * 20 bytes (an address length).\n     */\n    function _msgSender() internal view virtual override returns (address) {\n        uint256 calldataLength = msg.data.length;\n        uint256 contextSuffixLength = _contextSuffixLength();\n        if (isTrustedForwarder(msg.sender) && calldataLength >= contextSuffixLength) {\n            return address(bytes20(msg.data[calldataLength - contextSuffixLength:]));\n        } else {\n            return super._msgSender();\n        }\n    }\n\n    /**\n     * @dev Override for `msg.data`. Defaults to the original `msg.data` whenever\n     * a call is not performed by the trusted forwarder or the calldata length is less than\n     * 20 bytes (an address length).\n     */\n    function _msgData() internal view virtual override returns (bytes calldata) {\n        uint256 calldataLength = msg.data.length;\n        uint256 contextSuffixLength = _contextSuffixLength();\n        if (isTrustedForwarder(msg.sender) && calldataLength >= contextSuffixLength) {\n            return msg.data[:calldataLength - contextSuffixLength];\n        } else {\n            return super._msgData();\n        }\n    }\n\n    /**\n     * @dev ERC-2771 specifies the context as being a single address (20 bytes).\n     */\n    function _contextSuffixLength() internal view virtual override returns (uint256) {\n        return 20;\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/Address.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/Context.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
			},
			"src/JBController.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {JBPermissionIds} from \"@bananapus/permission-ids/src/JBPermissionIds.sol\";\nimport {ERC2771Context} from \"@openzeppelin/contracts/metatx/ERC2771Context.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {mulDiv} from \"@prb/math/src/Common.sol\";\n\nimport {JBPermissioned} from \"./abstract/JBPermissioned.sol\";\nimport {JBApprovalStatus} from \"./enums/JBApprovalStatus.sol\";\nimport {IJBController} from \"./interfaces/IJBController.sol\";\nimport {IJBDirectory} from \"./interfaces/IJBDirectory.sol\";\nimport {IJBDirectoryAccessControl} from \"./interfaces/IJBDirectoryAccessControl.sol\";\nimport {IJBFundAccessLimits} from \"./interfaces/IJBFundAccessLimits.sol\";\nimport {IJBMigratable} from \"./interfaces/IJBMigratable.sol\";\nimport {IJBPermissioned} from \"./interfaces/IJBPermissioned.sol\";\nimport {IJBPermissions} from \"./interfaces/IJBPermissions.sol\";\nimport {IJBPriceFeed} from \"./interfaces/IJBPriceFeed.sol\";\nimport {IJBPrices} from \"./interfaces/IJBPrices.sol\";\nimport {IJBProjects} from \"./interfaces/IJBProjects.sol\";\nimport {IJBProjectUriRegistry} from \"./interfaces/IJBProjectUriRegistry.sol\";\nimport {IJBRulesets} from \"./interfaces/IJBRulesets.sol\";\nimport {IJBRulesetDataHook} from \"./interfaces/IJBRulesetDataHook.sol\";\nimport {IJBSplitHook} from \"./interfaces/IJBSplitHook.sol\";\nimport {IJBSplits} from \"./interfaces/IJBSplits.sol\";\nimport {IJBTerminal} from \"./interfaces/IJBTerminal.sol\";\nimport {IJBToken} from \"./interfaces/IJBToken.sol\";\nimport {IJBTokens} from \"./interfaces/IJBTokens.sol\";\nimport {JBConstants} from \"./libraries/JBConstants.sol\";\nimport {JBRulesetMetadataResolver} from \"./libraries/JBRulesetMetadataResolver.sol\";\nimport {JBSplitGroupIds} from \"./libraries/JBSplitGroupIds.sol\";\nimport {JBRuleset} from \"./structs/JBRuleset.sol\";\nimport {JBRulesetConfig} from \"./structs/JBRulesetConfig.sol\";\nimport {JBRulesetMetadata} from \"./structs/JBRulesetMetadata.sol\";\nimport {JBRulesetWithMetadata} from \"./structs/JBRulesetWithMetadata.sol\";\nimport {JBSplit} from \"./structs/JBSplit.sol\";\nimport {JBSplitGroup} from \"./structs/JBSplitGroup.sol\";\nimport {JBSplitHookContext} from \"./structs/JBSplitHookContext.sol\";\nimport {JBTerminalConfig} from \"./structs/JBTerminalConfig.sol\";\n\n/// @notice `JBController` coordinates rulesets and project tokens, and is the entry point for most operations related\n/// to rulesets and project tokens.\ncontract JBController is JBPermissioned, ERC2771Context, IJBController, IJBMigratable {\n    // A library that parses packed ruleset metadata into a friendlier format.\n    using JBRulesetMetadataResolver for JBRuleset;\n\n    // A library that adds default safety checks to ERC20 functionality.\n    using SafeERC20 for IERC20;\n\n    //*********************************************************************//\n    // --------------------------- custom errors ------------------------- //\n    //*********************************************************************//\n\n    error ADDING_PRICE_FEED_NOT_ALLOWED();\n    error CREDIT_TRANSFERS_PAUSED();\n    error RULESETS_ARRAY_EMPTY();\n    error INVALID_REDEMPTION_RATE();\n    error INVALID_RESERVED_PERCENT();\n    error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_OR_HOOK();\n    error NO_BURNABLE_TOKENS();\n    error NO_RESERVED_TOKENS();\n    error RULESETS_ALREADY_LAUNCHED();\n    error ZERO_TOKENS_TO_MINT();\n    error RULESET_SET_TOKEN_DISABLED();\n\n    //*********************************************************************//\n    // --------------- public immutable stored properties ---------------- //\n    //*********************************************************************//\n\n    /// @notice Mints ERC-721s that represent project ownership and transfers.\n    IJBProjects public immutable override PROJECTS;\n\n    /// @notice The directory of terminals and controllers for projects.\n    IJBDirectory public immutable override DIRECTORY;\n\n    /// @notice The contract storing and managing project rulesets.\n    IJBRulesets public immutable override RULESETS;\n\n    /// @notice The contract that manages token minting and burning.\n    IJBTokens public immutable override TOKENS;\n\n    /// @notice The contract that stores splits for each project.\n    IJBSplits public immutable override SPLITS;\n\n    /// @notice A contract that stores fund access limits for each project.\n    IJBFundAccessLimits public immutable override FUND_ACCESS_LIMITS;\n\n    /// @notice A contract that stores prices for each project.\n    IJBPrices public immutable override PRICES;\n\n    //*********************************************************************//\n    // --------------------- public stored properties -------------------- //\n    //*********************************************************************//\n\n    /// @notice A project's unrealized reserved token balance (i.e. reserved tokens which haven't been sent out to the\n    /// reserved token split group yet).\n    /// @custom:param projectId The ID of the project to get the pending reserved token balance of.\n    mapping(uint256 projectId => uint256) public override pendingReservedTokenBalanceOf;\n\n    /// @notice The metadata URI for each project. This is typically an IPFS hash, optionally with an `ipfs://` prefix.\n    /// @custom:param projectId The ID of the project to get the metadata URI of.\n    mapping(uint256 projectId => string) public override uriOf;\n\n    //*********************************************************************//\n    // ------------------------- external views -------------------------- //\n    //*********************************************************************//\n\n    /// @notice Gets the a project token's total supply, including pending reserved tokens.\n    /// @param projectId The ID of the project to get the total token supply of.\n    /// @return The total supply of the project's token, including pending reserved tokens.\n    function totalTokenSupplyWithReservedTokensOf(uint256 projectId) external view override returns (uint256) {\n        // Add the reserved tokens to the total supply.\n        return TOKENS.totalSupplyOf(projectId) + pendingReservedTokenBalanceOf[projectId];\n    }\n\n    /// @notice Get the `JBRuleset` and `JBRulesetMetadata` corresponding to the specified `rulesetId`.\n    /// @param projectId The ID of the project the ruleset belongs to.\n    /// @return ruleset The ruleset's struct.\n    /// @return metadata The ruleset's metadata.\n    function getRulesetOf(\n        uint256 projectId,\n        uint256 rulesetId\n    )\n        external\n        view\n        override\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata)\n    {\n        ruleset = RULESETS.getRulesetOf(projectId, rulesetId);\n        metadata = ruleset.expandMetadata();\n    }\n\n    /// @notice Gets the latest ruleset queued for a project, its approval status, and its metadata.\n    /// @dev The 'latest queued ruleset' is the ruleset initialized furthest in the future (at the end of the ruleset\n    /// queue).\n    /// @param projectId The ID of the project to get the latest ruleset of.\n    /// @return ruleset The struct for the project's latest queued ruleset.\n    /// @return metadata The ruleset's metadata.\n    /// @return approvalStatus The ruleset's approval status.\n    function latestQueuedRulesetOf(uint256 projectId)\n        external\n        view\n        override\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata, JBApprovalStatus approvalStatus)\n    {\n        (ruleset, approvalStatus) = RULESETS.latestQueuedOf(projectId);\n        metadata = ruleset.expandMetadata();\n    }\n\n    /// @notice Get an array of a project's rulesets (with metadata) up to a maximum array size, sorted from latest to\n    /// earliest.\n    /// @param projectId The ID of the project to get the rulesets of.\n    /// @param startingId The ID of the ruleset to begin with. This will be the latest ruleset in the result. If the\n    /// `startingId` is 0, passed, the project's latest ruleset will be used.\n    /// @param size The maximum number of rulesets to return.\n    /// @return rulesets The array of rulesets with their metadata.\n    function rulesetsOf(\n        uint256 projectId,\n        uint256 startingId,\n        uint256 size\n    )\n        external\n        view\n        override\n        returns (JBRulesetWithMetadata[] memory rulesets)\n    {\n        // Get the rulesets (without metadata).\n        JBRuleset[] memory baseRulesets = RULESETS.rulesetsOf(projectId, startingId, size);\n\n        // Keep a reference to the number of rulesets.\n        uint256 numberOfRulesets = baseRulesets.length;\n\n        // Initialize the array being returned.\n        rulesets = new JBRulesetWithMetadata[](numberOfRulesets);\n\n        // Keep a reference to the ruleset being iterated on.\n        JBRuleset memory baseRuleset;\n\n        // Populate the array with rulesets AND their metadata.\n        for (uint256 i; i < numberOfRulesets; i++) {\n            // Set the ruleset being iterated on.\n            baseRuleset = baseRulesets[i];\n\n            // Set the returned value.\n            rulesets[i] = JBRulesetWithMetadata({ruleset: baseRuleset, metadata: baseRuleset.expandMetadata()});\n        }\n    }\n\n    /// @notice A project's currently active ruleset and its metadata.\n    /// @param projectId The ID of the project to get the current ruleset of.\n    /// @return ruleset The current ruleset's struct.\n    /// @return metadata The current ruleset's metadata.\n    function currentRulesetOf(uint256 projectId)\n        external\n        view\n        override\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata)\n    {\n        ruleset = _currentRulesetOf(projectId);\n        metadata = ruleset.expandMetadata();\n    }\n\n    /// @notice A project's next ruleset along with its metadata.\n    /// @dev If an upcoming ruleset isn't found, returns an empty ruleset with all properties set to 0.\n    /// @param projectId The ID of the project to get the next ruleset of.\n    /// @return ruleset The upcoming ruleset's struct.\n    /// @return metadata The upcoming ruleset's metadata.\n    function upcomingRulesetOf(uint256 projectId)\n        external\n        view\n        override\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata)\n    {\n        ruleset = _upcomingRulesetOf(projectId);\n        metadata = ruleset.expandMetadata();\n    }\n\n    /// @notice Check whether the project's terminals can currently be set.\n    /// @param projectId The ID of the project to check.\n    /// @return A `bool` which is true if the project allows terminals to be set.\n    function setTerminalsAllowed(uint256 projectId) external view returns (bool) {\n        return _currentRulesetOf(projectId).expandMetadata().allowSetTerminals;\n    }\n\n    /// @notice Check whether the project's controller can currently be set.\n    /// @param projectId The ID of the project to check.\n    /// @return A `bool` which is true if the project allows controllers to be set.\n    function setControllerAllowed(uint256 projectId) external view returns (bool) {\n        return _currentRulesetOf(projectId).expandMetadata().allowSetController;\n    }\n\n    //*********************************************************************//\n    // -------------------------- public views --------------------------- //\n    //*********************************************************************//\n\n    /// @notice Indicates whether this contract adheres to the specified interface.\n    /// @dev See {IERC165-supportsInterface}.\n    /// @param interfaceId The ID of the interface to check for adherence to.\n    /// @return A flag indicating if the provided interface ID is supported.\n    function supportsInterface(bytes4 interfaceId) public pure override returns (bool) {\n        return interfaceId == type(IJBController).interfaceId || interfaceId == type(IJBProjectUriRegistry).interfaceId\n            || interfaceId == type(IJBDirectoryAccessControl).interfaceId || interfaceId == type(IJBMigratable).interfaceId\n            || interfaceId == type(IJBPermissioned).interfaceId || interfaceId == type(IERC165).interfaceId;\n    }\n\n    //*********************************************************************//\n    // -------------------------- internal views ------------------------- //\n    //*********************************************************************//\n\n    /// @notice Indicates whether the provided address is a terminal for the project.\n    /// @param projectId The ID of the project to check.\n    /// @param terminal The address to check.\n    /// @return A flag indicating if the provided address is a terminal for the project.\n    function _isTerminalOf(uint256 projectId, address terminal) internal view returns (bool) {\n        return DIRECTORY.isTerminalOf(projectId, IJBTerminal(terminal));\n    }\n\n    /// @notice Indicates whether the provided address has mint permission for the project byway of the data hook.\n    /// @param projectId The ID of the project to check.\n    /// @param ruleset The ruleset to check.\n    /// @param addrs The address to check.\n    /// @return A flag indicating if the provided address has mint permission for the project.\n    function _hasDataHookMintPermissionFor(\n        uint256 projectId,\n        JBRuleset memory ruleset,\n        address addrs\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return ruleset.dataHook() != address(0)\n            && IJBRulesetDataHook(ruleset.dataHook()).hasMintPermissionFor(projectId, addrs);\n    }\n\n    /// @notice The project's current ruleset.\n    /// @param projectId The ID of the project to check.\n    /// @return The project's current ruleset.\n    function _currentRulesetOf(uint256 projectId) internal view returns (JBRuleset memory) {\n        return RULESETS.currentOf(projectId);\n    }\n\n    /// @notice The project's upcoming ruleset.\n    /// @param projectId The ID of the project to check.\n    /// @return The project's upcoming ruleset.\n    function _upcomingRulesetOf(uint256 projectId) internal view returns (JBRuleset memory) {\n        return RULESETS.upcomingOf(projectId);\n    }\n\n    //*********************************************************************//\n    // ---------------------------- constructor -------------------------- //\n    //*********************************************************************//\n\n    /// @param permissions A contract storing permissions.\n    /// @param projects A contract which mints ERC-721s that represent project ownership and transfers.\n    /// @param directory A contract storing directories of terminals and controllers for each project.\n    /// @param rulesets A contract storing and managing project rulesets.\n    /// @param tokens A contract that manages token minting and burning.\n    /// @param splits A contract that stores splits for each project.\n    /// @param fundAccessLimits A contract that stores fund access limits for each project.\n    /// @param prices A contract that stores prices for each project.\n    constructor(\n        IJBPermissions permissions,\n        IJBProjects projects,\n        IJBDirectory directory,\n        IJBRulesets rulesets,\n        IJBTokens tokens,\n        IJBSplits splits,\n        IJBFundAccessLimits fundAccessLimits,\n        IJBPrices prices,\n        address trustedForwarder\n    )\n        JBPermissioned(permissions)\n        ERC2771Context(trustedForwarder)\n    {\n        PROJECTS = projects;\n        DIRECTORY = directory;\n        RULESETS = rulesets;\n        TOKENS = tokens;\n        SPLITS = splits;\n        FUND_ACCESS_LIMITS = fundAccessLimits;\n        PRICES = prices;\n    }\n\n    //*********************************************************************//\n    // --------------------- external transactions ----------------------- //\n    //*********************************************************************//\n\n    /// @notice Creates a project.\n    /// @dev This will mint the project's ERC-721 to the `owner`'s address, queue the specified rulesets, and set up the\n    /// specified splits and terminals. Each operation within this transaction can be done in sequence separately.\n    /// @dev Anyone can deploy a project to any `owner`'s address.\n    /// @param owner The project's owner. The project ERC-721 will be minted to this address.\n    /// @param projectUri The project's metadata URI. This is typically an IPFS hash, optionally with the `ipfs://`\n    /// prefix. This can be updated by the project's owner.\n    /// @param rulesetConfigurations The rulesets to queue.\n    /// @param terminalConfigurations The terminals to set up for the project.\n    /// @param memo A memo to pass along to the emitted event.\n    /// @return projectId The project's ID.\n    function launchProjectFor(\n        address owner,\n        string calldata projectUri,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        JBTerminalConfig[] calldata terminalConfigurations,\n        string calldata memo\n    )\n        external\n        override\n        returns (uint256 projectId)\n    {\n        // Mint the project ERC-721 into the owner's wallet.\n        projectId = PROJECTS.createFor(owner);\n\n        // If provided, set the project's metadata URI.\n        if (bytes(projectUri).length > 0) {\n            uriOf[projectId] = projectUri;\n        }\n\n        // Set this contract as the project's controller in the directory.\n        DIRECTORY.setControllerOf(projectId, IERC165(this));\n\n        // Configure the terminals.\n        _configureTerminals(projectId, terminalConfigurations);\n\n        // Queue the rulesets.\n        uint256 rulesetId = _queueRulesets(projectId, rulesetConfigurations);\n\n        emit LaunchProject(rulesetId, projectId, projectUri, memo, _msgSender());\n    }\n\n    /// @notice Queue a project's initial rulesets and set up terminals for it. Projects which already have rulesets\n    /// should use `queueRulesetsOf(...)`.\n    /// @dev Each operation within this transaction can be done in sequence separately.\n    /// @dev Can only be called by the project's owner or an address with the owner's permission to `QUEUE_RULESETS`.\n    /// @param projectId The ID of the project to launch rulesets for.\n    /// @param rulesetConfigurations The rulesets to queue.\n    /// @param terminalConfigurations The terminals to set up.\n    /// @param memo A memo to pass along to the emitted event.\n    /// @return rulesetId The ID of the last successfully queued ruleset.\n    function launchRulesetsFor(\n        uint256 projectId,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        JBTerminalConfig[] calldata terminalConfigurations,\n        string calldata memo\n    )\n        external\n        override\n        returns (uint256 rulesetId)\n    {\n        // Make sure there are rulesets being queued.\n        if (rulesetConfigurations.length == 0) revert RULESETS_ARRAY_EMPTY();\n\n        // Enforce permissions.\n        _requirePermissionFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.QUEUE_RULESETS\n        });\n\n        // Enforce permissions.\n        _requirePermissionFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.SET_TERMINALS\n        });\n\n        // If the project has already had rulesets, use `queueRulesetsOf(...)` instead.\n        if (RULESETS.latestRulesetIdOf(projectId) > 0) {\n            revert RULESETS_ALREADY_LAUNCHED();\n        }\n\n        // Set this contract as the project's controller in the directory.\n        DIRECTORY.setControllerOf(projectId, IERC165(this));\n\n        // Configure the terminals.\n        _configureTerminals(projectId, terminalConfigurations);\n\n        // Queue the first ruleset.\n        rulesetId = _queueRulesets(projectId, rulesetConfigurations);\n\n        emit LaunchRulesets(rulesetId, projectId, memo, _msgSender());\n    }\n\n    /// @notice Add one or more rulesets to the end of a project's ruleset queue. Rulesets take effect after the\n    /// previous ruleset in the queue ends, and only if they are approved by the previous ruleset's approval hook.\n    /// @dev Can only be called by the project's owner or an address with the owner's permission to `QUEUE_RULESETS`.\n    /// @param projectId The ID of the project to queue rulesets for.\n    /// @param rulesetConfigurations The rulesets to queue.\n    /// @param memo A memo to pass along to the emitted event.\n    /// @return rulesetId The ID of the last ruleset which was successfully queued.\n    function queueRulesetsOf(\n        uint256 projectId,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        string calldata memo\n    )\n        external\n        override\n        returns (uint256 rulesetId)\n    {\n        // Make sure there are rulesets being queued.\n        if (rulesetConfigurations.length == 0) revert RULESETS_ARRAY_EMPTY();\n\n        // Enforce permissions.\n        _requirePermissionFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.QUEUE_RULESETS\n        });\n\n        // Queue the rulesets.\n        rulesetId = _queueRulesets(projectId, rulesetConfigurations);\n\n        emit QueueRulesets(rulesetId, projectId, memo, _msgSender());\n    }\n\n    /// @notice Add new project tokens or credits to the specified beneficiary's balance. Optionally, reserve a portion\n    /// according to the ruleset's reserved percent.\n    /// @dev Can only be called by the project's owner, an address with the owner's permission to `MINT_TOKENS`, one of\n    /// the project's terminals, or the project's data hook.\n    /// @dev If the ruleset's metadata has `allowOwnerMinting` set to `false`, this function can only be called by the\n    /// project's terminals or data hook.\n    /// @param projectId The ID of the project whose tokens are being minted.\n    /// @param tokenCount The number of tokens to mint, including any reserved tokens.\n    /// @param beneficiary The address which will receive the (non-reserved) tokens.\n    /// @param memo A memo to pass along to the emitted event.\n    /// @param useReservedPercent Whether to apply the ruleset's reserved percent.\n    /// @return beneficiaryTokenCount The number of tokens minted for the `beneficiary`.\n    function mintTokensOf(\n        uint256 projectId,\n        uint256 tokenCount,\n        address beneficiary,\n        string calldata memo,\n        bool useReservedPercent\n    )\n        external\n        override\n        returns (uint256 beneficiaryTokenCount)\n    {\n        // There should be tokens to mint.\n        if (tokenCount == 0) revert ZERO_TOKENS_TO_MINT();\n\n        // Keep a reference to the reserved percent.\n        uint256 reservedPercent;\n\n        // Get a reference to the project's ruleset.\n        JBRuleset memory ruleset = _currentRulesetOf(projectId);\n\n        // Minting is restricted to: the project's owner, addresses with permission to `MINT_TOKENS`, the project's\n        // terminals, and the project's data hook.\n        _requirePermissionAllowingOverrideFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.MINT_TOKENS,\n            alsoGrantAccessIf: _isTerminalOf(projectId, _msgSender()) || _msgSender() == ruleset.dataHook()\n                || _hasDataHookMintPermissionFor(projectId, ruleset, _msgSender())\n        });\n\n        // If the message sender is not the project's terminal or data hook, the ruleset must have `allowOwnerMinting`\n        // set to `true`.\n        if (\n            ruleset.id != 0 && !ruleset.allowOwnerMinting() && !_isTerminalOf(projectId, _msgSender())\n                && _msgSender() != address(ruleset.dataHook())\n                && !_hasDataHookMintPermissionFor(projectId, ruleset, _msgSender())\n        ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_OR_HOOK();\n\n        // Determine the reserved percent to use.\n        reservedPercent = useReservedPercent ? ruleset.reservedPercent() : 0;\n\n        if (reservedPercent != JBConstants.MAX_RESERVED_PERCENT) {\n            // Calculate the number of (non-reserved) tokens that will be minted to the beneficiary.\n            beneficiaryTokenCount =\n                mulDiv(tokenCount, JBConstants.MAX_RESERVED_PERCENT - reservedPercent, JBConstants.MAX_RESERVED_PERCENT);\n\n            // Mint the tokens.\n            TOKENS.mintFor(beneficiary, projectId, beneficiaryTokenCount);\n        }\n\n        // Add any reserved tokens to the pending reserved token balance.\n        if (reservedPercent > 0) {\n            pendingReservedTokenBalanceOf[projectId] += tokenCount - beneficiaryTokenCount;\n        }\n\n        emit MintTokens(beneficiary, projectId, tokenCount, beneficiaryTokenCount, memo, reservedPercent, _msgSender());\n    }\n\n    /// @notice Burns a project's tokens or credits from the specific holder's balance.\n    /// @dev Can only be called by the holder, an address with the holder's permission to `BURN_TOKENS`, or a project's\n    /// terminal.\n    /// @param holder The address whose tokens are being burned.\n    /// @param projectId The ID of the project whose tokens are being burned.\n    /// @param tokenCount The number of tokens to burn.\n    /// @param memo A memo to pass along to the emitted event.\n    function burnTokensOf(\n        address holder,\n        uint256 projectId,\n        uint256 tokenCount,\n        string calldata memo\n    )\n        external\n        override\n    {\n        // Enforce permissions.\n        _requirePermissionAllowingOverrideFrom({\n            account: holder,\n            projectId: projectId,\n            permissionId: JBPermissionIds.BURN_TOKENS,\n            alsoGrantAccessIf: _isTerminalOf(projectId, _msgSender())\n        });\n\n        // There must be tokens to burn.\n        if (tokenCount == 0) revert NO_BURNABLE_TOKENS();\n\n        // Burn the tokens.\n        TOKENS.burnFrom(holder, projectId, tokenCount);\n\n        emit BurnTokens(holder, projectId, tokenCount, memo, _msgSender());\n    }\n\n    /// @notice Sends a project's pending reserved tokens to its reserved token splits.\n    /// @dev If the project has no reserved token splits, or if they don't add up to 100%, leftover tokens are sent to\n    /// the project's owner.\n    /// @param projectId The ID of the project to send reserved tokens for.\n    /// @return The amount of reserved tokens minted and sent.\n    function sendReservedTokensToSplitsOf(uint256 projectId) external override returns (uint256) {\n        return _sendReservedTokensToSplitsOf(projectId);\n    }\n\n    /// @notice Prepares this controller to receive a project being migrated from another controller.\n    /// @dev This controller should not be the project's controller yet.\n    /// @param from The controller being migrated from.\n    /// @param projectId The ID of the project that will migrate to this controller.\n    function receiveMigrationFrom(IERC165 from, uint256 projectId) external override {\n        // If the sending controller is an `IJBProjectUriRegistry`, copy the project's metadata URI.\n        if (\n            from.supportsInterface(type(IJBProjectUriRegistry).interfaceId) && DIRECTORY.controllerOf(projectId) == from\n        ) {\n            uriOf[projectId] = IJBProjectUriRegistry(address(from)).uriOf(projectId);\n        }\n    }\n\n    /// @notice Migrate a project from this controller to another one.\n    /// @dev Can only be called by the directory.\n    /// @param projectId The ID of the project to migrate.\n    /// @param to The controller to migrate the project to.\n    function migrate(uint256 projectId, IERC165 to) external override {\n        // Make sure this is being called by the directory.\n        if (msg.sender != address(DIRECTORY)) revert UNAUTHORIZED();\n\n        // Mint any pending reserved tokens before migrating.\n        if (pendingReservedTokenBalanceOf[projectId] != 0) {\n            _sendReservedTokensToSplitsOf(projectId);\n        }\n\n        // Prepare the new controller to receive the project.\n        if (to.supportsInterface(type(IJBMigratable).interfaceId)) {\n            IJBMigratable(address(to)).receiveMigrationFrom(IERC165(this), projectId);\n        }\n\n        emit Migrate(projectId, to, msg.sender);\n    }\n\n    /// @notice Set a project's metadata URI.\n    /// @dev This is typically an IPFS hash, optionally with an `ipfs://` prefix.\n    /// @dev Can only be called by the project's owner or an address with the owner's permission to\n    /// `SET_PROJECT_URI`.\n    /// @param projectId The ID of the project to set the metadata URI of.\n    /// @param metadata The metadata URI to set.\n    function setUriOf(uint256 projectId, string calldata metadata) external override {\n        // Enforce permissions.\n        _requirePermissionFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.SET_PROJECT_URI\n        });\n\n        // Set the project's metadata URI.\n        uriOf[projectId] = metadata;\n\n        emit SetMetadata(projectId, metadata, _msgSender());\n    }\n\n    /// @notice Sets a project's split groups. The new split groups must include any current splits which are locked.\n    /// @dev Can only be called by the project's owner or an address with the owner's permission to `SET_SPLIT_GROUPS`.\n    /// @param projectId The ID of the project to set the split groups of.\n    /// @param rulesetId The ID of the ruleset the split groups should be active in. Use a `rulesetId` of 0 to set the\n    /// default split groups, which are used when a ruleset has no splits set. If there are no default splits and no\n    /// splits are set, all splits are sent to the project's owner.\n    /// @param splitGroups An array of split groups to set.\n    function setSplitGroupsOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        JBSplitGroup[] calldata splitGroups\n    )\n        external\n        override\n    {\n        // Enforce permissions.\n        _requirePermissionFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.SET_SPLIT_GROUPS\n        });\n\n        // Set the split groups.\n        SPLITS.setSplitGroupsOf(projectId, rulesetId, splitGroups);\n    }\n\n    /// @notice Deploys an ERC-20 token for a project. It will be used when claiming tokens (with credits).\n    /// @dev Deploys the project's ERC-20 contract.\n    /// @dev Can only be called by the project's owner or an address with the owner's permission to `DEPLOY_ERC20`.\n    /// @param projectId The ID of the project to deploy the ERC-20 for.\n    /// @param name The ERC-20's name.\n    /// @param symbol The ERC-20's symbol.\n    /// @param salt The salt used for ERC-1167 clone deployment. Pass a non-zero salt for deterministic deployment based\n    /// on `msg.sender` and the `TOKEN` implementation address.\n    /// @return token The address of the token that was deployed.\n    function deployERC20For(\n        uint256 projectId,\n        string calldata name,\n        string calldata symbol,\n        bytes32 salt\n    )\n        external\n        override\n        returns (IJBToken token)\n    {\n        // Enforce permissions.\n        _requirePermissionFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.DEPLOY_ERC20\n        });\n\n        if (salt != bytes32(0)) salt = keccak256(abi.encodePacked(_msgSender(), salt));\n\n        return TOKENS.deployERC20For(projectId, name, symbol, salt);\n    }\n\n    /// @notice Set a project's token. If the project's token is already set, this will revert.\n    /// @dev Can only be called by the project's owner or an address with the owner's permission to `SET_TOKEN`.\n    /// @param projectId The ID of the project to set the token of.\n    /// @param token The new token's address.\n    function setTokenFor(uint256 projectId, IJBToken token) external override {\n        // Enforce permissions.\n        _requirePermissionFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.SET_TOKEN\n        });\n\n        // Get a reference to the current ruleset.\n        JBRuleset memory ruleset = _currentRulesetOf(projectId);\n\n        // If there's no current ruleset, get a reference to the upcoming one.\n        if (ruleset.id == 0) ruleset = _upcomingRulesetOf(projectId);\n\n        // If owner minting is disabled for the ruleset, the owner cannot change the token.\n        if (!ruleset.allowSetCustomToken()) revert RULESET_SET_TOKEN_DISABLED();\n\n        TOKENS.setTokenFor(projectId, token);\n    }\n\n    /// @notice Redeem credits to claim tokens into a `beneficiary`'s account.\n    /// @dev Can only be called by the credit holder or an address with the holder's permission to `CLAIM_TOKENS`.\n    /// @param holder The address to redeem credits from.\n    /// @param projectId The ID of the project whose tokens are being claimed.\n    /// @param amount The amount of tokens to claim.\n    /// @param beneficiary The account the claimed tokens will go to.\n    function claimTokensFor(address holder, uint256 projectId, uint256 amount, address beneficiary) external override {\n        // Enforce permissions.\n        _requirePermissionFrom({account: holder, projectId: projectId, permissionId: JBPermissionIds.CLAIM_TOKENS});\n\n        TOKENS.claimTokensFor(holder, projectId, amount, beneficiary);\n    }\n\n    /// @notice Allows a credit holder to transfer credits to another address.\n    /// @dev Can only be called by the credit holder or an address with the holder's permission to `TRANSFER_CREDITS`.\n    /// @param holder The address to transfer credits from.\n    /// @param projectId The ID of the project whose credits are being transferred.\n    /// @param recipient The address to transfer credits to.\n    /// @param amount The amount of credits to transfer.\n    function transferCreditsFrom(\n        address holder,\n        uint256 projectId,\n        address recipient,\n        uint256 amount\n    )\n        external\n        override\n    {\n        // Enforce permissions.\n        _requirePermissionFrom({account: holder, projectId: projectId, permissionId: JBPermissionIds.TRANSFER_CREDITS});\n\n        // Get a reference to the project's ruleset.\n        JBRuleset memory ruleset = _currentRulesetOf(projectId);\n\n        // Credit transfers must not be paused.\n        if (ruleset.pauseCreditTransfers()) revert CREDIT_TRANSFERS_PAUSED();\n\n        TOKENS.transferCreditsFrom(holder, projectId, recipient, amount);\n    }\n\n    /// @notice Add a price feed for a project.\n    /// @dev Can only be called by the project's owner or an address with the owner's permission to `ADD_PRICE_FEED`.\n    /// @param projectId The ID of the project to add the feed for.\n    /// @param pricingCurrency The currency the feed's output price is in terms of.\n    /// @param unitCurrency The currency being priced by the feed.\n    /// @param feed The address of the price feed to add.\n    function addPriceFeed(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency,\n        IJBPriceFeed feed\n    )\n        external\n        override\n    {\n        // Enforce permissions.\n        _requirePermissionFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.ADD_PRICE_FEED\n        });\n\n        JBRuleset memory ruleset = _currentRulesetOf(projectId);\n\n        // Make sure the project's ruleset allows adding price feeds.\n        if (!ruleset.allowAddPriceFeed()) revert ADDING_PRICE_FEED_NOT_ALLOWED();\n\n        PRICES.addPriceFeedFor(projectId, pricingCurrency, unitCurrency, feed);\n    }\n\n    /// @notice When a project receives reserved tokens, if it has a terminal for the token, this is used to pay the\n    /// terminal.\n    /// @dev Can only be called by this controller.\n    /// @param terminal The terminal to pay.\n    /// @param projectId The ID of the project being paid.\n    /// @param token The token being paid with.\n    /// @param splitAmount The amount of tokens being paid.\n    /// @param beneficiary The payment's beneficiary.\n    /// @param metadata The pay metadata sent to the terminal.\n    function executePayReservedTokenToTerminal(\n        IJBTerminal terminal,\n        uint256 projectId,\n        IJBToken token,\n        uint256 splitAmount,\n        address beneficiary,\n        bytes calldata metadata\n    )\n        external\n    {\n        // Can only be called by this contract.\n        require(msg.sender == address(this));\n\n        // Approve the tokens being paid.\n        IERC20(address(token)).forceApprove(address(terminal), splitAmount);\n\n        // slither-disable-next-line unused-return\n        terminal.pay({\n            projectId: projectId,\n            token: address(token),\n            amount: splitAmount,\n            beneficiary: beneficiary,\n            minReturnedTokens: 0,\n            memo: \"\",\n            metadata: metadata\n        });\n\n        // Make sure that the terminal received the tokens.\n        assert(IERC20(address(token)).allowance(address(this), address(terminal)) == 0);\n    }\n\n    //*********************************************************************//\n    // ---------------------- internal transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice The message's sender. Preferred to use over `msg.sender`.\n    /// @return sender The address which sent this call.\n    function _msgSender() internal view override(ERC2771Context, Context) returns (address sender) {\n        return ERC2771Context._msgSender();\n    }\n\n    /// @notice The calldata. Preferred to use over `msg.data`.\n    /// @return calldata The `msg.data` of this call.\n    function _msgData() internal view override(ERC2771Context, Context) returns (bytes calldata) {\n        return ERC2771Context._msgData();\n    }\n\n    /// @dev `ERC-2771` specifies the context as being a single address (20 bytes).\n    function _contextSuffixLength() internal view override(ERC2771Context, Context) returns (uint256) {\n        return super._contextSuffixLength();\n    }\n\n    //*********************************************************************//\n    // ---------------------- internal transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice Sends pending reserved tokens to the project's reserved token splits.\n    /// @dev If the project has no reserved token splits, or if they don't add up to 100%, leftover tokens are sent to\n    /// the project's owner.\n    /// @param projectId The ID of the project to send reserved tokens for.\n    /// @return tokenCount The amount of reserved tokens minted and sent.\n    function _sendReservedTokensToSplitsOf(uint256 projectId) internal returns (uint256 tokenCount) {\n        // Get a reference to the number of tokens that need to be minted.\n        tokenCount = pendingReservedTokenBalanceOf[projectId];\n\n        // Revert if there are no pending reserved tokens\n        if (tokenCount == 0) revert NO_RESERVED_TOKENS();\n\n        // Get the ruleset to read the reserved percent from.\n        JBRuleset memory ruleset = _currentRulesetOf(projectId);\n\n        // Reset the pending reserved token balance.\n        pendingReservedTokenBalanceOf[projectId] = 0;\n\n        // Get a reference to the project's owner.\n        address owner = PROJECTS.ownerOf(projectId);\n\n        // Send reserved tokens to splits and get a reference to the amount left after the splits have all been paid.\n        uint256 leftoverTokenCount = tokenCount == 0\n            ? 0\n            : _sendTokensToSplitGroupOf(projectId, ruleset.id, JBSplitGroupIds.RESERVED_TOKENS, tokenCount);\n\n        // Mint any leftover tokens to the project owner.\n        if (leftoverTokenCount > 0) {\n            TOKENS.mintFor(owner, projectId, leftoverTokenCount);\n        }\n\n        emit SendReservedTokensToSplits(\n            ruleset.id, ruleset.cycleNumber, projectId, owner, tokenCount, leftoverTokenCount, _msgSender()\n        );\n    }\n\n    /// @notice Send project tokens to a split group.\n    /// @dev This is used to send reserved tokens to the reserved token split group.\n    /// @param projectId The ID of the project the splits belong to.\n    /// @param rulesetId The ID of the split group's ruleset.\n    /// @param groupId The ID of the split group.\n    /// @param amount The number of tokens to send.\n    /// @return leftoverAmount If the split percents don't add up to 100%, the leftover amount is returned.\n    function _sendTokensToSplitGroupOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        uint256 groupId,\n        uint256 amount\n    )\n        internal\n        returns (uint256 leftoverAmount)\n    {\n        // Set the leftover amount to the initial amount.\n        leftoverAmount = amount;\n\n        // Get a reference to the split group.\n        JBSplit[] memory splits = SPLITS.splitsOf(projectId, rulesetId, groupId);\n\n        // Keep a reference to the number of splits being iterated on.\n        uint256 numberOfSplits = splits.length;\n\n        // Keep a reference to the split being iterated on.\n        JBSplit memory split;\n\n        // Keep a reference to the split amount being iterated on.\n        uint256 splitAmount;\n\n        // Send the tokens to the splits.\n        for (uint256 i; i < numberOfSplits; i++) {\n            // Get a reference to the split being iterated on.\n            split = splits[i];\n\n            // Calculate the amount to send to the split.\n            splitAmount = mulDiv(amount, split.percent, JBConstants.SPLITS_TOTAL_PERCENT);\n\n            // Mints tokens for the split if needed.\n            if (splitAmount > 0) {\n                // 1. If the split has a `hook`, call the hook's `processSplitWith` function.\n                // 2. Otherwise, if the split has a `projectId`, try to pay the project using the split's `beneficiary`,\n                // or the `_msgSender()` if the split has no beneficiary.\n                // 3. Otherwise, if the split has a beneficiary, send the tokens to the split's beneficiary.\n                // 4. Otherwise, send the tokens to the `_msgSender()`.\n\n                // If the split has a hook, call its `processSplitWith` function.\n                if (split.hook != IJBSplitHook(address(0))) {\n                    // Mint the tokens for the split hook.\n                    TOKENS.mintFor(address(split.hook), projectId, splitAmount);\n\n                    // Get a reference to the project token address. If the project doesn't have a token, this will\n                    // return the 0 address.\n                    IJBToken token = TOKENS.tokenOf(projectId);\n\n                    split.hook.processSplitWith(\n                        JBSplitHookContext({\n                            token: address(token),\n                            amount: splitAmount,\n                            decimals: 18, // Hard-coded in `JBTokens`.\n                            projectId: projectId,\n                            groupId: groupId,\n                            split: split\n                        })\n                    );\n                    // If the split has a project ID, try to pay the project. If that fails, pay the beneficiary.\n                } else {\n                    // Pay the project using the split's beneficiary if one was provided. Otherwise, use the message\n                    // sender.\n                    address beneficiary = split.beneficiary != address(0) ? split.beneficiary : _msgSender();\n\n                    if (split.projectId != 0) {\n                        // Get a reference to the project's token address. If the project doesn't have a token, this\n                        // will return the 0 address.\n                        IJBToken token = TOKENS.tokenOf(projectId);\n\n                        // Get a reference to the receiving project's primary payment terminal for the token.\n                        IJBTerminal terminal = token == IJBToken(address(0))\n                            ? IJBTerminal(address(0))\n                            : DIRECTORY.primaryTerminalOf(split.projectId, address(token));\n\n                        // If the project doesn't have a token, or if the receiving project doesn't have a terminal\n                        // which accepts the token, send the tokens to the beneficiary.\n                        if (address(token) == address(0) || address(terminal) == address(0)) {\n                            // Mint the tokens to the beneficiary.\n                            TOKENS.mintFor(beneficiary, projectId, splitAmount);\n                        } else {\n                            // Mint the tokens to this contract.\n                            TOKENS.mintFor(address(this), projectId, splitAmount);\n\n                            // Use the `projectId` in the pay metadata.\n                            bytes memory metadata = bytes(abi.encodePacked(projectId));\n\n                            // Try to fulfill the payment.\n                            try this.executePayReservedTokenToTerminal({\n                                projectId: split.projectId,\n                                terminal: terminal,\n                                token: token,\n                                splitAmount: splitAmount,\n                                beneficiary: beneficiary,\n                                metadata: metadata\n                            }) {} catch (bytes memory reason) {\n                                // If it fails, transfer the tokens from this contract to the beneficiary.\n                                IERC20(address(token)).safeTransfer(beneficiary, splitAmount);\n                                emit ReservedDistributionReverted(projectId, split, splitAmount, reason, _msgSender());\n                            }\n                        }\n                    } else {\n                        // If the split has no project ID, mint the tokens to the beneficiary.\n                        TOKENS.mintFor(beneficiary, projectId, splitAmount);\n                    }\n                }\n\n                // Subtract the amount sent from the leftover.\n                leftoverAmount = leftoverAmount - splitAmount;\n            }\n\n            emit SendReservedTokensToSplit(projectId, rulesetId, groupId, split, splitAmount, _msgSender());\n        }\n    }\n\n    /// @notice Queues one or more rulesets and stores information pertinent to the configuration.\n    /// @param projectId The ID of the project to queue rulesets for.\n    /// @param rulesetConfigurations The rulesets being queued.\n    /// @return rulesetId The ID of the last ruleset that was successfully queued.\n    function _queueRulesets(\n        uint256 projectId,\n        JBRulesetConfig[] calldata rulesetConfigurations\n    )\n        internal\n        returns (uint256 rulesetId)\n    {\n        // Keep a reference to the number of ruleset configurations being queued.\n        uint256 numberOfConfigurations = rulesetConfigurations.length;\n\n        // Keep a reference to the ruleset config being iterated on.\n        JBRulesetConfig memory rulesetConfig;\n\n        // Keep a reference to the latest queued ruleset.\n        JBRuleset memory ruleset;\n\n        for (uint256 i; i < numberOfConfigurations; i++) {\n            // Get a reference to the ruleset config being iterated on.\n            rulesetConfig = rulesetConfigurations[i];\n\n            // Make sure its reserved percent is valid.\n            if (rulesetConfig.metadata.reservedPercent > JBConstants.MAX_RESERVED_PERCENT) {\n                revert INVALID_RESERVED_PERCENT();\n            }\n\n            // Make sure its redemption rate is valid.\n            if (rulesetConfig.metadata.redemptionRate > JBConstants.MAX_REDEMPTION_RATE) {\n                revert INVALID_REDEMPTION_RATE();\n            }\n\n            // Queue its ruleset.\n            ruleset = RULESETS.queueFor({\n                projectId: projectId,\n                duration: rulesetConfig.duration,\n                weight: rulesetConfig.weight,\n                decayPercent: rulesetConfig.decayPercent,\n                approvalHook: rulesetConfig.approvalHook,\n                metadata: JBRulesetMetadataResolver.packRulesetMetadata(rulesetConfig.metadata),\n                mustStartAtOrAfter: rulesetConfig.mustStartAtOrAfter\n            });\n\n            // Set its split groups.\n            SPLITS.setSplitGroupsOf(projectId, ruleset.id, rulesetConfig.splitGroups);\n\n            // Set its fund access limits.\n            FUND_ACCESS_LIMITS.setFundAccessLimitsFor(projectId, ruleset.id, rulesetConfig.fundAccessLimitGroups);\n\n            // If this is the last configuration being queued, return the ruleset's ID.\n            if (i == numberOfConfigurations - 1) {\n                rulesetId = ruleset.id;\n            }\n        }\n    }\n\n    /// @notice Set up a project's terminals.\n    /// @param projectId The ID of the project to set up terminals for.\n    /// @param terminalConfigs The terminals to set up.\n    function _configureTerminals(uint256 projectId, JBTerminalConfig[] calldata terminalConfigs) internal {\n        // Keep a reference to the number of terminals being configured.\n        uint256 numberOfTerminalConfigs = terminalConfigs.length;\n\n        // Initialize an array of terminals to populate.\n        IJBTerminal[] memory terminals = new IJBTerminal[](numberOfTerminalConfigs);\n\n        // Keep a reference to the terminal configuration being iterated on.\n        JBTerminalConfig memory terminalConfig;\n\n        for (uint256 i; i < numberOfTerminalConfigs; i++) {\n            // Set the terminal configuration being iterated on.\n            terminalConfig = terminalConfigs[i];\n\n            // Add the accounting contexts for the specified tokens.\n            terminalConfig.terminal.addAccountingContextsFor({\n                projectId: projectId,\n                accountingContexts: terminalConfig.accountingContextsToAccept\n            });\n\n            // Add the terminal.\n            terminals[i] = terminalConfig.terminal;\n        }\n\n        // Set the terminals in the directory.\n        if (numberOfTerminalConfigs > 0) {\n            DIRECTORY.setTerminalsOf(projectId, terminals);\n        }\n    }\n}\n"
			},
			"src/abstract/JBPermissioned.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\n\nimport {IJBPermissioned} from \"./../interfaces/IJBPermissioned.sol\";\nimport {IJBPermissions} from \"./../interfaces/IJBPermissions.sol\";\n\n/// @notice Modifiers to allow access to transactions based on which permissions the message's sender has.\nabstract contract JBPermissioned is Context, IJBPermissioned {\n    //*********************************************************************//\n    // --------------------------- custom errors -------------------------- //\n    //*********************************************************************//\n    error UNAUTHORIZED();\n\n    //*********************************************************************//\n    // ---------------- public immutable stored properties --------------- //\n    //*********************************************************************//\n\n    /// @notice A contract storing permissions.\n    IJBPermissions public immutable override PERMISSIONS;\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param permissions A contract storing permissions.\n    constructor(IJBPermissions permissions) {\n        PERMISSIONS = permissions;\n    }\n\n    //*********************************************************************//\n    // -------------------------- internal views ------------------------- //\n    //*********************************************************************//\n\n    /// @notice Require the message sender to be the account or have the relevant permission.\n    /// @param account The account to allow.\n    /// @param projectId The project ID to check the permission under.\n    /// @param permissionId The required permission ID. The operator must have this permission within the specified\n    /// project ID.\n    function _requirePermissionFrom(address account, uint256 projectId, uint256 permissionId) internal view {\n        address sender = _msgSender();\n        if (\n            sender != account\n                && !PERMISSIONS.hasPermission({\n                    operator: sender,\n                    account: account,\n                    projectId: projectId,\n                    permissionId: permissionId,\n                    includeRoot: true,\n                    includeWildcardProjectId: true\n                })\n        ) revert UNAUTHORIZED();\n    }\n\n    /// @notice If the 'alsoGrantAccessIf' condition is truthy, proceed. Otherwise, require the message sender to be the\n    /// account or\n    /// have the relevant permission.\n    /// @param account The account to allow.\n    /// @param projectId The project ID to check the permission under.\n    /// @param permissionId The required permission ID. The operator must have this permission within the specified\n    /// project ID.\n    /// @param alsoGrantAccessIf An override condition which will allow access regardless of permissions.\n    function _requirePermissionAllowingOverrideFrom(\n        address account,\n        uint256 projectId,\n        uint256 permissionId,\n        bool alsoGrantAccessIf\n    )\n        internal\n        view\n    {\n        if (alsoGrantAccessIf) return;\n        _requirePermissionFrom(account, projectId, permissionId);\n    }\n}\n"
			},
			"src/interfaces/IJBController.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBApprovalStatus} from \"./../enums/JBApprovalStatus.sol\";\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {JBRulesetConfig} from \"./../structs/JBRulesetConfig.sol\";\nimport {JBRulesetMetadata} from \"./../structs/JBRulesetMetadata.sol\";\nimport {JBRulesetWithMetadata} from \"./../structs/JBRulesetWithMetadata.sol\";\nimport {JBSplit} from \"./../structs/JBSplit.sol\";\nimport {JBSplitGroup} from \"./../structs/JBSplitGroup.sol\";\nimport {JBTerminalConfig} from \"./../structs/JBTerminalConfig.sol\";\nimport {IJBDirectory} from \"./IJBDirectory.sol\";\nimport {IJBDirectoryAccessControl} from \"./IJBDirectoryAccessControl.sol\";\nimport {IJBFundAccessLimits} from \"./IJBFundAccessLimits.sol\";\nimport {IJBPriceFeed} from \"./IJBPriceFeed.sol\";\nimport {IJBPrices} from \"./IJBPrices.sol\";\nimport {IJBProjects} from \"./IJBProjects.sol\";\nimport {IJBProjectUriRegistry} from \"./IJBProjectUriRegistry.sol\";\nimport {IJBRulesets} from \"./IJBRulesets.sol\";\nimport {IJBSplits} from \"./IJBSplits.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\nimport {IJBToken} from \"./IJBToken.sol\";\nimport {IJBTokens} from \"./IJBTokens.sol\";\n\ninterface IJBController is IERC165, IJBProjectUriRegistry, IJBDirectoryAccessControl {\n    event LaunchProject(uint256 rulesetId, uint256 projectId, string metadata, string memo, address caller);\n\n    event LaunchRulesets(uint256 rulesetId, uint256 projectId, string memo, address caller);\n\n    event QueueRulesets(uint256 rulesetId, uint256 projectId, string memo, address caller);\n\n    event SendReservedTokensToSplits(\n        uint256 indexed rulesetId,\n        uint256 indexed rulesetCycleNumber,\n        uint256 indexed projectId,\n        address beneficiary,\n        uint256 tokenCount,\n        uint256 beneficiaryTokenCount,\n        address caller\n    );\n\n    event SendReservedTokensToSplit(\n        uint256 indexed projectId,\n        uint256 indexed rulesetId,\n        uint256 indexed group,\n        JBSplit split,\n        uint256 tokenCount,\n        address caller\n    );\n\n    event MintTokens(\n        address indexed beneficiary,\n        uint256 indexed projectId,\n        uint256 tokenCount,\n        uint256 beneficiaryTokenCount,\n        string memo,\n        uint256 reservedPercent,\n        address caller\n    );\n\n    event BurnTokens(\n        address indexed holder, uint256 indexed projectId, uint256 tokenCount, string memo, address caller\n    );\n\n    event ReservedDistributionReverted(\n        uint256 indexed projectId, JBSplit split, uint256 amount, bytes reason, address caller\n    );\n\n    event PrepMigration(uint256 indexed projectId, address from, address caller);\n\n    event SetMetadata(uint256 indexed projectId, string metadata, address caller);\n\n    function PROJECTS() external view returns (IJBProjects);\n\n    function DIRECTORY() external view returns (IJBDirectory);\n\n    function RULESETS() external view returns (IJBRulesets);\n\n    function TOKENS() external view returns (IJBTokens);\n\n    function SPLITS() external view returns (IJBSplits);\n\n    function FUND_ACCESS_LIMITS() external view returns (IJBFundAccessLimits);\n\n    function PRICES() external view returns (IJBPrices);\n\n    function pendingReservedTokenBalanceOf(uint256 projectId) external view returns (uint256);\n\n    function totalTokenSupplyWithReservedTokensOf(uint256 projectId) external view returns (uint256);\n\n    function getRulesetOf(\n        uint256 projectId,\n        uint256 rulesetId\n    )\n        external\n        view\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata);\n\n    function latestQueuedRulesetOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory, JBRulesetMetadata memory metadata, JBApprovalStatus);\n\n    function rulesetsOf(\n        uint256 projectId,\n        uint256 startingId,\n        uint256 size\n    )\n        external\n        view\n        returns (JBRulesetWithMetadata[] memory rulesets);\n\n    function currentRulesetOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata);\n\n    function upcomingRulesetOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata);\n\n    function launchProjectFor(\n        address owner,\n        string calldata projectUri,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        JBTerminalConfig[] memory terminalConfigurations,\n        string calldata memo\n    )\n        external\n        returns (uint256 projectId);\n\n    function launchRulesetsFor(\n        uint256 projectId,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        JBTerminalConfig[] memory terminalConfigurations,\n        string calldata memo\n    )\n        external\n        returns (uint256 rulesetId);\n\n    function queueRulesetsOf(\n        uint256 projectId,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        string calldata memo\n    )\n        external\n        returns (uint256 rulesetId);\n\n    function mintTokensOf(\n        uint256 projectId,\n        uint256 tokenCount,\n        address beneficiary,\n        string calldata memo,\n        bool useReservedPercent\n    )\n        external\n        returns (uint256 beneficiaryTokenCount);\n\n    function executePayReservedTokenToTerminal(\n        IJBTerminal terminal,\n        uint256 projectId,\n        IJBToken token,\n        uint256 splitAmount,\n        address beneficiary,\n        bytes calldata metadata\n    )\n        external;\n\n    function burnTokensOf(address holder, uint256 projectId, uint256 tokenCount, string calldata memo) external;\n\n    function sendReservedTokensToSplitsOf(uint256 projectId) external returns (uint256);\n\n    function setSplitGroupsOf(uint256 projectId, uint256 rulesetId, JBSplitGroup[] calldata splitGroups) external;\n\n    function deployERC20For(\n        uint256 projectId,\n        string calldata name,\n        string calldata symbol,\n        bytes32 salt\n    )\n        external\n        returns (IJBToken token);\n\n    function setTokenFor(uint256 _projectId, IJBToken _token) external;\n\n    function claimTokensFor(address holder, uint256 projectId, uint256 amount, address beneficiary) external;\n\n    function transferCreditsFrom(address holder, uint256 projectId, address recipient, uint256 amount) external;\n\n    function addPriceFeed(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency,\n        IJBPriceFeed feed\n    )\n        external;\n}\n"
			},
			"src/interfaces/IJBDirectoryAccessControl.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBDirectoryAccessControl {\n    function setTerminalsAllowed(uint256 projectId) external view returns (bool);\n    function setControllerAllowed(uint256 projectId) external view returns (bool);\n}\n"
			},
			"src/interfaces/IJBFundAccessLimits.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBCurrencyAmount} from \"./../structs/JBCurrencyAmount.sol\";\nimport {JBFundAccessLimitGroup} from \"./../structs/JBFundAccessLimitGroup.sol\";\n\ninterface IJBFundAccessLimits {\n    event SetFundAccessLimits(\n        uint256 indexed rulesetId, uint256 indexed projectId, JBFundAccessLimitGroup limits, address caller\n    );\n\n    function payoutLimitsOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token\n    )\n        external\n        view\n        returns (JBCurrencyAmount[] memory payoutLimits);\n\n    function payoutLimitOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256 payoutLimit);\n\n    function surplusAllowancesOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token\n    )\n        external\n        view\n        returns (JBCurrencyAmount[] memory surplusAllowances);\n\n    function surplusAllowanceOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256 surplusAllowance);\n\n    function setFundAccessLimitsFor(\n        uint256 projectId,\n        uint256 rulesetId,\n        JBFundAccessLimitGroup[] memory fundAccessConstaints\n    )\n        external;\n}\n"
			},
			"src/interfaces/IJBMigratable.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ninterface IJBMigratable is IERC165 {\n    event Migrate(uint256 indexed projectId, IERC165 to, address caller);\n\n    function receiveMigrationFrom(IERC165 from, uint256 projectId) external;\n    function migrate(uint256 projectId, IERC165 to) external;\n}\n"
			},
			"src/interfaces/IJBPermissioned.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPermissions} from \"./IJBPermissions.sol\";\n\ninterface IJBPermissioned {\n    function PERMISSIONS() external view returns (IJBPermissions);\n}\n"
			},
			"src/interfaces/IJBPermissions.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBPermissionsData} from \"./../structs/JBPermissionsData.sol\";\n\ninterface IJBPermissions {\n    event OperatorPermissionsSet(\n        address indexed operator,\n        address indexed account,\n        uint256 indexed projectId,\n        uint8[] permissionIds,\n        uint256 packed,\n        address caller\n    );\n\n    function WILDCARD_PROJECT_ID() external view returns (uint256);\n\n    function permissionsOf(address operator, address account, uint256 projectId) external view returns (uint256);\n\n    function hasPermission(\n        address operator,\n        address account,\n        uint256 projectId,\n        uint256 permissionId,\n        bool includeRoot,\n        bool includeWildcardProjectId\n    )\n        external\n        view\n        returns (bool);\n\n    function hasPermissions(\n        address operator,\n        address account,\n        uint256 projectId,\n        uint256[] calldata permissionIds,\n        bool includeRoot,\n        bool includeWildcardProjectId\n    )\n        external\n        view\n        returns (bool);\n\n    function setPermissionsFor(address account, JBPermissionsData calldata permissionsData) external;\n}\n"
			},
			"src/interfaces/IJBPriceFeed.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBPriceFeed {\n    function currentUnitPrice(uint256 targetDecimals) external view returns (uint256);\n}\n"
			},
			"src/interfaces/IJBPrices.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPriceFeed} from \"./IJBPriceFeed.sol\";\nimport {IJBProjects} from \"./IJBProjects.sol\";\n\ninterface IJBPrices {\n    event AddPriceFeed(\n        uint256 indexed projectId, uint256 indexed pricingCurrency, uint256 indexed unitCurrency, IJBPriceFeed feed\n    );\n\n    function DEFAULT_PROJECT_ID() external view returns (uint256);\n\n    function PROJECTS() external view returns (IJBProjects);\n\n    function priceFeedFor(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency\n    )\n        external\n        view\n        returns (IJBPriceFeed);\n\n    function pricePerUnitOf(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency,\n        uint256 decimals\n    )\n        external\n        view\n        returns (uint256);\n\n    function addPriceFeedFor(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency,\n        IJBPriceFeed feed\n    )\n        external;\n}\n"
			},
			"src/interfaces/IJBProjectUriRegistry.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBProjectUriRegistry {\n    function uriOf(uint256 projectId) external view returns (string memory);\n    function setUriOf(uint256 projectId, string calldata metadata) external;\n}\n"
			},
			"src/interfaces/IJBRedeemHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBAfterRedeemRecordedContext} from \"./../structs/JBAfterRedeemRecordedContext.sol\";\n\n/// @notice Hook called after a terminal's `redeemTokensOf(...)` logic completes (if passed by the ruleset's data hook).\ninterface IJBRedeemHook is IERC165 {\n    /// @notice This function is called by the terminal's `redeemTokensOf(...)` function after the redemption has been\n    /// recorded in the terminal store.\n    /// @dev Critical business logic should be protected by appropriate access control.\n    /// @param context The context passed in by the terminal, as a `JBAfterRedeemRecordedContext` struct.\n    function afterRedeemRecordedWith(JBAfterRedeemRecordedContext calldata context) external payable;\n}\n"
			},
			"src/interfaces/IJBRulesetDataHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBBeforePayRecordedContext} from \"./../structs/JBBeforePayRecordedContext.sol\";\nimport {JBBeforeRedeemRecordedContext} from \"./../structs/JBBeforeRedeemRecordedContext.sol\";\nimport {JBPayHookSpecification} from \"./../structs/JBPayHookSpecification.sol\";\nimport {JBRedeemHookSpecification} from \"./../structs/JBRedeemHookSpecification.sol\";\n\n/// @notice Data hooks can extend a terminal's core pay/redeem functionality by overriding the weight or memo. They can\n/// also specify pay/redeem hooks for the terminal to fulfill, or allow addresses to mint a project's tokens on-demand.\n/// @dev If a project's ruleset has `useDataHookForPay` or `useDataHookForRedeem` enabled, its `dataHook` is called by\n/// the terminal upon payments/redemptions (respectively).\ninterface IJBRulesetDataHook is IERC165 {\n    /// @notice A flag indicating whether an address has permission to mint a project's tokens on-demand.\n    /// @dev A project's data hook can allow any address to mint its tokens.\n    /// @param projectId The ID of the project whose token can be minted.\n    /// @param addr The address to check the token minting permission of.\n    /// @return flag A flag indicating whether the address has permission to mint the project's tokens on-demand.\n    function hasMintPermissionFor(uint256 projectId, address addr) external view returns (bool flag);\n\n    /// @notice The data calculated before a payment is recorded in the terminal store. This data is provided to the\n    /// terminal's `pay(...)` transaction.\n    /// @param context The context passed to this data hook by the `pay(...)` function as a `JBBeforePayRecordedContext`\n    /// struct.\n    /// @return weight The new `weight` to use, overriding the ruleset's `weight`.\n    /// @return hookSpecifications The amount and data to send to pay hooks instead of adding to the terminal's balance.\n    function beforePayRecordedWith(JBBeforePayRecordedContext calldata context)\n        external\n        view\n        returns (uint256 weight, JBPayHookSpecification[] memory hookSpecifications);\n\n    /// @notice The data calculated before a redemption is recorded in the terminal store. This data is provided to the\n    /// terminal's `redeemTokensOf(...)` transaction.\n    /// @param context The context passed to this data hook by the `redeemTokensOf(...)` function as a\n    /// `JBBeforeRedeemRecordedContext` struct.\n    /// @return redemptionRate The rate determining the amount that should be reclaimable for a given surplus and token\n    /// supply.\n    /// @return redeemCount The amount of tokens that should be considered redeemed.\n    /// @return totalSupply The total amount of tokens that are considered to be existing.\n    /// @return hookSpecifications The amount and data to send to redeem hooks instead of returning to the beneficiary.\n    function beforeRedeemRecordedWith(JBBeforeRedeemRecordedContext calldata context)\n        external\n        view\n        returns (\n            uint256 redemptionRate,\n            uint256 redeemCount,\n            uint256 totalSupply,\n            JBRedeemHookSpecification[] memory hookSpecifications\n        );\n}\n"
			},
			"src/interfaces/IJBToken.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBToken {\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function mint(address account, uint256 amount) external;\n\n    function burn(address account, uint256 amount) external;\n\n    function initialize(string memory name, string memory symbol, address owner) external;\n}\n"
			},
			"src/interfaces/IJBTokens.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBToken} from \"./IJBToken.sol\";\n\ninterface IJBTokens {\n    event DeployERC20(\n        uint256 indexed projectId, IJBToken indexed token, string name, string symbol, bytes32 salt, address caller\n    );\n\n    event Mint(\n        address indexed holder, uint256 indexed projectId, uint256 amount, bool tokensWereClaimed, address caller\n    );\n\n    event Burn(\n        address indexed holder,\n        uint256 indexed projectId,\n        uint256 amount,\n        uint256 initialCreditBalance,\n        uint256 initialTokenBalance,\n        address caller\n    );\n\n    event ClaimTokens(\n        address indexed holder,\n        uint256 indexed projectId,\n        uint256 initialCreditBalance,\n        uint256 amount,\n        address beneficiary,\n        address caller\n    );\n\n    event SetToken(uint256 indexed projectId, IJBToken indexed newToken, address caller);\n\n    event TransferCredits(\n        address indexed holder, uint256 indexed projectId, address indexed recipient, uint256 amount, address caller\n    );\n\n    function tokenOf(uint256 projectId) external view returns (IJBToken);\n\n    function projectIdOf(IJBToken token) external view returns (uint256);\n\n    function creditBalanceOf(address holder, uint256 projectId) external view returns (uint256);\n\n    function totalCreditSupplyOf(uint256 projectId) external view returns (uint256);\n\n    function totalSupplyOf(uint256 projectId) external view returns (uint256);\n\n    function totalBalanceOf(address holder, uint256 projectId) external view returns (uint256 result);\n\n    function deployERC20For(\n        uint256 projectId,\n        string calldata name,\n        string calldata symbol,\n        bytes32 salt\n    )\n        external\n        returns (IJBToken token);\n\n    function setTokenFor(uint256 projectId, IJBToken token) external;\n\n    function burnFrom(address holder, uint256 projectId, uint256 amount) external;\n\n    function mintFor(address holder, uint256 projectId, uint256 amount) external;\n\n    function claimTokensFor(address holder, uint256 projectId, uint256 amount, address beneficiary) external;\n\n    function transferCreditsFrom(address holder, uint256 projectId, address recipient, uint256 amount) external;\n}\n"
			},
			"src/libraries/JBRulesetMetadataResolver.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {JBRulesetMetadata} from \"./../structs/JBRulesetMetadata.sol\";\n\nlibrary JBRulesetMetadataResolver {\n    function reservedPercent(JBRuleset memory ruleset) internal pure returns (uint16) {\n        return uint16(ruleset.metadata >> 4);\n    }\n\n    function redemptionRate(JBRuleset memory ruleset) internal pure returns (uint16) {\n        // Redemption rate is a number 0-10000.\n        return uint16(ruleset.metadata >> 20);\n    }\n\n    function baseCurrency(JBRuleset memory ruleset) internal pure returns (uint32) {\n        // Currency is a number 0-4294967296.\n        return uint32(ruleset.metadata >> 36);\n    }\n\n    function pausePay(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 68) & 1) == 1;\n    }\n\n    function pauseCreditTransfers(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 69) & 1) == 1;\n    }\n\n    function allowOwnerMinting(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 70) & 1) == 1;\n    }\n\n    function allowSetCustomToken(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 71) & 1) == 1;\n    }\n\n    function allowTerminalMigration(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 72) & 1) == 1;\n    }\n\n    function allowSetTerminals(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 73) & 1) == 1;\n    }\n\n    function allowSetController(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 74) & 1) == 1;\n    }\n\n    function allowAddAccountingContext(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 75) & 1) == 1;\n    }\n\n    function allowAddPriceFeed(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 76) & 1) == 1;\n    }\n\n    function ownerMustSendPayouts(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 77) & 1) == 1;\n    }\n\n    function holdFees(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 78) & 1) == 1;\n    }\n\n    function useTotalSurplusForRedemptions(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 79) & 1) == 1;\n    }\n\n    function useDataHookForPay(JBRuleset memory ruleset) internal pure returns (bool) {\n        return (ruleset.metadata >> 80) & 1 == 1;\n    }\n\n    function useDataHookForRedeem(JBRuleset memory ruleset) internal pure returns (bool) {\n        return (ruleset.metadata >> 81) & 1 == 1;\n    }\n\n    function dataHook(JBRuleset memory ruleset) internal pure returns (address) {\n        return address(uint160(ruleset.metadata >> 82));\n    }\n\n    function metadata(JBRuleset memory ruleset) internal pure returns (uint16) {\n        return uint16(ruleset.metadata >> 242);\n    }\n\n    /// @notice Pack the funding cycle metadata.\n    /// @param rulesetMetadata The ruleset metadata to validate and pack.\n    /// @return packed The packed uint256 of all metadata params. The first 8 bits specify the version.\n    function packRulesetMetadata(JBRulesetMetadata memory rulesetMetadata) internal pure returns (uint256 packed) {\n        // version 1 in the bits 0-3 (4 bits).\n        packed = 1;\n        // reserved percent in bits 4-19 (16 bits).\n        packed |= uint256(rulesetMetadata.reservedPercent) << 4;\n        // redemption rate in bits 20-35 (16 bits).\n        // redemption rate is a number 0-10000.\n        packed |= uint256(rulesetMetadata.redemptionRate) << 20;\n        // base currency in bits 36-67 (32 bits).\n        // base currency is a number 0-16777215.\n        packed |= uint256(rulesetMetadata.baseCurrency) << 36;\n        // pause pay in bit 68.\n        if (rulesetMetadata.pausePay) packed |= 1 << 68;\n        // pause credit transfers in bit 69.\n        if (rulesetMetadata.pauseCreditTransfers) packed |= 1 << 69;\n        // allow discretionary minting in bit 70.\n        if (rulesetMetadata.allowOwnerMinting) packed |= 1 << 70;\n        // allow a custom token to be set in bit 71.\n        if (rulesetMetadata.allowSetCustomToken) packed |= 1 << 71;\n        // allow terminal migration in bit 72.\n        if (rulesetMetadata.allowTerminalMigration) packed |= 1 << 72;\n        // allow set terminals in bit 73.\n        if (rulesetMetadata.allowSetTerminals) packed |= 1 << 73;\n        // allow set controller in bit 74.\n        if (rulesetMetadata.allowSetController) packed |= 1 << 74;\n        // allow add accounting context in bit 75.\n        if (rulesetMetadata.allowAddAccountingContext) packed |= 1 << 75;\n        // allow add price feed in bit 76.\n        if (rulesetMetadata.allowAddPriceFeed) packed |= 1 << 76;\n        // allow controller migration in bit 77.\n        if (rulesetMetadata.ownerMustSendPayouts) packed |= 1 << 77;\n        // hold fees in bit 78.\n        if (rulesetMetadata.holdFees) packed |= 1 << 78;\n        // useTotalSurplusForRedemptions in bit 79.\n        if (rulesetMetadata.useTotalSurplusForRedemptions) packed |= 1 << 79;\n        // use pay data source in bit 80.\n        if (rulesetMetadata.useDataHookForPay) packed |= 1 << 80;\n        // use redeem data source in bit 81.\n        if (rulesetMetadata.useDataHookForRedeem) packed |= 1 << 81;\n        // data source address in bits 82-241.\n        packed |= uint256(uint160(address(rulesetMetadata.dataHook))) << 82;\n        // metadata in bits 242-255 (14 bits).\n        packed |= (uint256(rulesetMetadata.metadata) >> 2) << 242;\n    }\n\n    /// @notice Expand the funding cycle metadata.\n    /// @param ruleset The funding cycle having its metadata expanded.\n    /// @return rulesetMetadata The ruleset's metadata object.\n    function expandMetadata(JBRuleset memory ruleset) internal pure returns (JBRulesetMetadata memory) {\n        return JBRulesetMetadata(\n            reservedPercent(ruleset),\n            redemptionRate(ruleset),\n            baseCurrency(ruleset),\n            pausePay(ruleset),\n            pauseCreditTransfers(ruleset),\n            allowOwnerMinting(ruleset),\n            allowSetCustomToken(ruleset),\n            allowTerminalMigration(ruleset),\n            allowSetTerminals(ruleset),\n            allowSetController(ruleset),\n            allowAddAccountingContext(ruleset),\n            allowAddPriceFeed(ruleset),\n            ownerMustSendPayouts(ruleset),\n            holdFees(ruleset),\n            useTotalSurplusForRedemptions(ruleset),\n            useDataHookForPay(ruleset),\n            useDataHookForRedeem(ruleset),\n            dataHook(ruleset),\n            metadata(ruleset)\n        );\n    }\n}\n"
			},
			"src/libraries/JBSplitGroupIds.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary JBSplitGroupIds {\n    uint256 public constant RESERVED_TOKENS = 1;\n}\n"
			},
			"src/structs/JBAfterRedeemRecordedContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTokenAmount} from \"./JBTokenAmount.sol\";\n\n/// @custom:member holder The holder of the tokens being redeemed.\n/// @custom:member projectId The ID of the project being redeemed from.\n/// @custom:member rulesetId The ID of the ruleset the redemption is being made during.\n/// @custom:member redeemCount The number of project tokens being redeemed.\n/// @custom:member redemptionRate The current ruleset's redemption rate.\n/// @custom:member reclaimedAmount The token amount being reclaimed from the project's terminal balance. Includes the\n/// token being\n/// reclaimed, the value, the number of decimals included, and the currency of the amount.\n/// @custom:member forwardedAmount The token amount being forwarded to the redeem hook. Includes the token\n/// being forwarded, the value, the number of decimals included, and the currency of the amount.\n/// @custom:member beneficiary The address the reclaimed amount will be sent to.\n/// @custom:member hookMetadata Extra data specified by the data hook, which is sent to the redeem hook.\n/// @custom:member redeemerMetadata Extra data specified by the redeemer, which is sent to the redeem hook.\nstruct JBAfterRedeemRecordedContext {\n    address holder;\n    uint256 projectId;\n    uint256 rulesetId;\n    uint256 redeemCount;\n    JBTokenAmount reclaimedAmount;\n    JBTokenAmount forwardedAmount;\n    uint256 redemptionRate;\n    address payable beneficiary;\n    bytes hookMetadata;\n    bytes redeemerMetadata;\n}\n"
			},
			"src/structs/JBBeforePayRecordedContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTokenAmount} from \"./JBTokenAmount.sol\";\n\n/// @notice Context sent from the terminal to the ruleset's data hook upon payment.\n/// @custom:member terminal The terminal that is facilitating the payment.\n/// @custom:member payer The address that the payment originated from.\n/// @custom:member amount The payment's token amount, including the token being paid, the value, the number of decimals\n/// included, and the currency of the amount.\n/// @custom:member projectId The ID of the project being paid.\n/// @custom:member rulesetId The ID of the ruleset the payment is being made during.\n/// @custom:member beneficiary The specified address that should be the beneficiary of anything that this payment\n/// yields.\n/// @custom:member weight The weight of the ruleset during which the payment is being made.\n/// @custom:member reservedPercent The reserved percent of the ruleset the payment is being made during.\n/// @custom:member metadata Extra data specified by the payer.\nstruct JBBeforePayRecordedContext {\n    address terminal;\n    address payer;\n    JBTokenAmount amount;\n    uint256 projectId;\n    uint256 rulesetId;\n    address beneficiary;\n    uint256 weight;\n    uint256 reservedPercent;\n    bytes metadata;\n}\n"
			},
			"src/structs/JBBeforeRedeemRecordedContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTokenAmount} from \"./JBTokenAmount.sol\";\n\n/// @notice Context sent from the terminal to the ruleset's data hook upon redemption.\n/// @custom:member terminal The terminal that is facilitating the redemption.\n/// @custom:member holder The holder of the tokens being redeemed.\n/// @custom:member projectId The ID of the project whose tokens are being redeemed.\n/// @custom:member rulesetId The ID of the ruleset the redemption is being made during.\n/// @custom:member redeemCount The number of tokens being redeemed, as a fixed point number with 18 decimals.\n/// @custom:member totalSupply The total token supply being used for the calculation, as a fixed point number with 18\n/// decimals.\n/// @custom:member surplus The surplus amount used for the calculation, as a fixed point number with 18 decimals.\n/// Includes the token of the surplus, the surplus value, the number of decimals\n/// included, and the currency of the surplus.\n/// @custom:member useTotalSurplus If surplus across all of a project's terminals is being used when making redemptions.\n/// @custom:member redemptionRate The redemption rate of the ruleset the redemption is being made during.\n/// @custom:member metadata Extra data provided by the redeemer.\nstruct JBBeforeRedeemRecordedContext {\n    address terminal;\n    address holder;\n    uint256 projectId;\n    uint256 rulesetId;\n    uint256 redeemCount;\n    uint256 totalSupply;\n    JBTokenAmount surplus;\n    bool useTotalSurplus;\n    uint256 redemptionRate;\n    bytes metadata;\n}\n"
			},
			"src/structs/JBCurrencyAmount.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member amount The amount of the currency.\n/// @custom:member currency The currency. By convention, this is `uint32(uint160(tokenAddress))` for tokens, or a\n/// constant ID from e.g. `JBCurrencyIds` for other currencies.\nstruct JBCurrencyAmount {\n    uint224 amount;\n    uint32 currency;\n}\n"
			},
			"src/structs/JBFundAccessLimitGroup.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBCurrencyAmount} from \"./JBCurrencyAmount.sol\";\n\n/// @dev Payout limit example: if the `amount` is 5, the `currency` is 1 (USD), and the terminal's token is ETH, then\n/// the project can pay out 5 USD worth of ETH during a ruleset.\n/// @dev Surplus allowance example: if the `amount` is 5, the `currency` is 1 (USD), and the terminal's token is ETH,\n/// then the project can pay out 5 USD worth of ETH from its surplus during a ruleset. A project's surplus is its\n/// balance minus its current combined payout limit.\n/// @dev If a project has multiple payout limits or surplus allowances, they are all available. They can all be used\n/// during a single ruleset.\n/// @dev The payout limits' and surplus allowances' fixed point amounts have the same number of decimals as the\n/// terminal.\n/// @custom:member terminal The terminal that the payout limits and surplus allowances apply to.\n/// @custom:member token The token that the payout limits and surplus allowances apply to within the `terminal`.\n/// @custom:member payoutLimits An array of payout limits. The payout limits cumulatively dictate the maximum value of\n/// `token`s a project can pay out from its balance in a terminal during a ruleset. Each payout limit can have a unique\n/// currency and amount.\n/// @custom:member surplusAllowances An array of surplus allowances. The surplus allowances cumulatively dictates the\n/// maximum value of `token`s a project can pay out from its surplus (balance less payouts) in a terminal during a\n/// ruleset. Each surplus allowance can have a unique currency and amount.\nstruct JBFundAccessLimitGroup {\n    address terminal;\n    address token;\n    JBCurrencyAmount[] payoutLimits;\n    JBCurrencyAmount[] surplusAllowances;\n}\n"
			},
			"src/structs/JBPayHookSpecification.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPayHook} from \"../interfaces/IJBPayHook.sol\";\n\n/// @notice A pay hook specification sent from the ruleset's data hook back to the terminal. This specification is\n/// fulfilled by the terminal.\n/// @custom:member hook The pay hook to use when fulfilling this specification.\n/// @custom:member amount The amount to send to the hook.\n/// @custom:member metadata Metadata to pass the hook.\nstruct JBPayHookSpecification {\n    IJBPayHook hook;\n    uint256 amount;\n    bytes metadata;\n}\n"
			},
			"src/structs/JBPermissionsData.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member operator The address that permissions are being given to.\n/// @custom:member projectId The ID of the project the operator is being given permissions for. Operators only have\n/// permissions under this project's scope. An ID of 0 is a wildcard, which gives an operator permissions across all\n/// projects.\n/// @custom:member permissionIds The IDs of the permissions being given. See the `JBPermissionIds` library.\nstruct JBPermissionsData {\n    address operator;\n    uint56 projectId;\n    uint8[] permissionIds;\n}\n"
			},
			"src/structs/JBRedeemHookSpecification.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBRedeemHook} from \"../interfaces/IJBRedeemHook.sol\";\n\n/// @notice A redeem hook specification sent from the ruleset's data hook back to the terminal. This specification is\n/// fulfilled by the terminal.\n/// @custom:member hook The redeem hook to use when fulfilling this specification.\n/// @custom:member amount The amount to send to the hook.\n/// @custom:member metadata Metadata to pass to the hook.\nstruct JBRedeemHookSpecification {\n    IJBRedeemHook hook;\n    uint256 amount;\n    bytes metadata;\n}\n"
			},
			"src/structs/JBRulesetConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBRulesetApprovalHook} from \"../interfaces/IJBRulesetApprovalHook.sol\";\nimport {JBFundAccessLimitGroup} from \"./JBFundAccessLimitGroup.sol\";\nimport {JBRulesetMetadata} from \"./JBRulesetMetadata.sol\";\nimport {JBSplitGroup} from \"./JBSplitGroup.sol\";\n\n/// @custom:member mustStartAtOrAfter The earliest time the ruleset can start.\n/// @custom:member duration The number of seconds the ruleset lasts for, after which a new ruleset will start. A\n/// duration of 0 means that the ruleset will stay active until the project owner explicitly issues a reconfiguration,\n/// at which point a new ruleset will immediately start with the updated properties. If the duration is greater than 0,\n/// a project owner cannot make changes to a ruleset's parameters while it is active  any proposed changes will apply\n/// to the subsequent ruleset. If no changes are proposed, a ruleset rolls over to another one with the same properties\n/// but new `start` timestamp and a decayed `weight`.\n/// @custom:member weight A fixed point number with 18 decimals that contracts can use to base arbitrary calculations\n/// on. For example, payment terminals can use this to determine how many tokens should be minted when a payment is\n/// received.\n/// @custom:member decayPercent A percent by how much the `weight` of the subsequent ruleset should be reduced, if the\n/// project owner hasn't queued the subsequent ruleset with an explicit `weight`. If it's 0, each ruleset will have\n/// equal weight. If the number is 90%, the next ruleset will have a 10% smaller weight. This weight is out of\n/// `JBConstants.MAX_DECAY_PERCENT`.\n/// @custom:member approvalHook An address of a contract that says whether a proposed ruleset should be accepted or\n/// rejected. It\n/// can be used to create rules around how a project owner can change ruleset parameters over time.\n/// @custom:member metadata Metadata specifying the controller-specific parameters that a ruleset can have. These\n/// properties cannot change until the next ruleset starts.\n/// @custom:member splitGroups An array of splits to use for any number of groups while the ruleset is active.\n/// @custom:member fundAccessLimitGroups An array of structs which dictate the amount of funds a project can access from\n/// its balance in each payment terminal while the ruleset is active. Amounts are fixed point numbers using the same\n/// number of decimals as the corresponding terminal. The `_payoutLimit` and `_surplusAllowance` parameters must fit in\n/// a `uint232`.\nstruct JBRulesetConfig {\n    uint48 mustStartAtOrAfter;\n    uint32 duration;\n    uint112 weight;\n    uint32 decayPercent;\n    IJBRulesetApprovalHook approvalHook;\n    JBRulesetMetadata metadata;\n    JBSplitGroup[] splitGroups;\n    JBFundAccessLimitGroup[] fundAccessLimitGroups;\n}\n"
			},
			"src/structs/JBRulesetMetadata.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member reservedPercent The reserved percent of the ruleset. This number is a percentage calculated out of\n/// `JBConstants.MAX_RESERVED_PERCENT`.\n/// @custom:member redemptionRate The redemption rate of the ruleset. This number is a percentage calculated out of\n/// `JBConstants.MAX_REDEMPTION_RATE`.\n/// @custom:member baseCurrency The currency on which to base the ruleset's weight. By convention, this is\n/// `uint32(uint160(tokenAddress))` for tokens, or a constant ID from e.g. `JBCurrencyIds` for other currencies.\n/// @custom:member pausePay A flag indicating if the pay functionality should be paused during the ruleset.\n/// @custom:member pauseCreditTransfers A flag indicating if the project token transfer functionality should be paused\n/// during the funding cycle.\n/// @custom:member allowOwnerMinting A flag indicating if the project owner or an operator with the `MINT_TOKENS`\n/// permission from the owner should be allowed to mint project tokens on demand during this ruleset.\n/// @custom:member allowTerminalMigration A flag indicating if migrating terminals should be allowed during this\n/// ruleset.\n/// @custom:member allowSetTerminals A flag indicating if a project's terminals can be added or removed.\n/// @custom:member allowSetController A flag indicating if a project's controller can be changed.\n/// @custom:member allowAddAccountingContext A flag indicating if a project can add new accounting contexts for its\n/// terminals to use.\n/// @custom:member allowAddPriceFeed A flag indicating if a project can add new price feeds to calculate exchange rates\n/// between its tokens.\n/// @custom:member ownerMustSendPayouts A flag indicating if privileged payout distribution should be\n/// enforced, otherwise payouts can be distributed by anyone.\n/// @custom:member holdFees A flag indicating if fees should be held during this ruleset.\n/// @custom:member useTotalSurplusForRedemptions A flag indicating if redemptions should use the project's balance held\n/// in all terminals instead of the project's local terminal balance from which the redemption is being fulfilled.\n/// @custom:member useDataHookForPay A flag indicating if the data hook should be used for pay transactions during this\n/// ruleset.\n/// @custom:member useDataHookForRedeem A flag indicating if the data hook should be used for redeem transactions during\n/// this ruleset.\n/// @custom:member dataHook The data hook to use during this ruleset.\n/// @custom:member metadata Metadata of the metadata, up to uint16 in size though only the first 14 bits can be used.\nstruct JBRulesetMetadata {\n    uint16 reservedPercent;\n    uint16 redemptionRate;\n    uint32 baseCurrency;\n    bool pausePay;\n    bool pauseCreditTransfers;\n    bool allowOwnerMinting;\n    bool allowSetCustomToken;\n    bool allowTerminalMigration;\n    bool allowSetTerminals;\n    bool allowSetController;\n    bool allowAddAccountingContext;\n    bool allowAddPriceFeed;\n    bool ownerMustSendPayouts;\n    bool holdFees;\n    bool useTotalSurplusForRedemptions;\n    bool useDataHookForPay;\n    bool useDataHookForRedeem;\n    address dataHook;\n    uint16 metadata;\n}\n"
			},
			"src/structs/JBRulesetWithMetadata.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBRuleset} from \"./JBRuleset.sol\";\nimport {JBRulesetMetadata} from \"./JBRulesetMetadata.sol\";\n\n/// @custom:member ruleset The ruleset.\n/// @custom:member metadata The ruleset's metadata.\nstruct JBRulesetWithMetadata {\n    JBRuleset ruleset;\n    JBRulesetMetadata metadata;\n}\n"
			},
			"src/structs/JBTerminalConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBTerminal} from \"./../interfaces/IJBTerminal.sol\";\nimport {JBAccountingContext} from \"./JBAccountingContext.sol\";\n\n/// @custom:member terminal The terminal to configure.\n/// @custom:member accountingContextsToAccept The accounting contexts to accept from the terminal.\nstruct JBTerminalConfig {\n    IJBTerminal terminal;\n    JBAccountingContext[] accountingContextsToAccept;\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
			},
			"src/JBTerminalStore.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {mulDiv} from \"@prb/math/src/Common.sol\";\n\nimport {IJBController} from \"./interfaces/IJBController.sol\";\nimport {IJBDirectory} from \"./interfaces/IJBDirectory.sol\";\nimport {IJBPrices} from \"./interfaces/IJBPrices.sol\";\nimport {IJBRulesetDataHook} from \"./interfaces/IJBRulesetDataHook.sol\";\nimport {IJBRulesets} from \"./interfaces/IJBRulesets.sol\";\nimport {IJBTerminal} from \"./interfaces/IJBTerminal.sol\";\nimport {IJBTerminalStore} from \"./interfaces/IJBTerminalStore.sol\";\nimport {JBConstants} from \"./libraries/JBConstants.sol\";\nimport {JBFixedPointNumber} from \"./libraries/JBFixedPointNumber.sol\";\nimport {JBRedemptions} from \"./libraries/JBRedemptions.sol\";\nimport {JBRulesetMetadataResolver} from \"./libraries/JBRulesetMetadataResolver.sol\";\nimport {JBAccountingContext} from \"./structs/JBAccountingContext.sol\";\nimport {JBBeforePayRecordedContext} from \"./structs/JBBeforePayRecordedContext.sol\";\nimport {JBBeforeRedeemRecordedContext} from \"./structs/JBBeforeRedeemRecordedContext.sol\";\nimport {JBCurrencyAmount} from \"./structs/JBCurrencyAmount.sol\";\nimport {JBPayHookSpecification} from \"./structs/JBPayHookSpecification.sol\";\nimport {JBRedeemHookSpecification} from \"./structs/JBRedeemHookSpecification.sol\";\nimport {JBRuleset} from \"./structs/JBRuleset.sol\";\nimport {JBTokenAmount} from \"./structs/JBTokenAmount.sol\";\n\n/// @notice Manages all bookkeeping for inflows and outflows of funds from any terminal address.\n/// @dev This contract expects a project's controller to be an `IJBController`.\ncontract JBTerminalStore is ReentrancyGuard, IJBTerminalStore {\n    // A library that parses the packed ruleset metadata into a friendlier format.\n    using JBRulesetMetadataResolver for JBRuleset;\n\n    //*********************************************************************//\n    // --------------------------- custom errors ------------------------- //\n    //*********************************************************************//\n    error INVALID_AMOUNT_TO_SEND_HOOK();\n    error PAYOUT_LIMIT_EXCEEDED();\n    error RULESET_PAYMENT_PAUSED();\n    error INADEQUATE_CONTROLLER_ALLOWANCE();\n    error INADEQUATE_TERMINAL_STORE_BALANCE();\n    error INSUFFICIENT_TOKENS();\n    error INVALID_RULESET();\n    error TERMINAL_MIGRATION_NOT_ALLOWED();\n\n    //*********************************************************************//\n    // -------------------------- internal constants --------------------- //\n    //*********************************************************************//\n\n    /// @notice Constrains `mulDiv` operations on fixed point numbers to a maximum number of decimal points of persisted\n    /// fidelity.\n    uint256 internal constant _MAX_FIXED_POINT_FIDELITY = 18;\n\n    //*********************************************************************//\n    // ---------------- public immutable stored properties --------------- //\n    //*********************************************************************//\n\n    /// @notice The directory of terminals and controllers for projects.\n    IJBDirectory public immutable override DIRECTORY;\n\n    /// @notice The contract storing and managing project rulesets.\n    IJBRulesets public immutable override RULESETS;\n\n    /// @notice The contract that exposes price feeds.\n    IJBPrices public immutable override PRICES;\n\n    //*********************************************************************//\n    // --------------------- public stored properties -------------------- //\n    //*********************************************************************//\n\n    /// @notice A project's balance of a specific token within a terminal.\n    /// @dev The balance is represented as a fixed point number with the same amount of decimals as its relative\n    /// terminal.\n    /// @custom:param terminal The terminal to get the project's balance within.\n    /// @custom:param projectId The ID of the project to get the balance of.\n    /// @custom:param token The token to get the balance for.\n    mapping(address terminal => mapping(uint256 projectId => mapping(address token => uint256))) public override\n        balanceOf;\n\n    /// @notice The currency-denominated amount of funds that a project has already paid out from its payout limit\n    /// during the current ruleset for each terminal, in terms of the payout limit's currency.\n    /// @dev Increases as projects pay out funds.\n    /// @dev The used payout limit is represented as a fixed point number with the same amount of decimals as the\n    /// terminal it applies to.\n    /// @custom:param terminal The terminal the payout limit applies to.\n    /// @custom:param projectId The ID of the project to get the used payout limit of.\n    /// @custom:param token The token the payout limit applies to in the terminal.\n    /// @custom:param rulesetCycleNumber The cycle number of the ruleset the payout limit was used during.\n    /// @custom:param currency The currency the payout limit is in terms of.\n    mapping(\n        address terminal\n            => mapping(\n                uint256 projectId\n                    => mapping(\n                        address token => mapping(uint256 rulesetCycleNumber => mapping(uint256 currency => uint256))\n                    )\n            )\n    ) public override usedPayoutLimitOf;\n\n    /// @notice The currency-denominated amounts of funds that a project has used from its surplus allowance during the\n    /// current ruleset for each terminal, in terms of the surplus allowance's currency.\n    /// @dev Increases as projects use their allowance.\n    /// @dev The used surplus allowance is represented as a fixed point number with the same amount of decimals as the\n    /// terminal it applies to.\n    /// @custom:param terminal The terminal the surplus allowance applies to.\n    /// @custom:param projectId The ID of the project to get the used surplus allowance of.\n    /// @custom:param token The token the surplus allowance applies to in the terminal.\n    /// @custom:param rulesetId The ID of the ruleset the surplus allowance was used during.\n    /// @custom:param currency The currency the surplus allowance is in terms of.\n    mapping(\n        address terminal\n            => mapping(\n                uint256 projectId\n                    => mapping(address token => mapping(uint256 rulesetId => mapping(uint256 currency => uint256)))\n            )\n    ) public override usedSurplusAllowanceOf;\n\n    //*********************************************************************//\n    // ------------------------- external views -------------------------- //\n    //*********************************************************************//\n\n    /// @notice Gets the current surplus amount in a terminal for a specified project.\n    /// @dev The surplus is the amount of funds a project has in a terminal in excess of its payout limit.\n    /// @dev The surplus is represented as a fixed point number with the same amount of decimals as the specified\n    /// terminal.\n    /// @param terminal The terminal the surplus is being calculated for.\n    /// @param projectId The ID of the project to get surplus for.\n    /// @param accountingContexts The accounting contexts of tokens whose balances should contribute to the surplus\n    /// being calculated.\n    /// @param currency The currency the resulting amount should be in terms of.\n    /// @param decimals The number of decimals to expect in the resulting fixed point number.\n    /// @return The current surplus amount the project has in the specified terminal.\n    function currentSurplusOf(\n        address terminal,\n        uint256 projectId,\n        JBAccountingContext[] calldata accountingContexts,\n        uint256 decimals,\n        uint256 currency\n    )\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // Return the surplus during the project's current ruleset.\n        return _surplusFrom({\n            terminal: terminal,\n            projectId: projectId,\n            accountingContexts: accountingContexts,\n            ruleset: RULESETS.currentOf(projectId),\n            targetDecimals: decimals,\n            targetCurrency: currency\n        });\n    }\n\n    /// @notice Gets the current surplus amount for a specified project across all terminals.\n    /// @param projectId The ID of the project to get the total surplus for.\n    /// @param decimals The number of decimals that the fixed point surplus should include.\n    /// @param currency The currency that the total surplus should be in terms of.\n    /// @return The current total surplus amount that the project has across all terminals.\n    function currentTotalSurplusOf(\n        uint256 projectId,\n        uint256 decimals,\n        uint256 currency\n    )\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _currentTotalSurplusOf(projectId, decimals, currency);\n    }\n\n    /// @notice Returns the number of surplus terminal tokens that would be reclaimed from a terminal by redeeming a\n    /// given number of tokens, based on the total token supply and total surplus.\n    /// @dev The returned amount in terms of the specified `terminal`'s base currency.\n    /// @dev The returned amount is represented as a fixed point number with the same amount of decimals as the\n    /// specified terminal.\n    /// @param terminal The terminal that would be redeemed from. If `useTotalSurplus` is true, this is ignored.\n    /// @param projectId The ID of the project whose tokens would be redeemed.\n    /// @param accountingContexts The accounting contexts of the surplus terminal tokens that would be reclaimed\n    /// @param decimals The number of decimals to include in the resulting fixed point number.\n    /// @param currency The currency that the resulting number will be in terms of.\n    /// @param tokensRedeemed The number of tokens that would be redeemed, as a fixed point number with 18 decimals.\n    /// @param useTotalSurplus Whether the total surplus should be summed across all of the project's terminals. If\n    /// false, only the `terminal`'s surplus is used.\n    /// @return The amount of surplus terminal tokens that would be reclaimed by redeeming `tokensRedeemed` tokens.\n    function currentReclaimableSurplusOf(\n        address terminal,\n        uint256 projectId,\n        JBAccountingContext[] calldata accountingContexts,\n        uint256 decimals,\n        uint256 currency,\n        uint256 tokensRedeemed,\n        bool useTotalSurplus\n    )\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // Get a reference to the project's current ruleset.\n        JBRuleset memory ruleset = RULESETS.currentOf(projectId);\n\n        // Get the current surplus amount.\n        // If `useTotalSurplus` is true, use the total surplus across all terminals. Otherwise, get the `terminal`'s\n        // surplus.\n        uint256 currentSurplus = useTotalSurplus\n            ? _currentTotalSurplusOf(projectId, decimals, currency)\n            : _surplusFrom(terminal, projectId, accountingContexts, ruleset, decimals, currency);\n\n        // If there's no surplus, nothing can be reclaimed.\n        if (currentSurplus == 0) return 0;\n\n        // Get the project token's total supply.\n        uint256 totalSupply =\n            IJBController(address(DIRECTORY.controllerOf(projectId))).totalTokenSupplyWithReservedTokensOf(projectId);\n\n        // Can't redeem more tokens than are in the total supply.\n        if (tokensRedeemed > totalSupply) return 0;\n\n        // Return the amount of surplus terminal tokens that would be reclaimed.\n        return JBRedemptions.reclaimFrom({\n            surplus: currentSurplus,\n            tokensRedeemed: tokensRedeemed,\n            totalSupply: totalSupply,\n            redemptionRate: ruleset.redemptionRate()\n        });\n    }\n\n    /// @notice Returns the number of surplus terminal tokens that would be reclaimed by redeeming a given project's\n    /// tokens based on its current ruleset and the given total project token supply and total terminal token surplus.\n    /// @param projectId The ID of the project whose project tokens would be redeemed.\n    /// @param tokensRedeemed The number of project tokens that would be redeemed, as a fixed point number with 18\n    /// decimals.\n    /// @param totalSupply The total project token supply, as a fixed point number with 18 decimals.\n    /// @param surplus The total terminal token surplus amount, as a fixed point number.\n    /// @return The number of surplus terminal tokens that would be reclaimed, as a fixed point number with the same\n    /// number of decimals as the provided `surplus`.\n    function currentReclaimableSurplusOf(\n        uint256 projectId,\n        uint256 tokensRedeemed,\n        uint256 totalSupply,\n        uint256 surplus\n    )\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // If there's no surplus, nothing can be reclaimed.\n        if (surplus == 0) return 0;\n\n        // Can't redeem more tokens than are in the total supply.\n        if (tokensRedeemed > totalSupply) return 0;\n\n        // Get a reference to the project's current ruleset.\n        JBRuleset memory ruleset = RULESETS.currentOf(projectId);\n\n        // Return the amount of surplus terminal tokens that would be reclaimed.\n        return JBRedemptions.reclaimFrom({\n            surplus: surplus,\n            tokensRedeemed: tokensRedeemed,\n            totalSupply: totalSupply,\n            redemptionRate: ruleset.redemptionRate()\n        });\n    }\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param directory A contract storing directories of terminals and controllers for each project.\n    /// @param rulesets A contract storing and managing project rulesets.\n    /// @param prices A contract that exposes price feeds.\n    constructor(IJBDirectory directory, IJBRulesets rulesets, IJBPrices prices) {\n        DIRECTORY = directory;\n        RULESETS = rulesets;\n        PRICES = prices;\n    }\n\n    //*********************************************************************//\n    // ---------------------- external transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice Records a payment to a project.\n    /// @dev Mints the project's tokens according to values provided by the ruleset's data hook. If the ruleset has no\n    /// data hook, mints tokens in proportion with the amount paid.\n    /// @param payer The address that made the payment to the terminal.\n    /// @param amount The amount of tokens being paid. Includes the token being paid, their value, the number of\n    /// decimals included, and the currency of the amount.\n    /// @param projectId The ID of the project being paid.\n    /// @param beneficiary The address that should be the beneficiary of anything the payment yields (including project\n    /// tokens minted by the payment).\n    /// @param metadata Bytes to send to the data hook, if the project's current ruleset specifies one.\n    /// @return ruleset The ruleset the payment was made during, as a `JBRuleset` struct.\n    /// @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.\n    /// @return hookSpecifications A list of pay hooks, including data and amounts to send to them. The terminal should\n    /// fulfill these specifications.\n    function recordPaymentFrom(\n        address payer,\n        JBTokenAmount calldata amount,\n        uint256 projectId,\n        address beneficiary,\n        bytes calldata metadata\n    )\n        external\n        override\n        nonReentrant\n        returns (JBRuleset memory ruleset, uint256 tokenCount, JBPayHookSpecification[] memory hookSpecifications)\n    {\n        // Get a reference to the project's current ruleset.\n        ruleset = RULESETS.currentOf(projectId);\n\n        // The project must have a ruleset.\n        if (ruleset.cycleNumber == 0) revert INVALID_RULESET();\n\n        // The ruleset must not have payments paused.\n        if (ruleset.pausePay()) revert RULESET_PAYMENT_PAUSED();\n\n        // The weight according to which new tokens are to be minted, as a fixed point number with 18 decimals.\n        uint256 weight;\n\n        // If the ruleset has a data hook enabled for payments, use it to derive a weight and memo.\n        if (ruleset.useDataHookForPay() && ruleset.dataHook() != address(0)) {\n            // Create the pay context that'll be sent to the data hook.\n            JBBeforePayRecordedContext memory context = JBBeforePayRecordedContext({\n                terminal: msg.sender,\n                payer: payer,\n                amount: amount,\n                projectId: uint56(projectId),\n                rulesetId: ruleset.id,\n                beneficiary: beneficiary,\n                weight: ruleset.weight,\n                reservedPercent: ruleset.reservedPercent(),\n                metadata: metadata\n            });\n\n            (weight, hookSpecifications) = IJBRulesetDataHook(ruleset.dataHook()).beforePayRecordedWith(context);\n        }\n        // Otherwise use the ruleset's weight\n        else {\n            weight = ruleset.weight;\n        }\n\n        // Keep a reference to the amount that should be added to the project's balance.\n        uint256 balanceDiff = amount.value;\n\n        // Scoped section preventing stack too deep.\n        {\n            // Keep a reference to the number of hook specifications.\n            uint256 numberOfSpecifications = hookSpecifications.length;\n\n            // Ensure that the specifications have valid amounts.\n            if (numberOfSpecifications != 0) {\n                for (uint256 i; i < numberOfSpecifications; i++) {\n                    // Get a reference to the specification's amount.\n                    uint256 specifiedAmount = hookSpecifications[i].amount;\n\n                    // Ensure the amount is non-zero.\n                    if (specifiedAmount != 0) {\n                        // Can't send more to hook than was paid.\n                        if (specifiedAmount > balanceDiff) {\n                            revert INVALID_AMOUNT_TO_SEND_HOOK();\n                        }\n\n                        // Decrement the total amount being added to the local balance.\n                        balanceDiff = balanceDiff - specifiedAmount;\n                    }\n                }\n            }\n        }\n\n        // If there's no amount being recorded, there's nothing left to do.\n        if (amount.value == 0) return (ruleset, 0, hookSpecifications);\n\n        // Add the correct balance difference to the token balance of the project.\n        if (balanceDiff != 0) {\n            balanceOf[msg.sender][projectId][amount.token] =\n                balanceOf[msg.sender][projectId][amount.token] + balanceDiff;\n        }\n\n        // If there's no weight, the token count must be 0, so there's nothing left to do.\n        if (weight == 0) return (ruleset, 0, hookSpecifications);\n\n        // If the terminal should base its weight on a currency other than the terminal's currency, determine the\n        // factor. The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the\n        // same\n        // number of decimals as the `amount`.\n        uint256 weightRatio = amount.currency == ruleset.baseCurrency()\n            ? 10 ** amount.decimals\n            : PRICES.pricePerUnitOf({\n                projectId: projectId,\n                pricingCurrency: amount.currency,\n                unitCurrency: ruleset.baseCurrency(),\n                decimals: amount.decimals\n            });\n\n        // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has.\n        tokenCount = mulDiv(amount.value, weight, weightRatio);\n    }\n\n    /// @notice Records a redemption from a project.\n    /// @dev Redeems the project's tokens according to values provided by the ruleset's data hook. If the ruleset has no\n    /// data hook, redeems tokens along a redemption bonding curve that is a function of the number of tokens being\n    /// burned.\n    /// @param holder The account that is redeeming tokens.\n    /// @param projectId The ID of the project being redeemed from.\n    /// @param redeemCount The number of project tokens to redeem, as a fixed point number with 18 decimals.\n    /// @param accountingContext The accounting context of the token being reclaimed by the redemption.\n    /// @param balanceAccountingContexts The accounting contexts of the tokens whose balances should contribute to the\n    /// surplus being reclaimed from.\n    /// @param metadata Bytes to send to the data hook, if the project's current ruleset specifies one.\n    /// @return ruleset The ruleset during the redemption was made during, as a `JBRuleset` struct. This ruleset will\n    /// have a redemption rate provided by the redemption hook if applicable.\n    /// @return reclaimAmount The amount of tokens reclaimed from the terminal, as a fixed point number with 18\n    /// decimals.\n    /// @return redemptionRate The redemption rate influencing the reclaim amount.\n    /// @return hookSpecifications A list of redeem hooks, including data and amounts to send to them. The terminal\n    /// should fulfill these specifications.\n    function recordRedemptionFor(\n        address holder,\n        uint256 projectId,\n        uint256 redeemCount,\n        JBAccountingContext calldata accountingContext,\n        JBAccountingContext[] calldata balanceAccountingContexts,\n        bytes memory metadata\n    )\n        external\n        override\n        nonReentrant\n        returns (\n            JBRuleset memory ruleset,\n            uint256 reclaimAmount,\n            uint256 redemptionRate,\n            JBRedeemHookSpecification[] memory hookSpecifications\n        )\n    {\n        // Get a reference to the project's current ruleset.\n        ruleset = RULESETS.currentOf(projectId);\n\n        // Get the current surplus amount.\n        // Use the local surplus if the ruleset specifies that it should be used. Otherwise, use the project's total\n        // surplus across all of its terminals.\n        uint256 currentSurplus = ruleset.useTotalSurplusForRedemptions()\n            ? _currentTotalSurplusOf({\n                projectId: projectId,\n                decimals: accountingContext.decimals,\n                currency: accountingContext.currency\n            })\n            : _surplusFrom({\n                terminal: msg.sender,\n                projectId: projectId,\n                accountingContexts: balanceAccountingContexts,\n                ruleset: ruleset,\n                targetDecimals: accountingContext.decimals,\n                targetCurrency: accountingContext.currency\n            });\n\n        // Get the total number of outstanding project tokens.\n        uint256 totalSupply =\n            IJBController(address(DIRECTORY.controllerOf(projectId))).totalTokenSupplyWithReservedTokensOf(projectId);\n\n        // Can't redeem more tokens that are in the supply.\n        if (redeemCount > totalSupply) revert INSUFFICIENT_TOKENS();\n\n        // If the ruleset has a data hook which is enabled for redemptions, use it to derive a claim amount and memo.\n        if (ruleset.useDataHookForRedeem() && ruleset.dataHook() != address(0)) {\n            // Create the redeem context that'll be sent to the data hook.\n            JBBeforeRedeemRecordedContext memory context = JBBeforeRedeemRecordedContext({\n                terminal: msg.sender,\n                holder: holder,\n                projectId: uint56(projectId),\n                rulesetId: ruleset.id,\n                redeemCount: redeemCount,\n                totalSupply: totalSupply,\n                surplus: JBTokenAmount({\n                    token: accountingContext.token,\n                    value: currentSurplus,\n                    decimals: accountingContext.decimals,\n                    currency: accountingContext.currency\n                }),\n                useTotalSurplus: ruleset.useTotalSurplusForRedemptions(),\n                redemptionRate: ruleset.redemptionRate(),\n                metadata: metadata\n            });\n\n            (redemptionRate, redeemCount, totalSupply, hookSpecifications) =\n                IJBRulesetDataHook(ruleset.dataHook()).beforeRedeemRecordedWith(context);\n        } else {\n            redemptionRate = ruleset.redemptionRate();\n        }\n\n        if (currentSurplus != 0) {\n            // Calculate reclaim amount using the current surplus amount.\n            reclaimAmount = JBRedemptions.reclaimFrom({\n                surplus: currentSurplus,\n                tokensRedeemed: redeemCount,\n                totalSupply: totalSupply,\n                redemptionRate: redemptionRate\n            });\n        }\n\n        // Keep a reference to the amount that should be added to the project's balance.\n        uint256 balanceDiff = reclaimAmount;\n\n        // Ensure that the specifications have valid amounts.\n        if (hookSpecifications.length != 0) {\n            // Keep a reference to the number of redeem hooks specified.\n            uint256 numberOfSpecifications = hookSpecifications.length;\n\n            // Loop through each specification.\n            for (uint256 i; i < numberOfSpecifications; i++) {\n                // Get a reference to the specification's amount.\n                uint256 specificationAmount = hookSpecifications[i].amount;\n\n                // Ensure the amount is non-zero.\n                if (specificationAmount != 0) {\n                    // Increment the total amount being subtracted from the balance.\n                    balanceDiff = balanceDiff + specificationAmount;\n                }\n            }\n        }\n\n        // The amount being reclaimed must be within the project's balance.\n        if (balanceDiff > balanceOf[msg.sender][projectId][accountingContext.token]) {\n            revert INADEQUATE_TERMINAL_STORE_BALANCE();\n        }\n\n        // Remove the reclaimed funds from the project's balance.\n        if (balanceDiff != 0) {\n            unchecked {\n                balanceOf[msg.sender][projectId][accountingContext.token] =\n                    balanceOf[msg.sender][projectId][accountingContext.token] - balanceDiff;\n            }\n        }\n    }\n\n    /// @notice Records a payout from a project.\n    /// @param projectId The ID of the project that is paying out funds.\n    /// @param accountingContext The context of the token being paid out.\n    /// @param amount The amount to pay out (use from the payout limit), as a fixed point number.\n    /// @param currency The currency of the `amount`. This must match the project's current ruleset's currency.\n    /// @return ruleset The ruleset the payout was made during, as a `JBRuleset` struct.\n    /// @return amountPaidOut The amount of terminal tokens paid out, as a fixed point number with the same amount of\n    /// decimals as its relative terminal.\n    function recordPayoutFor(\n        uint256 projectId,\n        JBAccountingContext calldata accountingContext,\n        uint256 amount,\n        uint256 currency\n    )\n        external\n        override\n        nonReentrant\n        returns (JBRuleset memory ruleset, uint256 amountPaidOut)\n    {\n        // Get a reference to the project's current ruleset.\n        ruleset = RULESETS.currentOf(projectId);\n\n        // The new total amount which has been paid out during this ruleset.\n        uint256 newUsedPayoutLimitOf =\n            usedPayoutLimitOf[msg.sender][projectId][accountingContext.token][ruleset.cycleNumber][currency] + amount;\n\n        // Amount must be within what is still available to pay out.\n        uint256 payoutLimit = IJBController(address(DIRECTORY.controllerOf(projectId))).FUND_ACCESS_LIMITS()\n            .payoutLimitOf({\n            projectId: projectId,\n            rulesetId: ruleset.id,\n            terminal: msg.sender,\n            token: accountingContext.token,\n            currency: currency\n        });\n\n        // Make sure the new used amount is within the payout limit.\n        if (newUsedPayoutLimitOf > payoutLimit || payoutLimit == 0) {\n            revert PAYOUT_LIMIT_EXCEEDED();\n        }\n\n        // Convert the amount to the balance's currency.\n        amountPaidOut = (currency == accountingContext.currency)\n            ? amount\n            : mulDiv(\n                amount,\n                10 ** _MAX_FIXED_POINT_FIDELITY, // Use `_MAX_FIXED_POINT_FIDELITY` to keep as much of the `_amount`'s\n                    // fidelity as possible when converting.\n                PRICES.pricePerUnitOf({\n                    projectId: projectId,\n                    pricingCurrency: currency,\n                    unitCurrency: accountingContext.currency,\n                    decimals: _MAX_FIXED_POINT_FIDELITY\n                })\n            );\n\n        // The amount being paid out must be available.\n        if (amountPaidOut > balanceOf[msg.sender][projectId][accountingContext.token]) {\n            revert INADEQUATE_TERMINAL_STORE_BALANCE();\n        }\n\n        // Store the new amount.\n        usedPayoutLimitOf[msg.sender][projectId][accountingContext.token][ruleset.cycleNumber][currency] =\n            newUsedPayoutLimitOf;\n\n        // Removed the paid out funds from the project's token balance.\n        unchecked {\n            balanceOf[msg.sender][projectId][accountingContext.token] =\n                balanceOf[msg.sender][projectId][accountingContext.token] - amountPaidOut;\n        }\n    }\n\n    /// @notice Records a use of a project's surplus allowance.\n    /// @dev When surplus allowance is \"used\", it is taken out of the project's surplus within a terminal.\n    /// @param projectId The ID of the project to use the surplus allowance of.\n    /// @param accountingContext The accounting context of the token whose balances should contribute to the surplus\n    /// allowance being reclaimed from.\n    /// @param amount The amount to use from the surplus allowance, as a fixed point number.\n    /// @param currency The currency of the `amount`. Must match the currency of the surplus allowance.\n    /// @return ruleset The ruleset during the surplus allowance is being used during, as a `JBRuleset` struct.\n    /// @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals\n    /// as its relative terminal.\n    function recordUsedAllowanceOf(\n        uint256 projectId,\n        JBAccountingContext calldata accountingContext,\n        uint256 amount,\n        uint256 currency\n    )\n        external\n        override\n        nonReentrant\n        returns (JBRuleset memory ruleset, uint256 usedAmount)\n    {\n        // Get a reference to the project's current ruleset.\n        ruleset = RULESETS.currentOf(projectId);\n\n        // Get a reference to the new used surplus allowance for this ruleset ID.\n        uint256 newUsedSurplusAllowanceOf =\n            usedSurplusAllowanceOf[msg.sender][projectId][accountingContext.token][ruleset.id][currency] + amount;\n\n        // There must be sufficient surplus allowance available.\n        uint256 surplusAllowance = IJBController(address(DIRECTORY.controllerOf(projectId))).FUND_ACCESS_LIMITS()\n            .surplusAllowanceOf({\n            projectId: projectId,\n            rulesetId: ruleset.id,\n            terminal: msg.sender,\n            token: accountingContext.token,\n            currency: currency\n        });\n\n        // Make sure the new used amount is within the allowance.\n        if (newUsedSurplusAllowanceOf > surplusAllowance || surplusAllowance == 0) {\n            revert INADEQUATE_CONTROLLER_ALLOWANCE();\n        }\n\n        // Convert the amount to this store's terminal's token.\n        usedAmount = currency == accountingContext.currency\n            ? amount\n            : mulDiv(\n                amount,\n                10 ** _MAX_FIXED_POINT_FIDELITY, // Use `_MAX_FIXED_POINT_FIDELITY` to keep as much of the `amount`'s\n                    // fidelity as possible when converting.\n                PRICES.pricePerUnitOf({\n                    projectId: projectId,\n                    pricingCurrency: currency,\n                    unitCurrency: accountingContext.currency,\n                    decimals: _MAX_FIXED_POINT_FIDELITY\n                })\n            );\n\n        // Set the token being used as the only one to look for surplus within.\n        JBAccountingContext[] memory accountingContexts = new JBAccountingContext[](1);\n        accountingContexts[0] = accountingContext;\n\n        // The amount being used must be available in the surplus.\n        if (\n            usedAmount\n                > _surplusFrom({\n                    terminal: msg.sender,\n                    projectId: projectId,\n                    accountingContexts: accountingContexts,\n                    ruleset: ruleset,\n                    targetDecimals: accountingContext.decimals,\n                    targetCurrency: accountingContext.currency\n                })\n        ) revert INADEQUATE_TERMINAL_STORE_BALANCE();\n\n        // Store the incremented value.\n        usedSurplusAllowanceOf[msg.sender][projectId][accountingContext.token][ruleset.id][currency] =\n            newUsedSurplusAllowanceOf;\n\n        // Update the project's balance.\n        balanceOf[msg.sender][projectId][accountingContext.token] =\n            balanceOf[msg.sender][projectId][accountingContext.token] - usedAmount;\n    }\n\n    /// @notice Records funds being added to a project's balance.\n    /// @param projectId The ID of the project which funds are being added to the balance of.\n    /// @param token The token being added to the balance.\n    /// @param amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as\n    /// its relative terminal.\n    function recordAddedBalanceFor(uint256 projectId, address token, uint256 amount) external override {\n        // Increment the balance.\n        balanceOf[msg.sender][projectId][token] = balanceOf[msg.sender][projectId][token] + amount;\n    }\n\n    /// @notice Records the migration of funds from this store.\n    /// @param projectId The ID of the project being migrated.\n    /// @param token The token being migrated.\n    /// @return balance The project's current balance (which is being migrated), as a fixed point number with the same\n    /// amount of decimals as its relative terminal.\n    function recordTerminalMigration(\n        uint256 projectId,\n        address token\n    )\n        external\n        override\n        nonReentrant\n        returns (uint256 balance)\n    {\n        // Get a reference to the project's current ruleset.\n        JBRuleset memory ruleset = RULESETS.currentOf(projectId);\n\n        // Terminal migration must be allowed.\n        if (!ruleset.allowTerminalMigration()) {\n            revert TERMINAL_MIGRATION_NOT_ALLOWED();\n        }\n\n        // Return the current balance, which is the amount being migrated.\n        balance = balanceOf[msg.sender][projectId][token];\n\n        // Set the balance to 0.\n        balanceOf[msg.sender][projectId][token] = 0;\n    }\n\n    //*********************************************************************//\n    // --------------------- internal helper functions ------------------- //\n    //*********************************************************************//\n\n    /// @notice Gets a project's surplus amount in a terminal as measured by a given ruleset, across multiple accounting\n    /// contexts.\n    /// @dev This amount changes as the value of the balance changes in relation to the currency being used to measure\n    /// various payout limits.\n    /// @param terminal The terminal the surplus is being calculated for.\n    /// @param projectId The ID of the project to get the surplus for.\n    /// @param accountingContexts The accounting contexts of tokens whose balances should contribute to the surplus\n    /// being calculated.\n    /// @param ruleset The ID of the ruleset to base the surplus on.\n    /// @param targetDecimals The number of decimals to include in the resulting fixed point number.\n    /// @param targetCurrency The currency that the reported surplus is expected to be in terms of.\n    /// @return surplus The surplus of funds in terms of `targetCurrency`, as a fixed point number with\n    /// `targetDecimals` decimals.\n    function _surplusFrom(\n        address terminal,\n        uint256 projectId,\n        JBAccountingContext[] memory accountingContexts,\n        JBRuleset memory ruleset,\n        uint256 targetDecimals,\n        uint256 targetCurrency\n    )\n        internal\n        view\n        returns (uint256 surplus)\n    {\n        // Keep a reference to the number of tokens being iterated on.\n        uint256 numberOfTokenAccountingContexts = accountingContexts.length;\n\n        // Add payout limits from each token.\n        for (uint256 i; i < numberOfTokenAccountingContexts; i++) {\n            uint256 tokenSurplus = _tokenSurplusFrom({\n                terminal: terminal,\n                projectId: projectId,\n                accountingContext: accountingContexts[i],\n                ruleset: ruleset,\n                targetDecimals: targetDecimals,\n                targetCurrency: targetCurrency\n            });\n            // Increment the surplus with any remaining balance.\n            if (tokenSurplus > 0) surplus += tokenSurplus;\n        }\n    }\n\n    /// @notice Get a project's surplus amount of a specific token in a given terminal as measured by a given ruleset\n    /// (one specific accounting context).\n    /// @dev This amount changes as the value of the balance changes in relation to the currency being used to measure\n    /// the payout limits.\n    /// @param terminal The terminal the surplus is being calculated for.\n    /// @param projectId The ID of the project to get the surplus of.\n    /// @param accountingContext The accounting context of the token whose balance should contribute to the surplus\n    /// being measured.\n    /// @param ruleset The ID of the ruleset to base the surplus calculation on.\n    /// @param targetDecimals The number of decimals to include in the resulting fixed point number.\n    /// @param targetCurrency The currency that the reported surplus is expected to be in terms of.\n    /// @return surplus The surplus of funds in terms of `targetCurrency`, as a fixed point number with\n    /// `targetDecimals` decimals.\n    function _tokenSurplusFrom(\n        address terminal,\n        uint256 projectId,\n        JBAccountingContext memory accountingContext,\n        JBRuleset memory ruleset,\n        uint256 targetDecimals,\n        uint256 targetCurrency\n    )\n        internal\n        view\n        returns (uint256 surplus)\n    {\n        // Keep a reference to the balance.\n        surplus = balanceOf[terminal][projectId][accountingContext.token];\n\n        // If needed, adjust the decimals of the fixed point number to have the correct decimals.\n        surplus = accountingContext.decimals == targetDecimals\n            ? surplus\n            : JBFixedPointNumber.adjustDecimals({\n                value: surplus,\n                decimals: accountingContext.decimals,\n                targetDecimals: targetDecimals\n            });\n\n        // Add up all the balances.\n        surplus = (surplus == 0 || accountingContext.currency == targetCurrency)\n            ? surplus\n            : mulDiv(\n                surplus,\n                10 ** _MAX_FIXED_POINT_FIDELITY, // Use `_MAX_FIXED_POINT_FIDELITY` to keep as much of the\n                    // `_payoutLimitRemaining`'s fidelity as possible when converting.\n                PRICES.pricePerUnitOf({\n                    projectId: projectId,\n                    pricingCurrency: accountingContext.currency,\n                    unitCurrency: targetCurrency,\n                    decimals: _MAX_FIXED_POINT_FIDELITY\n                })\n            );\n\n        // Get a reference to the payout limit during the ruleset for the token.\n        JBCurrencyAmount[] memory payoutLimits = IJBController(address(DIRECTORY.controllerOf(projectId)))\n            .FUND_ACCESS_LIMITS().payoutLimitsOf({\n            projectId: projectId,\n            rulesetId: ruleset.id,\n            terminal: address(terminal),\n            token: accountingContext.token\n        });\n\n        // Keep a reference to the payout limit being iterated on.\n        JBCurrencyAmount memory payoutLimit;\n\n        // Keep a reference to the number of payout limits being iterated on.\n        uint256 numberOfPayoutLimits = payoutLimits.length;\n\n        // Loop through each payout limit to determine the cumulative normalized payout limit remaining.\n        for (uint256 i; i < numberOfPayoutLimits; i++) {\n            payoutLimit = payoutLimits[i];\n\n            // Set the payout limit value to the amount still available to pay out during the ruleset.\n            payoutLimit.amount = uint224(\n                payoutLimit.amount\n                    - usedPayoutLimitOf[terminal][projectId][accountingContext.token][ruleset.cycleNumber][payoutLimit\n                        .currency]\n            );\n\n            // Adjust the decimals of the fixed point number if needed to have the correct decimals.\n            payoutLimit.amount = accountingContext.decimals == targetDecimals\n                ? payoutLimit.amount\n                : uint224(\n                    JBFixedPointNumber.adjustDecimals({\n                        value: payoutLimit.amount,\n                        decimals: accountingContext.decimals,\n                        targetDecimals: targetDecimals\n                    })\n                );\n\n            // Convert the `payoutLimit`'s amount to be in terms of the provided currency.\n            payoutLimit.amount = payoutLimit.amount == 0 || payoutLimit.currency == targetCurrency\n                ? payoutLimit.amount\n                : uint224(\n                    mulDiv(\n                        payoutLimit.amount,\n                        10 ** _MAX_FIXED_POINT_FIDELITY, // Use `_MAX_FIXED_POINT_FIDELITY` to keep as much of the\n                            // `payoutLimitRemaining`'s fidelity as possible when converting.\n                        PRICES.pricePerUnitOf({\n                            projectId: projectId,\n                            pricingCurrency: payoutLimit.currency,\n                            unitCurrency: targetCurrency,\n                            decimals: _MAX_FIXED_POINT_FIDELITY\n                        })\n                    )\n                );\n\n            // Decrement from the balance until it reaches zero.\n            if (surplus > payoutLimit.amount) {\n                surplus -= payoutLimit.amount;\n            } else {\n                return 0;\n            }\n        }\n    }\n\n    /// @notice Gets the total current surplus amount across all of a project's terminals.\n    /// @dev This amount changes as the value of the balances changes in relation to the currency being used to measure\n    /// the project's payout limits.\n    /// @param projectId The ID of the project to get the total surplus for.\n    /// @param decimals The number of decimals that the fixed point surplus result should include.\n    /// @param currency The currency that the surplus result should be in terms of.\n    /// @return surplus The total surplus of a project's funds in terms of `currency`, as a fixed point number with the\n    /// specified number of decimals.\n    function _currentTotalSurplusOf(\n        uint256 projectId,\n        uint256 decimals,\n        uint256 currency\n    )\n        internal\n        view\n        returns (uint256 surplus)\n    {\n        // Get a reference to the project's terminals.\n        IJBTerminal[] memory terminals = DIRECTORY.terminalsOf(projectId);\n\n        // Keep a reference to the number of termainls.\n        uint256 numberOfTerminals = terminals.length;\n\n        // Add the current surplus for each terminal.\n        for (uint256 i; i < numberOfTerminals; i++) {\n            surplus += terminals[i].currentSurplusOf(projectId, decimals, currency);\n        }\n    }\n}\n"
			},
			"src/interfaces/IJBTerminalStore.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBAccountingContext} from \"./../structs/JBAccountingContext.sol\";\nimport {JBPayHookSpecification} from \"./../structs/JBPayHookSpecification.sol\";\nimport {JBRedeemHookSpecification} from \"./../structs/JBRedeemHookSpecification.sol\";\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {JBTokenAmount} from \"./../structs/JBTokenAmount.sol\";\nimport {IJBDirectory} from \"./IJBDirectory.sol\";\nimport {IJBPrices} from \"./IJBPrices.sol\";\nimport {IJBRulesets} from \"./IJBRulesets.sol\";\n\ninterface IJBTerminalStore {\n    function RULESETS() external view returns (IJBRulesets);\n\n    function DIRECTORY() external view returns (IJBDirectory);\n\n    function PRICES() external view returns (IJBPrices);\n\n    function balanceOf(address terminal, uint256 projectId, address token) external view returns (uint256);\n\n    function usedPayoutLimitOf(\n        address terminal,\n        uint256 projectId,\n        address token,\n        uint256 rulesetCycleNumber,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256);\n\n    function usedSurplusAllowanceOf(\n        address terminal,\n        uint256 projectId,\n        address token,\n        uint256 rulesetId,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256);\n\n    function currentSurplusOf(\n        address terminal,\n        uint256 projectId,\n        JBAccountingContext[] calldata accountingContexts,\n        uint256 decimals,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256);\n\n    function currentTotalSurplusOf(\n        uint256 projectId,\n        uint256 decimals,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256);\n\n    function currentReclaimableSurplusOf(\n        address terminal,\n        uint256 projectId,\n        JBAccountingContext[] calldata accountingContexts,\n        uint256 _decimals,\n        uint256 _currency,\n        uint256 tokenCount,\n        bool useTotalSurplus\n    )\n        external\n        view\n        returns (uint256);\n\n    function currentReclaimableSurplusOf(\n        uint256 projectId,\n        uint256 tokenCount,\n        uint256 totalSupply,\n        uint256 surplus\n    )\n        external\n        view\n        returns (uint256);\n\n    function recordPaymentFrom(\n        address payer,\n        JBTokenAmount memory amount,\n        uint256 projectId,\n        address beneficiary,\n        bytes calldata metadata\n    )\n        external\n        returns (JBRuleset memory ruleset, uint256 tokenCount, JBPayHookSpecification[] memory hookSpecifications);\n\n    function recordRedemptionFor(\n        address holder,\n        uint256 projectId,\n        uint256 redeemCount,\n        JBAccountingContext calldata accountingContext,\n        JBAccountingContext[] calldata balanceAccountingContexts,\n        bytes calldata metadata\n    )\n        external\n        returns (\n            JBRuleset memory ruleset,\n            uint256 reclaimAmount,\n            uint256 redemptionRate,\n            JBRedeemHookSpecification[] memory hookSpecifications\n        );\n\n    function recordPayoutFor(\n        uint256 projectId,\n        JBAccountingContext calldata accountingContext,\n        uint256 amount,\n        uint256 currency\n    )\n        external\n        returns (JBRuleset memory ruleset, uint256 amountPaidOut);\n\n    function recordUsedAllowanceOf(\n        uint256 projectId,\n        JBAccountingContext calldata accountingContext,\n        uint256 amount,\n        uint256 currency\n    )\n        external\n        returns (JBRuleset memory ruleset, uint256 withdrawnAmount);\n\n    function recordAddedBalanceFor(uint256 projectId, address token, uint256 amount) external;\n\n    function recordTerminalMigration(uint256 projectId, address token) external returns (uint256 balance);\n}\n"
			},
			"src/libraries/JBFixedPointNumber.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nlibrary JBFixedPointNumber {\n    function adjustDecimals(uint256 value, uint256 decimals, uint256 targetDecimals) internal pure returns (uint256) {\n        // If decimals need adjusting, multiply or divide the price by the decimal adjuster to get the normalized\n        // result.\n        if (targetDecimals == decimals) return value;\n        else if (targetDecimals > decimals) return value * 10 ** (targetDecimals - decimals);\n        else return value / 10 ** (decimals - targetDecimals);\n    }\n}\n"
			},
			"src/libraries/JBRedemptions.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {mulDiv} from \"@prb/math/src/Common.sol\";\n\nimport {JBConstants} from \"./JBConstants.sol\";\n\n/// @notice Redemption calculations.\nlibrary JBRedemptions {\n    /// @notice Returns the amount of surplus terminal tokens which can be reclaimed based on the total surplus, the\n    /// number of tokens being redeemed, the total token supply, and the ruleset's redemption rate.\n    /// @param surplus The total amount of surplus terminal tokens.\n    /// @param tokensRedeemed The number of tokens being redeemed, as a fixed point number with 18 decimals.\n    /// @param totalSupply The total token supply, as a fixed point number with 18 decimals.\n    /// @param redemptionRate The current ruleset's redemption rate.\n    /// @return The amount of surplus tokens that can be reclaimed.\n    function reclaimFrom(\n        uint256 surplus,\n        uint256 tokensRedeemed,\n        uint256 totalSupply,\n        uint256 redemptionRate\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        // If the redemption rate is 0, no surplus can be reclaimed.\n        if (redemptionRate == 0) return 0;\n\n        // If the total supply is being redeemed, return the entire surplus.\n        if (tokensRedeemed == totalSupply) return surplus;\n\n        // Get a reference to the linear proportion.\n        uint256 base = mulDiv(surplus, tokensRedeemed, totalSupply);\n\n        // These conditions are all part of the same curve.\n        // Edge conditions are separated to minimize the operations performed in those cases.\n        if (redemptionRate == JBConstants.MAX_REDEMPTION_RATE) {\n            return base;\n        }\n\n        return mulDiv(\n            base,\n            redemptionRate + mulDiv(tokensRedeemed, JBConstants.MAX_REDEMPTION_RATE - redemptionRate, totalSupply),\n            JBConstants.MAX_REDEMPTION_RATE\n        );\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
			},
			"node_modules/@uniswap/permit2/src/interfaces/IAllowanceTransfer.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IEIP712} from \"./IEIP712.sol\";\n\n/// @title AllowanceTransfer\n/// @notice Handles ERC20 token permissions through signature based allowance setting and ERC20 token transfers by checking allowed amounts\n/// @dev Requires user's token approval on the Permit2 contract\ninterface IAllowanceTransfer is IEIP712 {\n    /// @notice Thrown when an allowance on a token has expired.\n    /// @param deadline The timestamp at which the allowed amount is no longer valid\n    error AllowanceExpired(uint256 deadline);\n\n    /// @notice Thrown when an allowance on a token has been depleted.\n    /// @param amount The maximum amount allowed\n    error InsufficientAllowance(uint256 amount);\n\n    /// @notice Thrown when too many nonces are invalidated.\n    error ExcessiveInvalidation();\n\n    /// @notice Emits an event when the owner successfully invalidates an ordered nonce.\n    event NonceInvalidation(\n        address indexed owner, address indexed token, address indexed spender, uint48 newNonce, uint48 oldNonce\n    );\n\n    /// @notice Emits an event when the owner successfully sets permissions on a token for the spender.\n    event Approval(\n        address indexed owner, address indexed token, address indexed spender, uint160 amount, uint48 expiration\n    );\n\n    /// @notice Emits an event when the owner successfully sets permissions using a permit signature on a token for the spender.\n    event Permit(\n        address indexed owner,\n        address indexed token,\n        address indexed spender,\n        uint160 amount,\n        uint48 expiration,\n        uint48 nonce\n    );\n\n    /// @notice Emits an event when the owner sets the allowance back to 0 with the lockdown function.\n    event Lockdown(address indexed owner, address token, address spender);\n\n    /// @notice The permit data for a token\n    struct PermitDetails {\n        // ERC20 token address\n        address token;\n        // the maximum amount allowed to spend\n        uint160 amount;\n        // timestamp at which a spender's token allowances become invalid\n        uint48 expiration;\n        // an incrementing value indexed per owner,token,and spender for each signature\n        uint48 nonce;\n    }\n\n    /// @notice The permit message signed for a single token allowance\n    struct PermitSingle {\n        // the permit data for a single token alownce\n        PermitDetails details;\n        // address permissioned on the allowed tokens\n        address spender;\n        // deadline on the permit signature\n        uint256 sigDeadline;\n    }\n\n    /// @notice The permit message signed for multiple token allowances\n    struct PermitBatch {\n        // the permit data for multiple token allowances\n        PermitDetails[] details;\n        // address permissioned on the allowed tokens\n        address spender;\n        // deadline on the permit signature\n        uint256 sigDeadline;\n    }\n\n    /// @notice The saved permissions\n    /// @dev This info is saved per owner, per token, per spender and all signed over in the permit message\n    /// @dev Setting amount to type(uint160).max sets an unlimited approval\n    struct PackedAllowance {\n        // amount allowed\n        uint160 amount;\n        // permission expiry\n        uint48 expiration;\n        // an incrementing value indexed per owner,token,and spender for each signature\n        uint48 nonce;\n    }\n\n    /// @notice A token spender pair.\n    struct TokenSpenderPair {\n        // the token the spender is approved\n        address token;\n        // the spender address\n        address spender;\n    }\n\n    /// @notice Details for a token transfer.\n    struct AllowanceTransferDetails {\n        // the owner of the token\n        address from;\n        // the recipient of the token\n        address to;\n        // the amount of the token\n        uint160 amount;\n        // the token to be transferred\n        address token;\n    }\n\n    /// @notice A mapping from owner address to token address to spender address to PackedAllowance struct, which contains details and conditions of the approval.\n    /// @notice The mapping is indexed in the above order see: allowance[ownerAddress][tokenAddress][spenderAddress]\n    /// @dev The packed slot holds the allowed amount, expiration at which the allowed amount is no longer valid, and current nonce thats updated on any signature based approvals.\n    function allowance(address user, address token, address spender)\n        external\n        view\n        returns (uint160 amount, uint48 expiration, uint48 nonce);\n\n    /// @notice Approves the spender to use up to amount of the specified token up until the expiration\n    /// @param token The token to approve\n    /// @param spender The spender address to approve\n    /// @param amount The approved amount of the token\n    /// @param expiration The timestamp at which the approval is no longer valid\n    /// @dev The packed allowance also holds a nonce, which will stay unchanged in approve\n    /// @dev Setting amount to type(uint160).max sets an unlimited approval\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\n\n    /// @notice Permit a spender to a given amount of the owners token via the owner's EIP-712 signature\n    /// @dev May fail if the owner's nonce was invalidated in-flight by invalidateNonce\n    /// @param owner The owner of the tokens being approved\n    /// @param permitSingle Data signed over by the owner specifying the terms of approval\n    /// @param signature The owner's signature over the permit data\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n\n    /// @notice Permit a spender to the signed amounts of the owners tokens via the owner's EIP-712 signature\n    /// @dev May fail if the owner's nonce was invalidated in-flight by invalidateNonce\n    /// @param owner The owner of the tokens being approved\n    /// @param permitBatch Data signed over by the owner specifying the terms of approval\n    /// @param signature The owner's signature over the permit data\n    function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;\n\n    /// @notice Transfer approved tokens from one address to another\n    /// @param from The address to transfer from\n    /// @param to The address of the recipient\n    /// @param amount The amount of the token to transfer\n    /// @param token The token address to transfer\n    /// @dev Requires the from address to have approved at least the desired amount\n    /// of tokens to msg.sender.\n    function transferFrom(address from, address to, uint160 amount, address token) external;\n\n    /// @notice Transfer approved tokens in a batch\n    /// @param transferDetails Array of owners, recipients, amounts, and tokens for the transfers\n    /// @dev Requires the from addresses to have approved at least the desired amount\n    /// of tokens to msg.sender.\n    function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;\n\n    /// @notice Enables performing a \"lockdown\" of the sender's Permit2 identity\n    /// by batch revoking approvals\n    /// @param approvals Array of approvals to revoke.\n    function lockdown(TokenSpenderPair[] calldata approvals) external;\n\n    /// @notice Invalidate nonces for a given (token, spender) pair\n    /// @param token The token to invalidate nonces for\n    /// @param spender The spender to invalidate nonces for\n    /// @param newNonce The new nonce to set. Invalidates all nonces less than it.\n    /// @dev Can't invalidate more than 2**16 nonces per transaction.\n    function invalidateNonces(address token, address spender, uint48 newNonce) external;\n}\n"
			},
			"node_modules/@uniswap/permit2/src/interfaces/IEIP712.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IEIP712 {\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
			},
			"node_modules/@uniswap/permit2/src/interfaces/IPermit2.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ISignatureTransfer} from \"./ISignatureTransfer.sol\";\nimport {IAllowanceTransfer} from \"./IAllowanceTransfer.sol\";\n\n/// @notice Permit2 handles signature-based transfers in SignatureTransfer and allowance-based transfers in AllowanceTransfer.\n/// @dev Users must approve Permit2 before calling any of the transfer functions.\ninterface IPermit2 is ISignatureTransfer, IAllowanceTransfer {\n// IPermit2 unifies the two interfaces so users have maximal flexibility with their approval.\n}\n"
			},
			"node_modules/@uniswap/permit2/src/interfaces/ISignatureTransfer.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IEIP712} from \"./IEIP712.sol\";\n\n/// @title SignatureTransfer\n/// @notice Handles ERC20 token transfers through signature based actions\n/// @dev Requires user's token approval on the Permit2 contract\ninterface ISignatureTransfer is IEIP712 {\n    /// @notice Thrown when the requested amount for a transfer is larger than the permissioned amount\n    /// @param maxAmount The maximum amount a spender can request to transfer\n    error InvalidAmount(uint256 maxAmount);\n\n    /// @notice Thrown when the number of tokens permissioned to a spender does not match the number of tokens being transferred\n    /// @dev If the spender does not need to transfer the number of tokens permitted, the spender can request amount 0 to be transferred\n    error LengthMismatch();\n\n    /// @notice Emits an event when the owner successfully invalidates an unordered nonce.\n    event UnorderedNonceInvalidation(address indexed owner, uint256 word, uint256 mask);\n\n    /// @notice The token and amount details for a transfer signed in the permit transfer signature\n    struct TokenPermissions {\n        // ERC20 token address\n        address token;\n        // the maximum amount that can be spent\n        uint256 amount;\n    }\n\n    /// @notice The signed permit message for a single token transfer\n    struct PermitTransferFrom {\n        TokenPermissions permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /// @notice Specifies the recipient address and amount for batched transfers.\n    /// @dev Recipients and amounts correspond to the index of the signed token permissions array.\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount.\n    struct SignatureTransferDetails {\n        // recipient address\n        address to;\n        // spender requested amount\n        uint256 requestedAmount;\n    }\n\n    /// @notice Used to reconstruct the signed permit message for multiple token transfers\n    /// @dev Do not need to pass in spender address as it is required that it is msg.sender\n    /// @dev Note that a user still signs over a spender address\n    struct PermitBatchTransferFrom {\n        // the tokens and corresponding amounts permitted for a transfer\n        TokenPermissions[] permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /// @notice A map from token owner address and a caller specified word index to a bitmap. Used to set bits in the bitmap to prevent against signature replay protection\n    /// @dev Uses unordered nonces so that permit messages do not need to be spent in a certain order\n    /// @dev The mapping is indexed first by the token owner, then by an index specified in the nonce\n    /// @dev It returns a uint256 bitmap\n    /// @dev The index, or wordPosition is capped at type(uint248).max\n    function nonceBitmap(address, uint256) external view returns (uint256);\n\n    /// @notice Transfers a token using a signed permit message\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails The spender's requested transfer details for the permitted token\n    /// @param signature The signature to verify\n    function permitTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers a token using a signed permit message\n    /// @notice Includes extra data provided by the caller to verify signature over\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails The spender's requested transfer details for the permitted token\n    /// @param witness Extra data to include when checking the user signature\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\n    /// @param signature The signature to verify\n    function permitWitnessTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers multiple tokens using a signed permit message\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\n    /// @param signature The signature to verify\n    function permitTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers multiple tokens using a signed permit message\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\n    /// @notice Includes extra data provided by the caller to verify signature over\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\n    /// @param witness Extra data to include when checking the user signature\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\n    /// @param signature The signature to verify\n    function permitWitnessTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Invalidates the bits specified in mask for the bitmap at the word position\n    /// @dev The wordPos is maxed at type(uint248).max\n    /// @param wordPos A number to index the nonceBitmap at\n    /// @param mask A bitmap masked against msg.sender's current bitmap at the word position\n    function invalidateUnorderedNonces(uint256 wordPos, uint256 mask) external;\n}\n"
			},
			"src/JBMultiTerminal.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {JBPermissionIds} from \"@bananapus/permission-ids/src/JBPermissionIds.sol\";\nimport {ERC2771Context} from \"@openzeppelin/contracts/metatx/ERC2771Context.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {mulDiv} from \"@prb/math/src/Common.sol\";\nimport {IAllowanceTransfer} from \"@uniswap/permit2/src/interfaces/IAllowanceTransfer.sol\";\nimport {IPermit2} from \"@uniswap/permit2/src/interfaces/IPermit2.sol\";\n\nimport {JBPermissioned} from \"./abstract/JBPermissioned.sol\";\nimport {IJBController} from \"./interfaces/IJBController.sol\";\nimport {IJBDirectory} from \"./interfaces/IJBDirectory.sol\";\nimport {IJBFeelessAddresses} from \"./interfaces/IJBFeelessAddresses.sol\";\nimport {IJBFeeTerminal} from \"./interfaces/IJBFeeTerminal.sol\";\nimport {IJBMultiTerminal} from \"./interfaces/IJBMultiTerminal.sol\";\nimport {IJBPayoutTerminal} from \"./interfaces/IJBPayoutTerminal.sol\";\nimport {IJBPermissioned} from \"./interfaces/IJBPermissioned.sol\";\nimport {IJBPermitTerminal} from \"./interfaces/IJBPermitTerminal.sol\";\nimport {IJBPermissions} from \"./interfaces/IJBPermissions.sol\";\nimport {IJBProjects} from \"./interfaces/IJBProjects.sol\";\nimport {IJBRedeemTerminal} from \"./interfaces/IJBRedeemTerminal.sol\";\nimport {IJBRulesets} from \"./interfaces/IJBRulesets.sol\";\nimport {IJBSplitHook} from \"./interfaces/IJBSplitHook.sol\";\nimport {IJBSplits} from \"./interfaces/IJBSplits.sol\";\nimport {IJBTerminal} from \"./interfaces/IJBTerminal.sol\";\nimport {IJBTerminalStore} from \"./interfaces/IJBTerminalStore.sol\";\nimport {JBConstants} from \"./libraries/JBConstants.sol\";\nimport {JBFees} from \"./libraries/JBFees.sol\";\nimport {JBMetadataResolver} from \"./libraries/JBMetadataResolver.sol\";\nimport {JBRulesetMetadataResolver} from \"./libraries/JBRulesetMetadataResolver.sol\";\nimport {JBAccountingContext} from \"./structs/JBAccountingContext.sol\";\nimport {JBAfterPayRecordedContext} from \"./structs/JBAfterPayRecordedContext.sol\";\nimport {JBAfterRedeemRecordedContext} from \"./structs/JBAfterRedeemRecordedContext.sol\";\nimport {JBFee} from \"./structs/JBFee.sol\";\nimport {JBPayHookSpecification} from \"./structs/JBPayHookSpecification.sol\";\nimport {JBRedeemHookSpecification} from \"./structs/JBRedeemHookSpecification.sol\";\nimport {JBRuleset} from \"./structs/JBRuleset.sol\";\nimport {JBSingleAllowance} from \"./structs/JBSingleAllowance.sol\";\nimport {JBSplit} from \"./structs/JBSplit.sol\";\nimport {JBSplitHookContext} from \"./structs/JBSplitHookContext.sol\";\nimport {JBTokenAmount} from \"./structs/JBTokenAmount.sol\";\n\n/// @notice `JBMultiTerminal` manages native/ERC-20 payments, redemptions, and surplus allowance usage for any number of\n/// projects. Terminals are the entry point for operations involving inflows and outflows of funds.\ncontract JBMultiTerminal is JBPermissioned, ERC2771Context, IJBMultiTerminal {\n    // A library that parses the packed ruleset metadata into a friendlier format.\n    using JBRulesetMetadataResolver for JBRuleset;\n\n    // A library that adds default safety checks to ERC20 functionality.\n    using SafeERC20 for IERC20;\n\n    //*********************************************************************//\n    // --------------------------- custom errors ------------------------- //\n    //*********************************************************************//\n\n    error ACCOUNTING_CONTEXT_ALREADY_SET();\n    error ADDING_ACCOUNTING_CONTEXT_NOT_ALLOWED();\n    error FEE_TERMINAL_NOT_FOUND();\n    error INVALID_ACCOUNTING_CONTEXT_DECIMALS();\n    error INVALID_ACCOUNTING_CONTEXT_CURRENCY();\n    error UNDER_MIN_TOKENS_PAID_OUT();\n    error UNDER_MIN_TOKENS_RECLAIMED();\n    error UNDER_MIN_RETURNED_TOKENS();\n    error NO_MSG_VALUE_ALLOWED();\n    error OVERFLOW_ALERT();\n    error PERMIT_ALLOWANCE_NOT_ENOUGH();\n    error RECIPIENT_PROJECT_TERMINAL_NOT_FOUND();\n    error SPLIT_HOOK_INVALID();\n    error TERMINAL_TOKENS_INCOMPATIBLE();\n    error TOKEN_NOT_ACCEPTED();\n\n    //*********************************************************************//\n    // ------------------------- public constants ------------------------ //\n    //*********************************************************************//\n\n    /// @notice This terminal's fee (as a fraction out of `JBConstants.MAX_FEE`).\n    /// @dev Fees are charged on payouts to addresses and surplus allowance usage, as well as redemptions while the\n    /// redemption rate is less than 100%.\n    uint256 public constant override FEE = 25; // 2.5%\n\n    //*********************************************************************//\n    // ------------------------ internal constants ----------------------- //\n    //*********************************************************************//\n\n    /// @notice Project ID #1 receives fees. It should be the first project launched during the deployment process.\n    uint256 internal constant _FEE_BENEFICIARY_PROJECT_ID = 1;\n\n    /// @notice The number of seconds fees can be held for.\n    uint256 internal constant _FEE_HOLDING_SECONDS = 2_419_200; // 28 days\n\n    //*********************************************************************//\n    // ---------------- public immutable stored properties --------------- //\n    //*********************************************************************//\n\n    /// @notice Mints ERC-721s that represent project ownership and transfers.\n    IJBProjects public immutable override PROJECTS;\n\n    /// @notice The directory of terminals and controllers for PROJECTS.\n    IJBDirectory public immutable override DIRECTORY;\n\n    /// @notice The contract that stores splits for each project.\n    IJBSplits public immutable override SPLITS;\n\n    /// @notice The contract that stores and manages the terminal's data.\n    IJBTerminalStore public immutable override STORE;\n\n    /// @notice The contract that stores addresses that shouldn't incur fees when being paid towards or from.\n    IJBFeelessAddresses public immutable override FEELESS_ADDRESSES;\n\n    /// @notice The contract storing and managing project rulesets.\n    IJBRulesets public immutable override RULESETS;\n\n    /// @notice The permit2 utility.\n    IPermit2 public immutable override PERMIT2;\n\n    //*********************************************************************//\n    // --------------------- internal stored properties ------------------ //\n    //*********************************************************************//\n\n    /// @notice Context describing how a token is accounted for by a project.\n    /// @custom:param projectId The ID of the project that the token accounting context applies to.\n    /// @custom:param token The address of the token being accounted for.\n    mapping(uint256 projectId => mapping(address token => JBAccountingContext)) internal _accountingContextForTokenOf;\n\n    /// @notice A list of tokens accepted by each project.\n    /// @custom:param projectId The ID of the project to get a list of accepted tokens for.\n    mapping(uint256 projectId => JBAccountingContext[]) internal _accountingContextsOf;\n\n    /// @notice Fees that are being held for each project.\n    /// @dev Projects can temporarily hold fees and unlock them later by adding funds to the project's balance.\n    /// @dev Held fees can be processed at any time by this terminal's owner.\n    /// @custom:param projectId The ID of the project that is holding fees.\n    /// @custom:param token The token that the fees are held in.\n    mapping(uint256 projectId => mapping(address token => JBFee[])) internal _heldFeesOf;\n\n    //*********************************************************************//\n    // ------------------------- external views -------------------------- //\n    //*********************************************************************//\n\n    /// @notice A project's accounting context for a token.\n    /// @dev See the `JBAccountingContext` struct for more information.\n    /// @param projectId The ID of the project to get token accounting context of.\n    /// @param token The token to check the accounting context of.\n    /// @return The token's accounting context for the token.\n    function accountingContextForTokenOf(\n        uint256 projectId,\n        address token\n    )\n        external\n        view\n        override\n        returns (JBAccountingContext memory)\n    {\n        return _accountingContextForTokenOf[projectId][token];\n    }\n\n    /// @notice The tokens accepted by a project.\n    /// @param projectId The ID of the project to get the accepted tokens of.\n    /// @return tokenContexts The accounting contexts of the accepted tokens.\n    function accountingContextsOf(uint256 projectId) external view override returns (JBAccountingContext[] memory) {\n        return _accountingContextsOf[projectId];\n    }\n\n    /// @notice Gets the total current surplus amount in this terminal for a project, in terms of a given currency.\n    /// @dev This total surplus only includes tokens that the project accepts (as returned by\n    /// `accountingContextsOf(...)`).\n    /// @param projectId The ID of the project to get the current total surplus of.\n    /// @param decimals The number of decimals to include in the fixed point returned value.\n    /// @param currency The currency to express the returned value in terms of.\n    /// @return The current surplus amount the project has in this terminal, in terms of `currency` and with the\n    /// specified number of decimals.\n    function currentSurplusOf(\n        uint256 projectId,\n        uint256 decimals,\n        uint256 currency\n    )\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return STORE.currentSurplusOf(address(this), projectId, _accountingContextsOf[projectId], decimals, currency);\n    }\n\n    /// @notice Fees that are being held for a project.\n    /// @dev Projects can temporarily hold fees and unlock them later by adding funds to the project's balance.\n    /// @dev Held fees can be processed at any time by this terminal's owner.\n    /// @param projectId The ID of the project that is holding fees.\n    /// @param token The token that the fees are held in.\n    function heldFeesOf(uint256 projectId, address token) external view override returns (JBFee[] memory) {\n        return _heldFeesOf[projectId][token];\n    }\n\n    //*********************************************************************//\n    // -------------------------- public views --------------------------- //\n    //*********************************************************************//\n\n    /// @notice Indicates whether this contract adheres to the specified interface.\n    /// @dev See {IERC165-supportsInterface}.\n    /// @param interfaceId The ID of the interface to check for adherence to.\n    /// @return A flag indicating if the provided interface ID is supported.\n    function supportsInterface(bytes4 interfaceId) public pure override returns (bool) {\n        return interfaceId == type(IJBMultiTerminal).interfaceId || interfaceId == type(IJBPermissioned).interfaceId\n            || interfaceId == type(IJBTerminal).interfaceId || interfaceId == type(IJBRedeemTerminal).interfaceId\n            || interfaceId == type(IJBPayoutTerminal).interfaceId || interfaceId == type(IJBPermitTerminal).interfaceId\n            || interfaceId == type(IJBMultiTerminal).interfaceId || interfaceId == type(IJBFeeTerminal).interfaceId\n            || interfaceId == type(IERC165).interfaceId;\n    }\n\n    //*********************************************************************//\n    // -------------------------- internal views ------------------------- //\n    //*********************************************************************//\n\n    /// @notice Checks this terminal's balance of a specific token.\n    /// @param token The address of the token to get this terminal's balance of.\n    /// @return This terminal's balance.\n    function _balanceOf(address token) internal view returns (uint256) {\n        // If the `token` is native, get the native token balance.\n        return token == JBConstants.NATIVE_TOKEN ? address(this).balance : IERC20(token).balanceOf(address(this));\n    }\n\n    /// @notice Returns the value that should be forwarded with transactions, determined by whether or not a token is\n    /// the native token.\n    /// @param token The token being sent.\n    /// @param amount The amount of the token being sent\n    /// @return value The value to attach to the transaction being sent.\n    function _payValueOf(address token, uint256 amount) internal pure returns (uint256) {\n        return token == JBConstants.NATIVE_TOKEN ? amount : 0;\n    }\n\n    /// @notice Returns the current controller of a project.\n    /// @param projectId The ID of the project to get the controller of.\n    /// @return controller The project's controller.\n    function _controllerOf(uint256 projectId) internal view returns (IJBController) {\n        return IJBController(address(DIRECTORY.controllerOf(projectId)));\n    }\n\n    /// @notice Returns a flag indicating if interacting with an address should not incur fees.\n    /// @param addr The address to check.\n    /// @return A flag indicating if the address should not incur fees.\n    function _isFeeless(address addr) internal view returns (bool) {\n        return FEELESS_ADDRESSES.isFeeless(addr);\n    }\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param permissions A contract storing permissions.\n    /// @param projects A contract which mints ERC-721s that represent project ownership and transfers.\n    /// @param splits A contract that stores splits for each project.\n    /// @param store A contract that stores the terminal's data.\n    /// @param feelessAddresses A contract that stores addresses that shouldn't incur fees when being paid towards or\n    /// from.\n    /// @param permit2 A permit2 utility.\n    /// @param trustedForwarder A trusted forwarder of transactions to this contract.\n    constructor(\n        IJBPermissions permissions,\n        IJBProjects projects,\n        IJBSplits splits,\n        IJBTerminalStore store,\n        IJBFeelessAddresses feelessAddresses,\n        IPermit2 permit2,\n        address trustedForwarder\n    )\n        JBPermissioned(permissions)\n        ERC2771Context(trustedForwarder)\n    {\n        PROJECTS = projects;\n        DIRECTORY = store.DIRECTORY();\n        SPLITS = splits;\n        RULESETS = store.RULESETS();\n        STORE = store;\n        FEELESS_ADDRESSES = feelessAddresses;\n        PERMIT2 = permit2;\n    }\n\n    //*********************************************************************//\n    // ---------------------- external transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice Pay a project with tokens.\n    /// @param projectId The ID of the project being paid.\n    /// @param amount The amount of terminal tokens being received, as a fixed point number with the same number of\n    /// decimals as this terminal. If this terminal's token is native, this is ignored and `msg.value` is used in its\n    /// place.\n    /// @param token The token being paid.\n    /// @param beneficiary The address to mint tokens to, and pass along to the ruleset's data hook and pay hook if\n    /// applicable.\n    /// @param minReturnedTokens The minimum number of project tokens expected in return for this payment, as a fixed\n    /// point number with the same number of decimals as this terminal. If the amount of tokens minted for the\n    /// beneficiary would be less than this amount, the payment is reverted.\n    /// @param memo A memo to pass along to the emitted event.\n    /// @param metadata Bytes to pass along to the emitted event, as well as the data hook and pay hook if applicable.\n    /// @return beneficiaryTokenCount The number of tokens minted to the beneficiary, as a fixed point number with 18\n    /// decimals.\n    function pay(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        address beneficiary,\n        uint256 minReturnedTokens,\n        string calldata memo,\n        bytes calldata metadata\n    )\n        external\n        payable\n        override\n        returns (uint256 beneficiaryTokenCount)\n    {\n        // Pay the project.\n        beneficiaryTokenCount = _pay({\n            projectId: projectId,\n            token: token,\n            amount: _acceptFundsFor(projectId, token, amount, metadata),\n            payer: _msgSender(),\n            beneficiary: beneficiary,\n            memo: memo,\n            metadata: metadata\n        });\n\n        // The token count for the beneficiary must be greater than or equal to the specified minimum.\n        if (beneficiaryTokenCount < minReturnedTokens) {\n            revert UNDER_MIN_RETURNED_TOKENS();\n        }\n    }\n\n    /// @notice Adds funds to a project's balance without minting tokens.\n    /// @dev Adding to balance can unlock held fees if `shouldUnlockHeldFees` is true.\n    /// @param projectId The ID of the project to add funds to the balance of.\n    /// @param amount The amount of tokens to add to the balance, as a fixed point number with the same number of\n    /// decimals as this terminal. If this is a native token terminal, this is ignored and `msg.value` is used instead.\n    /// @param token The token being added to the balance.\n    /// @param shouldReturnHeldFees A flag indicating if held fees should be returned based on the amount being added.\n    /// @param memo A memo to pass along to the emitted event.\n    /// @param metadata Extra data to pass along to the emitted event.\n    function addToBalanceOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        bool shouldReturnHeldFees,\n        string calldata memo,\n        bytes calldata metadata\n    )\n        external\n        payable\n        override\n    {\n        // Add to balance.\n        _addToBalanceOf({\n            projectId: projectId,\n            token: token,\n            amount: _acceptFundsFor(projectId, token, amount, metadata),\n            shouldReturnHeldFees: shouldReturnHeldFees,\n            memo: memo,\n            metadata: metadata\n        });\n    }\n\n    /// @notice Holders can redeem a project's tokens to reclaim some of that project's surplus tokens, or to trigger\n    /// rules determined by the current ruleset's data hook and redeem hook.\n    /// @dev Only a token's holder or an operator with the `REDEEM_TOKENS` permission from that holder can redeem those\n    /// tokens.\n    /// @param holder The account whose tokens are being redeemed.\n    /// @param projectId The ID of the project the project tokens belong to.\n    /// @param tokenToReclaim The token being reclaimed.\n    /// @param redeemCount The number of project tokens to redeem, as a fixed point number with 18 decimals.\n    /// @param minTokensReclaimed The minimum number of terminal tokens expected in return, as a fixed point number with\n    /// the same number of decimals as this terminal. If the amount of tokens minted for the beneficiary would be less\n    /// than this amount, the redemption is reverted.\n    /// @param beneficiary The address to send the reclaimed terminal tokens to, and to pass along to the ruleset's\n    /// data hook and redeem hook if applicable.\n    /// @param metadata Bytes to send along to the emitted event, as well as the data hook and redeem hook if\n    /// applicable.\n    /// @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point\n    /// number with 18 decimals.\n    function redeemTokensOf(\n        address holder,\n        uint256 projectId,\n        address tokenToReclaim,\n        uint256 redeemCount,\n        uint256 minTokensReclaimed,\n        address payable beneficiary,\n        bytes calldata metadata\n    )\n        external\n        override\n        returns (uint256 reclaimAmount)\n    {\n        // Enforce permissions.\n        _requirePermissionFrom({account: holder, projectId: projectId, permissionId: JBPermissionIds.REDEEM_TOKENS});\n\n        reclaimAmount = _redeemTokensOf(holder, projectId, tokenToReclaim, redeemCount, beneficiary, metadata);\n\n        // The amount being reclaimed must be at least as much as was expected.\n        if (reclaimAmount < minTokensReclaimed) revert UNDER_MIN_TOKENS_RECLAIMED();\n    }\n\n    /// @notice Sends payouts to a project's current payout split group, according to its ruleset, up to its current\n    /// payout limit.\n    /// @dev If the percentages of the splits in the project's payout split group do not add up to 100%, the remainder\n    /// is sent to the project's owner.\n    /// @dev Anyone can send payouts on a project's behalf. Projects can include a wildcard split (a split with no\n    /// `hook`, `projectId`, or `beneficiary`) to send funds to the `_msgSender()` which calls this function. This can\n    /// be used to incentivize calling this function.\n    /// @dev payouts sent to addresses which aren't feeless incur the protocol fee.\n    /// @dev Payouts a projects don't incur fees if its terminal is feeless.\n    /// @param projectId The ID of the project having its payouts sent.\n    /// @param token The token being sent.\n    /// @param amount The total number of terminal tokens to send, as a fixed point number with same number of decimals\n    /// as this terminal.\n    /// @param currency The expected currency of the payouts being sent. Must match the currency of one of the\n    /// project's current ruleset's payout limits.\n    /// @param minTokensPaidOut The minimum number of terminal tokens that the `amount` should be worth (if expressed\n    /// in terms of this terminal's currency), as a fixed point number with the same number of decimals as this\n    /// terminal. If the amount of tokens paid out would be less than this amount, the send is reverted.\n    /// @return amountPaidOut The total amount paid out.\n    function sendPayoutsOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        uint256 currency,\n        uint256 minTokensPaidOut\n    )\n        external\n        override\n        returns (uint256 amountPaidOut)\n    {\n        amountPaidOut = _sendPayoutsOf(projectId, token, amount, currency);\n\n        // The amount being paid out must be at least as much as was expected.\n        if (amountPaidOut < minTokensPaidOut) revert UNDER_MIN_TOKENS_PAID_OUT();\n    }\n\n    /// @notice Allows a project to pay out funds from its surplus up to the current surplus allowance.\n    /// @dev Only a project's owner or an operator with the `USE_ALLOWANCE` permission from that owner can use the\n    /// surplus allowance.\n    /// @dev Incurs the protocol fee unless the caller is a feeless address.\n    /// @param projectId The ID of the project to use the surplus allowance of.\n    /// @param token The token being paid out from the surplus.\n    /// @param amount The amount of terminal tokens to use from the project's current surplus allowance, as a fixed\n    /// point number with the same amount of decimals as this terminal.\n    /// @param currency The expected currency of the amount being paid out. Must match the currency of one of the\n    /// project's current ruleset's surplus allowances.\n    /// @param minTokensPaidOut The minimum number of terminal tokens that should be used from the surplus allowance\n    /// (including fees), as a fixed point number with 18 decimals. If the amount of surplus used would be less than\n    /// this amount, the transaction is reverted.\n    /// @param beneficiary The address to send the surplus funds to.\n    /// @param memo A memo to pass along to the emitted event.\n    /// @return amountPaidOut The number of tokens that were sent to the beneficiary, as a fixed point number with\n    /// the same amount of decimals as the terminal.\n    function useAllowanceOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        uint256 currency,\n        uint256 minTokensPaidOut,\n        address payable beneficiary,\n        string calldata memo\n    )\n        external\n        override\n        returns (uint256 amountPaidOut)\n    {\n        // Enforce permissions.\n        _requirePermissionFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.USE_ALLOWANCE\n        });\n\n        amountPaidOut = _useAllowanceOf(projectId, token, amount, currency, beneficiary, memo);\n\n        // The amount being withdrawn must be at least as much as was expected.\n        if (amountPaidOut < minTokensPaidOut) revert UNDER_MIN_TOKENS_PAID_OUT();\n    }\n\n    /// @notice Migrate a project's funds and operations to a new terminal that accepts the same token type.\n    /// @dev Only a project's owner or an operator with the `MIGRATE_TERMINAL` permission from that owner can migrate\n    /// the project's terminal.\n    /// @param projectId The ID of the project being migrated.\n    /// @param token The address of the token being migrated.\n    /// @param to The terminal contract being migrated to, which will receive the project's funds and operations.\n    /// @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals\n    /// as this terminal.\n    function migrateBalanceOf(\n        uint256 projectId,\n        address token,\n        IJBTerminal to\n    )\n        external\n        override\n        returns (uint256 balance)\n    {\n        // Enforce permissions.\n        _requirePermissionFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.MIGRATE_TERMINAL\n        });\n\n        // The terminal being migrated to must accept the same token as this terminal.\n        if (to.accountingContextForTokenOf(projectId, token).currency == 0) {\n            revert TERMINAL_TOKENS_INCOMPATIBLE();\n        }\n\n        // Process any held fees.\n        _processHeldFeesOf({projectId: projectId, token: token, forced: true});\n\n        // Record the migration in the store.\n        balance = STORE.recordTerminalMigration(projectId, token);\n\n        // Transfer the balance if needed.\n        if (balance != 0) {\n            // Trigger any inherited pre-transfer logic.\n            _beforeTransferTo({to: address(to), token: token, amount: balance});\n\n            // If this terminal's token is the native token, send it in `msg.value`.\n            uint256 payValue = _payValueOf(token, balance);\n\n            // Withdraw the balance to transfer to the new terminal;\n            to.addToBalanceOf{value: payValue}({\n                projectId: projectId,\n                token: token,\n                amount: balance,\n                shouldReturnHeldFees: false,\n                memo: \"\",\n                metadata: bytes(\"\")\n            });\n        }\n\n        emit MigrateTerminal(projectId, token, to, balance, _msgSender());\n    }\n\n    /// @notice Process any fees that are being held for the project.\n    /// @param projectId The ID of the project to process held fees for.\n    /// @param token The token to process held fees for.\n    function processHeldFeesOf(uint256 projectId, address token) external override {\n        _processHeldFeesOf({projectId: projectId, token: token, forced: false});\n    }\n\n    /// @notice Adds accounting contexts for a project to this terminal so the project can begin accepting the tokens in\n    /// those contexts.\n    /// @dev Only a project's owner, an operator with the `ADD_ACCOUNTING_CONTEXTS` permission from that owner, or a\n    /// project's controller can add accounting contexts for the project.\n    /// @param projectId The ID of the project having to add accounting contexts for.\n    /// @param accountingContexts The accounting contexts to add.\n    function addAccountingContextsFor(\n        uint256 projectId,\n        JBAccountingContext[] calldata accountingContexts\n    )\n        external\n        override\n    {\n        // Enforce permissions.\n        _requirePermissionAllowingOverrideFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.ADD_ACCOUNTING_CONTEXTS,\n            alsoGrantAccessIf: _msgSender() == address(_controllerOf(projectId))\n        });\n\n        // Get a reference to the project's current ruleset.\n        JBRuleset memory ruleset = RULESETS.currentOf(projectId);\n\n        // Make sure that if there's a ruleset, it allows adding accounting contexts.\n        if (ruleset.id != 0 && !ruleset.allowAddAccountingContext()) revert ADDING_ACCOUNTING_CONTEXT_NOT_ALLOWED();\n\n        // Keep a reference to the number of accounting contexts to add.\n        uint256 numberOfAccountingContexts = accountingContexts.length;\n\n        // Keep a reference to the accounting context being iterated on.\n        JBAccountingContext memory accountingContext;\n\n        // Start accepting each token.\n        for (uint256 i; i < numberOfAccountingContexts; i++) {\n            // Set the accounting context being iterated on.\n            accountingContext = accountingContexts[i];\n\n            // Get a storage reference to the currency accounting context for the token.\n            JBAccountingContext storage storedAccountingContext =\n                _accountingContextForTokenOf[projectId][accountingContext.token];\n\n            // Make sure the token accounting context isn't already set.\n            if (storedAccountingContext.token != address(0)) revert ACCOUNTING_CONTEXT_ALREADY_SET();\n\n            // Keep track of a flag indiciating if we know the provided decimals are incorrect.\n            bool knownInvalidDecimals;\n\n            // Check if the token is the native token and has the correct decimals\n            if (accountingContext.token == JBConstants.NATIVE_TOKEN && accountingContext.decimals != 18) {\n                knownInvalidDecimals = true;\n            } else if (accountingContext.token != JBConstants.NATIVE_TOKEN) {\n                try IERC165(accountingContext.token).supportsInterface(type(IERC20Metadata).interfaceId) returns (\n                    bool doesSupport\n                ) {\n                    if (doesSupport && accountingContext.decimals != IERC20Metadata(accountingContext.token).decimals())\n                    {\n                        knownInvalidDecimals = true;\n                    }\n                } catch {}\n            }\n\n            // Make sure the decimals are correct.\n            if (knownInvalidDecimals) {\n                revert INVALID_ACCOUNTING_CONTEXT_DECIMALS();\n            }\n\n            // Make sure the currency is non-zero.\n            if (accountingContext.currency == 0) revert INVALID_ACCOUNTING_CONTEXT_CURRENCY();\n\n            // Define the context from the config.\n            storedAccountingContext.token = accountingContext.token;\n            storedAccountingContext.decimals = accountingContext.decimals;\n            storedAccountingContext.currency = accountingContext.currency;\n\n            // Add the token to the list of accepted tokens of the project.\n            _accountingContextsOf[projectId].push(storedAccountingContext);\n\n            emit SetAccountingContext(projectId, storedAccountingContext, _msgSender());\n        }\n    }\n\n    /// @notice Process a specified amount of fees for a project.\n    /// @dev Only accepts calls from this terminal itself.\n    /// @param projectId The ID of the project paying the fee.\n    /// @param token The token the fee is being paid in.\n    /// @param amount The fee amount, as a fixed point number with 18 decimals.\n    /// @param beneficiary The address to mint tokens to (from the project which receives fees), and pass along to the\n    /// ruleset's data hook and pay hook if applicable.\n    /// @param feeTerminal The terminal that'll receive the fees.\n    function executeProcessFee(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        address beneficiary,\n        IJBTerminal feeTerminal\n    )\n        external\n    {\n        // NOTICE: May only be called by this terminal itself.\n        require(msg.sender == address(this));\n\n        if (address(feeTerminal) == address(0)) {\n            revert FEE_TERMINAL_NOT_FOUND();\n        }\n\n        // Trigger any inherited pre-transfer logic if funds will be transferred.\n        if (address(feeTerminal) != address(this)) {\n            _beforeTransferTo({to: address(feeTerminal), token: token, amount: amount});\n        }\n\n        // Send the projectId in the metadata.\n        bytes memory metadata = bytes(abi.encodePacked(projectId));\n\n        _efficientPay({\n            terminal: feeTerminal,\n            projectId: _FEE_BENEFICIARY_PROJECT_ID,\n            token: token,\n            amount: amount,\n            beneficiary: beneficiary,\n            metadata: metadata\n        });\n    }\n\n    /// @notice Executes a payout to a split.\n    /// @dev Only accepts calls from this terminal itself.\n    /// @param split The split to pay.\n    /// @param projectId The ID of the project the split belongs to.\n    /// @param token The address of the token being paid to the split.\n    /// @param amount The total amount being paid to the split, as a fixed point number with the same number of\n    /// decimals as this terminal.\n    /// @return netPayoutAmount The amount sent to the split after subtracting fees.\n    function executePayout(\n        JBSplit calldata split,\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        address originalMessageSender\n    )\n        external\n        returns (uint256 netPayoutAmount)\n    {\n        // NOTICE: May only be called by this terminal itself.\n        require(msg.sender == address(this));\n\n        // By default, the net payout amount is the full amount. This will be adjusted if fees are taken.\n        netPayoutAmount = amount;\n\n        // If there's a split hook set, transfer to its `process` function.\n        if (split.hook != IJBSplitHook(address(0))) {\n            // Make sure that the address supports the split hook interface.\n            if (!split.hook.supportsInterface(type(IJBSplitHook).interfaceId)) {\n                revert SPLIT_HOOK_INVALID();\n            }\n\n            // This payout is eligible for a fee since the funds are leaving this contract and the split hook isn't a\n            // feeless address.\n            if (!_isFeeless(address(split.hook))) {\n                netPayoutAmount -= JBFees.feeAmountIn(amount, FEE);\n            }\n\n            // Create the context to send to the split hook.\n            JBSplitHookContext memory context = JBSplitHookContext({\n                token: token,\n                amount: netPayoutAmount,\n                decimals: _accountingContextForTokenOf[projectId][token].decimals,\n                projectId: projectId,\n                groupId: uint256(uint160(token)),\n                split: split\n            });\n\n            // Trigger any inherited pre-transfer logic.\n            _beforeTransferTo({to: address(split.hook), token: token, amount: netPayoutAmount});\n\n            // Get a reference to the amount being paid in `msg.value`.\n            uint256 payValue = _payValueOf(token, netPayoutAmount);\n\n            // If this terminal's token is the native token, send it in `msg.value`.\n            split.hook.processSplitWith{value: payValue}(context);\n\n            // Otherwise, if a project is specified, make a payment to it.\n        } else if (split.projectId != 0) {\n            // Get a reference to the terminal being used.\n            IJBTerminal terminal = DIRECTORY.primaryTerminalOf(split.projectId, token);\n\n            // The project must have a terminal to send funds to.\n            if (terminal == IJBTerminal(address(0))) revert RECIPIENT_PROJECT_TERMINAL_NOT_FOUND();\n\n            // This payout is eligible for a fee if the funds are leaving this contract and the receiving terminal isn't\n            // a feelss address.\n            if (terminal != this && !_isFeeless(address(terminal))) {\n                netPayoutAmount -= JBFees.feeAmountIn(amount, FEE);\n            }\n\n            // Trigger any inherited pre-transfer logic.\n            if (terminal != this) _beforeTransferTo({to: address(terminal), token: token, amount: netPayoutAmount});\n\n            // Send the `projectId` in the metadata as a referral.\n            bytes memory metadata = bytes(abi.encodePacked(projectId));\n\n            // Add to balance if preferred.\n            if (split.preferAddToBalance) {\n                _efficientAddToBalance({\n                    terminal: terminal,\n                    projectId: split.projectId,\n                    token: token,\n                    amount: netPayoutAmount,\n                    metadata: metadata\n                });\n            } else {\n                // Keep a reference to the beneficiary of the payment.\n                address beneficiary = split.beneficiary != address(0) ? split.beneficiary : originalMessageSender;\n\n                _efficientPay({\n                    terminal: terminal,\n                    projectId: split.projectId,\n                    token: token,\n                    amount: netPayoutAmount,\n                    beneficiary: beneficiary,\n                    metadata: metadata\n                });\n            }\n        } else {\n            // If there's a beneficiary, send the funds directly to the beneficiary.\n            // If there isn't a beneficiary, send the funds to the  `_msgSender()`.\n            address payable recipient =\n                split.beneficiary != address(0) ? split.beneficiary : payable(originalMessageSender);\n\n            // This payout is eligible for a fee since the funds are leaving this contract and the recipient isn't a\n            // feeless address.\n            if (!_isFeeless(recipient)) {\n                netPayoutAmount -= JBFees.feeAmountIn(amount, FEE);\n            }\n\n            // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the\n            // `_msgSender()`.\n            _transferFrom({from: address(this), to: recipient, token: token, amount: netPayoutAmount});\n        }\n    }\n\n    //*********************************************************************//\n    // ---------------------- internal transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice The message's sender. Preferred to use over `msg.sender`.\n    /// @return sender The address which sent this call.\n    function _msgSender() internal view override(ERC2771Context, Context) returns (address sender) {\n        return ERC2771Context._msgSender();\n    }\n\n    /// @notice The calldata. Preferred to use over `msg.data`.\n    /// @return calldata The `msg.data` of this call.\n    function _msgData() internal view override(ERC2771Context, Context) returns (bytes calldata) {\n        return ERC2771Context._msgData();\n    }\n\n    /// @dev `ERC-2771` specifies the context as being a single address (20 bytes).\n    function _contextSuffixLength() internal view override(ERC2771Context, Context) returns (uint256) {\n        return super._contextSuffixLength();\n    }\n\n    //*********************************************************************//\n    // ---------------------- internal transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice Accepts an incoming token.\n    /// @param projectId The ID of the project that the transfer is being accepted for.\n    /// @param token The token being accepted.\n    /// @param amount The number of tokens being accepted.\n    /// @param metadata The metadata in which permit2 context is provided.\n    /// @return amount The number of tokens which have been accepted.\n    function _acceptFundsFor(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        bytes calldata metadata\n    )\n        internal\n        returns (uint256)\n    {\n        // Make sure the project has an accounting context for the token being paid.\n        if (_accountingContextForTokenOf[projectId][token].token == address(0)) {\n            revert TOKEN_NOT_ACCEPTED();\n        }\n\n        // If the terminal's token is the native token, override `amount` with `msg.value`.\n        if (token == JBConstants.NATIVE_TOKEN) return msg.value;\n\n        // If the terminal's token is not native, revert if there is a non-zero `msg.value`.\n        if (msg.value != 0) revert NO_MSG_VALUE_ALLOWED();\n\n        // Unpack the allowance to use, if any, given by the frontend.\n        (bool exists, bytes memory parsedMetadata) =\n            JBMetadataResolver.getDataFor({id: JBMetadataResolver.getId(\"permit2\"), metadata: metadata});\n\n        // Check if the metadata contains permit data.\n        if (exists) {\n            // Keep a reference to the allowance context parsed from the metadata.\n            (JBSingleAllowance memory allowance) = abi.decode(parsedMetadata, (JBSingleAllowance));\n\n            // Make sure the permit allowance is enough for this payment. If not we revert early.\n            if (allowance.amount < amount) {\n                revert PERMIT_ALLOWANCE_NOT_ENOUGH();\n            }\n\n            // Keep a reference to the permit rules.\n            IAllowanceTransfer.PermitSingle memory permitSingle = IAllowanceTransfer.PermitSingle({\n                details: IAllowanceTransfer.PermitDetails({\n                    token: token,\n                    amount: allowance.amount,\n                    expiration: allowance.expiration,\n                    nonce: allowance.nonce\n                }),\n                spender: address(this),\n                sigDeadline: allowance.sigDeadline\n            });\n\n            // Set the allowance to `spend` tokens for the user.\n            try PERMIT2.permit({owner: _msgSender(), permitSingle: permitSingle, signature: allowance.signature}) {}\n                catch (bytes memory) {}\n        }\n\n        // Get a reference to the balance before receiving tokens.\n        uint256 balanceBefore = _balanceOf(token);\n\n        // Transfer tokens to this terminal from the msg sender.\n        _transferFrom({from: _msgSender(), to: payable(address(this)), token: token, amount: amount});\n\n        // The amount should reflect the change in balance.\n        return _balanceOf(token) - balanceBefore;\n    }\n\n    /// @notice Pay a project with tokens.\n    /// @param projectId The ID of the project being paid.\n    /// @param token The address of the token which the project is being paid with.\n    /// @param amount The amount of terminal tokens being received, as a fixed point number with the same number of\n    /// decimals as this terminal. If this terminal's token is the native token, `amount` is ignored and `msg.value` is\n    /// used in its place.\n    /// @param payer The address making the payment.\n    /// @param beneficiary The address to mint tokens to, and pass along to the ruleset's data hook and pay hook if\n    /// applicable.\n    /// @param memo A memo to pass along to the emitted event.\n    /// @param metadata Bytes to send along to the emitted event, as well as the data hook and pay hook if applicable.\n    /// @return beneficiaryTokenCount The number of tokens minted and sent to the beneficiary, as a fixed point number\n    /// with 18 decimals.\n    function _pay(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        address payer,\n        address beneficiary,\n        string memory memo,\n        bytes memory metadata\n    )\n        internal\n        returns (uint256 beneficiaryTokenCount)\n    {\n        // Keep a reference to the token amount to forward to the store.\n        JBTokenAmount memory tokenAmount;\n\n        // Scoped section prevents stack too deep. `context` only used within scope.\n        {\n            // Get a reference to the token's accounting context.\n            JBAccountingContext memory context = _accountingContextForTokenOf[projectId][token];\n\n            // Bundle the amount info into a `JBTokenAmount` struct.\n            tokenAmount =\n                JBTokenAmount({token: token, decimals: context.decimals, currency: context.currency, value: amount});\n        }\n\n        // Record the payment.\n        // Keep a reference to the ruleset the payment is being made during.\n        // Keep a reference to the pay hook specifications.\n        // Keep a reference to the token count that'll be minted as a result of the payment.\n        (JBRuleset memory ruleset, uint256 tokenCount, JBPayHookSpecification[] memory hookSpecifications) = STORE\n            .recordPaymentFrom({\n            payer: payer,\n            amount: tokenAmount,\n            projectId: projectId,\n            beneficiary: beneficiary,\n            metadata: metadata\n        });\n\n        // Mint tokens if needed.\n        if (tokenCount != 0) {\n            // Set the token count to be the number of tokens minted for the beneficiary instead of the total\n            // amount.\n            beneficiaryTokenCount = _controllerOf(projectId).mintTokensOf({\n                projectId: projectId,\n                tokenCount: tokenCount,\n                beneficiary: beneficiary,\n                memo: \"\",\n                useReservedPercent: true\n            });\n        }\n\n        // If the data hook returned pay hook specifications, fulfill them.\n        if (hookSpecifications.length != 0) {\n            _fulfillPayHookSpecificationsFor(\n                projectId, hookSpecifications, tokenAmount, payer, ruleset, beneficiary, beneficiaryTokenCount, metadata\n            );\n        }\n\n        emit Pay(\n            ruleset.id,\n            ruleset.cycleNumber,\n            projectId,\n            payer,\n            beneficiary,\n            amount,\n            beneficiaryTokenCount,\n            memo,\n            metadata,\n            _msgSender()\n        );\n    }\n\n    /// @notice Adds funds to a project's balance without minting tokens.\n    /// @param projectId The ID of the project to add funds to the balance of.\n    /// @param token The address of the token being added to the project's balance.\n    /// @param amount The amount of tokens to add as a fixed point number with the same number of decimals as this\n    /// terminal. If this is a native token terminal, this is ignored and `msg.value` is used instead.\n    /// @param shouldReturnHeldFees A flag indicating if held fees should be returned based on the amount being added.\n    /// @param memo A memo to pass along to the emitted event.\n    /// @param metadata Extra data to pass along to the emitted event.\n    function _addToBalanceOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        bool shouldReturnHeldFees,\n        string memory memo,\n        bytes memory metadata\n    )\n        internal\n    {\n        // Return held fees if desired. This mechanism means projects don't pay fees multiple times when funds go out of\n        // and back into the protocol.\n        uint256 returnedFees = shouldReturnHeldFees ? _returnHeldFees(projectId, token, amount) : 0;\n\n        // Record the added funds with any returned fees.\n        STORE.recordAddedBalanceFor({projectId: projectId, token: token, amount: amount + returnedFees});\n\n        emit AddToBalance(projectId, amount, returnedFees, memo, metadata, _msgSender());\n    }\n\n    /// @notice Holders can redeem their tokens to claim some of a project's surplus, or to trigger rules determined by\n    /// the project's current ruleset's data hook.\n    /// @dev Only a token holder or a an operator with the `REDEEM_TOKENS` permission from that holder can redeem those\n    /// tokens.\n    /// @param holder The account redeeming tokens.\n    /// @param projectId The ID of the project whose tokens are being redeemed.\n    /// @param tokenToReclaim The address of the token which is being reclaimed.\n    /// @param redeemCount The number of project tokens to redeem, as a fixed point number with 18 decimals.\n    /// @param beneficiary The address to send the reclaimed terminal tokens to.\n    /// @param metadata Bytes to send along to the emitted event, as well as the data hook and redeem hook if\n    /// applicable.\n    /// @return reclaimAmount The number of terminal tokens reclaimed for the `beneficiary`, as a fixed point number\n    /// with 18 decimals.\n\n    function _redeemTokensOf(\n        address holder,\n        uint256 projectId,\n        address tokenToReclaim,\n        uint256 redeemCount,\n        address payable beneficiary,\n        bytes memory metadata\n    )\n        internal\n        returns (uint256 reclaimAmount)\n    {\n        // Keep a reference to the ruleset the redemption is being made during.\n        JBRuleset memory ruleset;\n\n        // Keep a reference to the redeem hook specifications.\n        JBRedeemHookSpecification[] memory hookSpecifications;\n\n        // Keep a reference to the redemption rate being used.\n        uint256 redemptionRate;\n\n        // Keep a reference to the accounting context of the token being reclaimed.\n        JBAccountingContext memory accountingContext = _accountingContextForTokenOf[projectId][tokenToReclaim];\n\n        // Scoped section prevents stack too deep.\n        {\n            JBAccountingContext[] memory balanceAccountingContexts = _accountingContextsOf[projectId];\n\n            // Record the redemption.\n            (ruleset, reclaimAmount, redemptionRate, hookSpecifications) = STORE.recordRedemptionFor({\n                holder: holder,\n                projectId: projectId,\n                accountingContext: accountingContext,\n                balanceAccountingContexts: balanceAccountingContexts,\n                redeemCount: redeemCount,\n                metadata: metadata\n            });\n        }\n\n        // Burn the project tokens.\n        if (redeemCount != 0) {\n            _controllerOf(projectId).burnTokensOf({\n                holder: holder,\n                projectId: projectId,\n                tokenCount: redeemCount,\n                memo: \"\"\n            });\n        }\n\n        // Keep a reference to the amount being reclaimed that is subject to fees.\n        uint256 amountEligibleForFees;\n\n        // Send the reclaimed funds to the beneficiary.\n        if (reclaimAmount != 0) {\n            // Determine if a fee should be taken. Fees are not exercised if the redemption rate is at its max (100%),\n            // if the beneficiary is feeless, or if the fee beneficiary doesn't accept the given token.\n            if (!_isFeeless(beneficiary) && redemptionRate != JBConstants.MAX_REDEMPTION_RATE) {\n                amountEligibleForFees += reclaimAmount;\n                // Subtract the fee for the reclaimed amount.\n                reclaimAmount -= JBFees.feeAmountIn(reclaimAmount, FEE);\n            }\n\n            // Subtract the fee from the reclaim amount.\n            if (reclaimAmount != 0) {\n                _transferFrom({from: address(this), to: beneficiary, token: tokenToReclaim, amount: reclaimAmount});\n            }\n        }\n\n        // If the data hook returned redeem hook specifications, fulfill them.\n        if (hookSpecifications.length != 0) {\n            // Fulfill the redeem hook specifications.\n            amountEligibleForFees += _fulfillRedeemHookSpecificationsFor({\n                projectId: projectId,\n                holder: holder,\n                redeemCount: redeemCount,\n                ruleset: ruleset,\n                redemptionRate: redemptionRate,\n                beneficiary: beneficiary,\n                beneficiaryReclaimAmount: JBTokenAmount({\n                    token: tokenToReclaim,\n                    decimals: accountingContext.decimals,\n                    currency: accountingContext.currency,\n                    value: reclaimAmount\n                }),\n                specifications: hookSpecifications,\n                metadata: metadata\n            });\n        }\n\n        // Take the fee from all outbound reclaimings.\n        amountEligibleForFees != 0\n            ? _takeFeeFrom({\n                projectId: projectId,\n                token: tokenToReclaim,\n                amount: amountEligibleForFees,\n                beneficiary: beneficiary,\n                shouldHoldFees: false\n            })\n            : 0;\n\n        emit RedeemTokens(\n            ruleset.id,\n            ruleset.cycleNumber,\n            projectId,\n            holder,\n            beneficiary,\n            redeemCount,\n            redemptionRate,\n            reclaimAmount,\n            metadata,\n            _msgSender()\n        );\n    }\n\n    /// @notice Sends payouts to a project's current payout split group, according to its ruleset, up to its current\n    /// payout limit.\n    /// @dev If the percentages of the splits in the project's payout split group do not add up to 100%, the remainder\n    /// is sent to the project's owner.\n    /// @dev Anyone can send payouts on a project's behalf. Projects can include a wildcard split (a split with no\n    /// `hook`, `projectId`, or `beneficiary`) to send funds to the `_msgSender()` which calls this function. This can\n    /// be used to incentivize calling this function.\n    /// @dev Payouts sent to addresses which aren't feeless incur the protocol fee.\n    /// @param projectId The ID of the project to send the payouts of.\n    /// @param token The token being paid out.\n    /// @param amount The number of terminal tokens to pay out, as a fixed point number with same number of decimals as\n    /// this terminal.\n    /// @param currency The expected currency of the amount being paid out. Must match the currency of one of the\n    /// project's current ruleset's payout limits.\n    /// @return amountPaidOut The total amount that was paid out.\n    function _sendPayoutsOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        uint256 currency\n    )\n        internal\n        returns (uint256 amountPaidOut)\n    {\n        // Keep a reference to the ruleset.\n        JBRuleset memory ruleset;\n\n        // Record the payout.\n        (ruleset, amountPaidOut) = STORE.recordPayoutFor({\n            projectId: projectId,\n            accountingContext: _accountingContextForTokenOf[projectId][token],\n            amount: amount,\n            currency: currency\n        });\n\n        // If the ruleset requires privileged payout distribution, ensure the caller has the permission.\n        if (ruleset.ownerMustSendPayouts()) {\n            // Enforce permissions.\n            _requirePermissionFrom({\n                account: PROJECTS.ownerOf(projectId),\n                projectId: projectId,\n                permissionId: JBPermissionIds.SEND_PAYOUTS\n            });\n        }\n\n        // Get a reference to the project's owner.\n        // The owner will receive tokens minted by paying the platform fee and receive any leftover funds not sent to\n        // payout splits.\n        address payable projectOwner = payable(PROJECTS.ownerOf(projectId));\n\n        // Send payouts to the splits and get a reference to the amount left over after the splits have been paid.\n        // Also get a reference to the amount which was paid out to splits that is eligible for fees.\n        (uint256 leftoverPayoutAmount, uint256 amountEligibleForFees) =\n            _sendPayoutsToSplitGroupOf(projectId, token, ruleset.id, amountPaidOut);\n\n        // Take the fee.\n        uint256 feeTaken = _takeFeeFrom({\n            projectId: projectId,\n            token: token,\n            amount: amountEligibleForFees + leftoverPayoutAmount,\n            beneficiary: projectOwner,\n            shouldHoldFees: ruleset.holdFees()\n        });\n\n        /// The leftover amount that was sent to the project owner.\n        uint256 netLeftoverPayoutAmount;\n\n        // Send any leftover funds to the project owner and update the net leftover (which is returned) accordingly.\n        if (leftoverPayoutAmount != 0) {\n            // Subtract the fee from the net leftover amount.\n            netLeftoverPayoutAmount = leftoverPayoutAmount - JBFees.feeAmountIn(leftoverPayoutAmount, FEE);\n\n            // Transfer the amount to the project owner.\n            _transferFrom({from: address(this), to: projectOwner, token: token, amount: netLeftoverPayoutAmount});\n        }\n\n        emit SendPayouts(\n            ruleset.id,\n            ruleset.cycleNumber,\n            projectId,\n            projectOwner,\n            amount,\n            amountPaidOut,\n            feeTaken,\n            netLeftoverPayoutAmount,\n            _msgSender()\n        );\n    }\n\n    /// @notice Allows a project to send out funds from its surplus up to the current surplus allowance.\n    /// @dev Only a project's owner or an operator with the `USE_ALLOWANCE` permission from that owner can use the\n    /// surplus allowance.\n    /// @dev Incurs the protocol fee unless the caller is a feeless address.\n    /// @param projectId The ID of the project to use the surplus allowance of.\n    /// @param token The token being paid out from the surplus.\n    /// @param amount The amount of terminal tokens to use from the project's current surplus allowance, as a fixed\n    /// point number with the same amount of decimals as this terminal.\n    /// @param currency The expected currency of the amount being paid out. Must match the currency of one of the\n    /// project's current ruleset's surplus allowances.\n    /// @param beneficiary The address to send the funds to.\n    /// @param memo A memo to pass along to the emitted event.\n    /// @return amountPaidOut The amount of tokens paid out.\n    function _useAllowanceOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        uint256 currency,\n        address payable beneficiary,\n        string memory memo\n    )\n        internal\n        returns (uint256 amountPaidOut)\n    {\n        // Keep a reference to the ruleset.\n        JBRuleset memory ruleset;\n\n        // Record the use of the allowance.\n        (ruleset, amountPaidOut) = STORE.recordUsedAllowanceOf({\n            projectId: projectId,\n            accountingContext: _accountingContextForTokenOf[projectId][token],\n            amount: amount,\n            currency: currency\n        });\n\n        // Take a fee from the `amountPaidOut`, if needed.\n        // The net amount is the final amount withdrawn after the fee has been taken.\n        uint256 netAmountPaidOut = amountPaidOut\n            - (\n                _isFeeless(_msgSender())\n                    ? 0\n                    : _takeFeeFrom({\n                        projectId: projectId,\n                        token: token,\n                        amount: amountPaidOut,\n                        // The project owner will receive tokens minted by paying the platform fee.\n                        beneficiary: PROJECTS.ownerOf(projectId),\n                        shouldHoldFees: ruleset.holdFees()\n                    })\n            );\n\n        // Transfer any remaining balance to the beneficiary.\n        if (netAmountPaidOut != 0) {\n            _transferFrom({from: address(this), to: beneficiary, token: token, amount: netAmountPaidOut});\n        }\n\n        emit UseAllowance(\n            ruleset.id,\n            ruleset.cycleNumber,\n            projectId,\n            beneficiary,\n            amount,\n            amountPaidOut,\n            netAmountPaidOut,\n            memo,\n            _msgSender()\n        );\n    }\n\n    /// @notice Sends payouts to the payout splits group specified in a project's ruleset.\n    /// @param projectId The ID of the project to send the payouts of.\n    /// @param token The address of the token being paid out.\n    /// @param rulesetId The ID of the ruleset of the split group being paid.\n    /// @param amount The total amount being paid out, as a fixed point number with the same number of decimals as this\n    /// terminal.\n    /// @return amount The leftover amount (zero if the splits add up to 100%).\n    /// @return amountEligibleForFees The total amount of funds which were paid out and are eligible for fees.\n    function _sendPayoutsToSplitGroupOf(\n        uint256 projectId,\n        address token,\n        uint256 rulesetId,\n        uint256 amount\n    )\n        internal\n        returns (uint256, uint256 amountEligibleForFees)\n    {\n        // The total percentage available to split\n        uint256 leftoverPercentage = JBConstants.SPLITS_TOTAL_PERCENT;\n\n        // Get a reference to the project's payout splits.\n        JBSplit[] memory splits =\n            SPLITS.splitsOf({projectId: projectId, rulesetId: rulesetId, groupId: uint256(uint160(token))});\n\n        // Keep a reference to the number of splits being iterated on.\n        uint256 numberOfSplits = splits.length;\n\n        // Keep a reference to the split being iterated on.\n        JBSplit memory split;\n\n        // Transfer between all splits.\n        for (uint256 i; i < numberOfSplits; i++) {\n            // Get a reference to the split being iterated on.\n            split = splits[i];\n\n            // The amount to send to the split.\n            uint256 payoutAmount = mulDiv(amount, split.percent, leftoverPercentage);\n\n            // The final payout amount after taking out any fees.\n            uint256 netPayoutAmount = _sendPayoutToSplit(split, projectId, token, payoutAmount);\n\n            // If the split hook is a feeless address, this payout doesn't incur a fee.\n            if (netPayoutAmount != 0 && netPayoutAmount != payoutAmount) {\n                amountEligibleForFees += payoutAmount;\n            }\n\n            if (payoutAmount != 0) {\n                // Subtract from the amount to be sent to the beneficiary.\n                unchecked {\n                    amount -= payoutAmount;\n                }\n            }\n\n            unchecked {\n                // Decrement the leftover percentage.\n                leftoverPercentage -= split.percent;\n            }\n\n            emit SendPayoutToSplit(\n                projectId, rulesetId, uint256(uint160(token)), split, payoutAmount, netPayoutAmount, _msgSender()\n            );\n        }\n\n        return (amount, amountEligibleForFees);\n    }\n\n    /// @notice Sends a payout to a split.\n    /// @param split The split to pay.\n    /// @param projectId The ID of the project the split was specified by.\n    /// @param token The address of the token being paid out.\n    /// @param amount The total amount that the split is being paid, as a fixed point number with the same number of\n    /// decimals as this terminal.\n    /// @return netPayoutAmount The amount sent to the split after subtracting fees.\n    function _sendPayoutToSplit(\n        JBSplit memory split,\n        uint256 projectId,\n        address token,\n        uint256 amount\n    )\n        internal\n        returns (uint256)\n    {\n        // Attempt to distribute this split.\n        try this.executePayout(split, projectId, token, amount, _msgSender()) returns (uint256 netPayoutAmount) {\n            return netPayoutAmount;\n        } catch (bytes memory failureReason) {\n            // Add balance back to the project.\n            STORE.recordAddedBalanceFor(projectId, token, amount);\n            // Emit event.\n            emit PayoutReverted(projectId, split, amount, failureReason, _msgSender());\n            // Since the payout failed the netPayoutAmount is zero.\n            return 0;\n        }\n    }\n\n    /// @notice Fulfills a list of pay hook specifications.\n    /// @param projectId The ID of the project being paid.\n    /// @param specifications The pay hook specifications to be fulfilled.\n    /// @param tokenAmount The amount of tokens that the project was paid.\n    /// @param payer The address that sent the payment.\n    /// @param ruleset The ruleset the payment is being accepted during.\n    /// @param beneficiary The address which will receive any tokens that the payment yields.\n    /// @param beneficiaryTokenCount The amount of tokens that are being minted and sent to the beneificary.\n    /// @param metadata Bytes to send along to the emitted event and pay hooks as applicable.\n    function _fulfillPayHookSpecificationsFor(\n        uint256 projectId,\n        JBPayHookSpecification[] memory specifications,\n        JBTokenAmount memory tokenAmount,\n        address payer,\n        JBRuleset memory ruleset,\n        address beneficiary,\n        uint256 beneficiaryTokenCount,\n        bytes memory metadata\n    )\n        internal\n    {\n        // Keep a reference to payment context for the pay hooks.\n        JBAfterPayRecordedContext memory context = JBAfterPayRecordedContext({\n            payer: payer,\n            projectId: projectId,\n            rulesetId: ruleset.id,\n            amount: tokenAmount,\n            forwardedAmount: tokenAmount,\n            weight: ruleset.weight,\n            projectTokenCount: beneficiaryTokenCount,\n            beneficiary: beneficiary,\n            hookMetadata: bytes(\"\"),\n            payerMetadata: metadata\n        });\n\n        // Keep a reference to the number of pay hook specifications to iterate through.\n        uint256 numberOfSpecifications = specifications.length;\n\n        // Keep a reference to the specification being iterated on.\n        JBPayHookSpecification memory specification;\n\n        // Fulfill each specification through their pay hooks.\n        for (uint256 i; i < numberOfSpecifications; i++) {\n            // Set the specification being iterated on.\n            specification = specifications[i];\n\n            // Pass the correct token `forwardedAmount` to the hook.\n            context.forwardedAmount = JBTokenAmount({\n                value: specification.amount,\n                token: tokenAmount.token,\n                decimals: tokenAmount.decimals,\n                currency: tokenAmount.currency\n            });\n\n            // Pass the correct metadata from the data hook's specification.\n            context.hookMetadata = specification.metadata;\n\n            // Trigger any inherited pre-transfer logic.\n            _beforeTransferTo({to: address(specification.hook), token: tokenAmount.token, amount: specification.amount});\n\n            // Keep a reference to the amount that'll be paid as a `msg.value`.\n            uint256 payValue = _payValueOf(tokenAmount.token, specification.amount);\n\n            // Fulfill the specification.\n            specification.hook.afterPayRecordedWith{value: payValue}(context);\n\n            emit HookAfterRecordPay(specification.hook, context, specification.amount, _msgSender());\n        }\n    }\n\n    /// @notice Fulfills a list of redeem hook specification.\n    /// @param projectId The ID of the project being redeemed from.\n    /// @param beneficiaryReclaimAmount The number of tokens that are being reclaimed from the project.\n    /// @param holder The address that holds the tokens being redeemed.\n    /// @param redeemCount The number of tokens being redeemed.\n    /// @param metadata Bytes to send along to the emitted event and redeem hooks as applicable.\n    /// @param ruleset The ruleset the redemption is being made during as a `JBRuleset` struct.\n    /// @param redemptionRate The redemption rate influencing the reclaim amount.\n    /// @param beneficiary The address which will receive any terminal tokens that are reclaimed by this redemption.\n    /// @param specifications The hook specifications being fulfilled.\n    /// @return amountEligibleForFees The amount of funds which were allocated to redeem hooks and are eligible for\n    /// fees.\n    function _fulfillRedeemHookSpecificationsFor(\n        uint256 projectId,\n        JBTokenAmount memory beneficiaryReclaimAmount,\n        address holder,\n        uint256 redeemCount,\n        bytes memory metadata,\n        JBRuleset memory ruleset,\n        uint256 redemptionRate,\n        address payable beneficiary,\n        JBRedeemHookSpecification[] memory specifications\n    )\n        internal\n        returns (uint256 amountEligibleForFees)\n    {\n        // Keep a reference to redemption context for the redeem hooks.\n        JBAfterRedeemRecordedContext memory context = JBAfterRedeemRecordedContext({\n            holder: holder,\n            projectId: projectId,\n            rulesetId: ruleset.id,\n            redeemCount: redeemCount,\n            reclaimedAmount: beneficiaryReclaimAmount,\n            forwardedAmount: beneficiaryReclaimAmount,\n            redemptionRate: redemptionRate,\n            beneficiary: beneficiary,\n            hookMetadata: \"\",\n            redeemerMetadata: metadata\n        });\n\n        // Keep a reference to the number of redeem hook specifications being iterated through.\n        uint256 numberOfSpecifications = specifications.length;\n\n        // Keep a reference to the specification being iterated on.\n        JBRedeemHookSpecification memory specification;\n\n        for (uint256 i; i < numberOfSpecifications; i++) {\n            // Set the specification being iterated on.\n            specification = specifications[i];\n\n            // Get the fee for the specified amount.\n            uint256 specificationAmountFee =\n                _isFeeless(address(specification.hook)) ? 0 : JBFees.feeAmountIn(specification.amount, FEE);\n\n            // Add the specification's amount to the amount eligible for fees.\n            if (specificationAmountFee != 0) {\n                amountEligibleForFees += specification.amount;\n                specification.amount -= specificationAmountFee;\n            }\n\n            // Pass the correct token `forwardedAmount` to the hook.\n            context.forwardedAmount = JBTokenAmount({\n                value: specification.amount,\n                token: beneficiaryReclaimAmount.token,\n                decimals: beneficiaryReclaimAmount.decimals,\n                currency: beneficiaryReclaimAmount.currency\n            });\n\n            // Pass the correct metadata from the data hook's specification.\n            context.hookMetadata = specification.metadata;\n\n            // Trigger any inherited pre-transfer logic.\n            _beforeTransferTo({\n                to: address(specification.hook),\n                token: beneficiaryReclaimAmount.token,\n                amount: specification.amount\n            });\n\n            // Keep a reference to the amount that'll be paid as a `msg.value`.\n            uint256 payValue = _payValueOf(beneficiaryReclaimAmount.token, specification.amount);\n\n            // Fulfill the specification.\n            specification.hook.afterRedeemRecordedWith{value: payValue}(context);\n\n            emit HookAfterRecordRedeem(\n                specification.hook, context, specification.amount, specificationAmountFee, _msgSender()\n            );\n        }\n    }\n\n    /// @notice Takes a fee into the platform's project (with the `_FEE_BENEFICIARY_PROJECT_ID`).\n    /// @param projectId The ID of the project paying the fee.\n    /// @param token The address of the token that the fee is being paid in.\n    /// @param amount The fee's token amount, as a fixed point number with 18 decimals.\n    /// @param beneficiary The address to mint the platform's project's tokens for.\n    /// @param shouldHoldFees If fees should be tracked and held instead of being exercised immediately.\n    /// @return feeAmount The amount of the fee taken.\n    function _takeFeeFrom(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        address beneficiary,\n        bool shouldHoldFees\n    )\n        internal\n        returns (uint256 feeAmount)\n    {\n        // Get a reference to the fee amount.\n        feeAmount = JBFees.feeAmountIn(amount, FEE);\n\n        if (shouldHoldFees) {\n            // Store the held fee.\n            _heldFeesOf[projectId][token].push(\n                JBFee({\n                    amount: amount,\n                    beneficiary: beneficiary,\n                    unlockTimestamp: uint48(block.timestamp + _FEE_HOLDING_SECONDS)\n                })\n            );\n\n            emit HoldFee(projectId, token, amount, FEE, beneficiary, _msgSender());\n        } else {\n            // Get the terminal that'll receive the fee if one wasn't provided.\n            IJBTerminal feeTerminal = DIRECTORY.primaryTerminalOf(_FEE_BENEFICIARY_PROJECT_ID, token);\n\n            // Process the fee.\n            _processFee({\n                projectId: projectId,\n                token: token,\n                amount: feeAmount,\n                beneficiary: beneficiary,\n                feeTerminal: feeTerminal,\n                wasHeld: false\n            });\n        }\n    }\n\n    /// @notice Process any fees that are being held for the project.\n    /// @param projectId The ID of the project to process held fees for.\n    /// @param token The token to process held fees for.\n    /// @param forced If locked held fees should be force processed.\n    function _processHeldFeesOf(uint256 projectId, address token, bool forced) internal {\n        // Get a reference to the project's held fees.\n        JBFee[] memory heldFees = _heldFeesOf[projectId][token];\n\n        // Delete the held fees.\n        delete _heldFeesOf[projectId][token];\n\n        // Keep a reference to the number of held fees.\n        uint256 numberOfHeldFees = heldFees.length;\n\n        // Keep a reference to the fee being iterated on.\n        JBFee memory heldFee;\n\n        // Keep a reference to the terminal that'll receive the fees.\n        IJBTerminal feeTerminal = DIRECTORY.primaryTerminalOf(_FEE_BENEFICIARY_PROJECT_ID, token);\n\n        // Process each fee.\n        for (uint256 i; i < numberOfHeldFees; i++) {\n            // Keep a reference to the held fee being iterated on.\n            heldFee = heldFees[i];\n\n            // Can't process fees that aren't yet unlocked.\n            if (!forced && heldFee.unlockTimestamp > block.timestamp) {\n                // Add the fee back to storage.\n                _heldFeesOf[projectId][token].push(heldFee);\n                continue;\n            }\n\n            // Process the fee.\n            _processFee({\n                projectId: projectId,\n                token: token,\n                amount: heldFee.amount,\n                beneficiary: heldFee.beneficiary,\n                feeTerminal: feeTerminal,\n                wasHeld: true\n            });\n        }\n    }\n\n    /// @notice Process a fee of the specified amount from a project.\n    /// @param projectId The ID of the project paying the fee.\n    /// @param token The token the fee is being paid in.\n    /// @param amount The fee amount, as a fixed point number with 18 decimals.\n    /// @param beneficiary The address which will receive any platform tokens minted.\n    /// @param feeTerminal The terminal that'll receive the fee.\n    /// @param wasHeld A flag indicating if the fee being processed was being held by this terminal.\n    function _processFee(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        address beneficiary,\n        IJBTerminal feeTerminal,\n        bool wasHeld\n    )\n        internal\n    {\n        // slither-disable-start reentrancy-no-eth\n        try this.executeProcessFee(projectId, token, amount, beneficiary, feeTerminal) {\n            emit ProcessFee(projectId, token, amount, wasHeld, beneficiary, _msgSender());\n        } catch (bytes memory reason) {\n            STORE.recordAddedBalanceFor(projectId, token, amount);\n\n            emit FeeReverted(projectId, token, _FEE_BENEFICIARY_PROJECT_ID, amount, reason, _msgSender());\n        }\n        // slither-disable-end reentrancy-no-eth\n    }\n\n    /// @notice Returns held fees to the project who paid them based on the specified amount.\n    /// @param projectId The project held fees are being returned to.\n    /// @param token The token that the held fees are in.\n    /// @param amount The amount to base the calculation on, as a fixed point number with the same number of decimals\n    /// as this terminal.\n    /// @return returnedFees The amount of held fees that were returned, as a fixed point number with the same number of\n    /// decimals as this terminal\n    function _returnHeldFees(\n        uint256 projectId,\n        address token,\n        uint256 amount\n    )\n        internal\n        returns (uint256 returnedFees)\n    {\n        // Get a reference to the project's held fees.\n        JBFee[] memory heldFees = _heldFeesOf[projectId][token];\n\n        // Delete the current held fees.\n        delete _heldFeesOf[projectId][token];\n\n        // Get a reference to the leftover amount once all fees have been settled.\n        uint256 leftoverAmount = amount;\n\n        // Keep a reference to the number of held fees.\n        uint256 numberOfHeldFees = heldFees.length;\n\n        // Keep a reference to the fee being iterated on.\n        JBFee memory heldFee;\n\n        // Process each fee.\n        for (uint256 i; i < numberOfHeldFees; i++) {\n            // Save the fee being iterated on.\n            heldFee = heldFees[i];\n\n            // slither-disable-next-line incorrect-equality\n            if (leftoverAmount == 0) {\n                _heldFeesOf[projectId][token].push(heldFee);\n            } else {\n                // Notice here we take `feeAmountIn` on the stored `.amount`.\n                uint256 feeAmount = JBFees.feeAmountIn(heldFee.amount, FEE);\n\n                // Keep a reference to the amount from which the fee was taken.\n                uint256 amountFromFee = heldFee.amount - feeAmount;\n\n                if (leftoverAmount >= amountFromFee) {\n                    unchecked {\n                        leftoverAmount = leftoverAmount - amountFromFee;\n                        returnedFees += feeAmount;\n                    }\n                } else {\n                    // And here we overwrite with `feeAmountFrom` the `leftoverAmount`\n                    feeAmount = JBFees.feeAmountFrom(leftoverAmount, FEE);\n\n                    unchecked {\n                        _heldFeesOf[projectId][token].push(\n                            JBFee({\n                                amount: amountFromFee - leftoverAmount,\n                                beneficiary: heldFee.beneficiary,\n                                unlockTimestamp: heldFee.unlockTimestamp\n                            })\n                        );\n                        returnedFees += feeAmount;\n                    }\n                    leftoverAmount = 0;\n                }\n            }\n        }\n\n        emit ReturnHeldFees(projectId, token, amount, returnedFees, leftoverAmount, _msgSender());\n    }\n\n    /// @notice Fund a project either by calling this terminal's internal `addToBalance` function or by calling the\n    /// recipient\n    /// terminal's `addToBalance` function.\n    /// @param terminal The terminal on which the project is expecting to receive funds.\n    /// @param projectId The ID of the project being funded.\n    /// @param token The token being used.\n    /// @param amount The amount being funded, as a fixed point number with the amount of decimals that the terminal's\n    /// accounting context specifies.\n    /// @param metadata Additional metadata to include with the payment.\n    function _efficientAddToBalance(\n        IJBTerminal terminal,\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        bytes memory metadata\n    )\n        internal\n    {\n        // Call the internal method if this terminal is being used.\n        if (terminal == IJBTerminal(address(this))) {\n            _addToBalanceOf({\n                projectId: projectId,\n                token: token,\n                amount: amount,\n                shouldReturnHeldFees: false,\n                memo: \"\",\n                metadata: metadata\n            });\n        } else {\n            // Get a reference to the amount being added to balance through `msg.value`.\n            uint256 payValue = _payValueOf(token, amount);\n\n            // Add to balance.\n            // If this terminal's token is the native token, send it in `msg.value`.\n            terminal.addToBalanceOf{value: payValue}({\n                projectId: projectId,\n                token: token,\n                amount: amount,\n                shouldReturnHeldFees: false,\n                memo: \"\",\n                metadata: metadata\n            });\n        }\n    }\n\n    /// @notice Pay a project either by calling this terminal's internal `pay` function or by calling the recipient\n    /// terminal's `pay` function.\n    /// @param terminal The terminal on which the project is expecting to receive payments.\n    /// @param projectId The ID of the project being paid.\n    /// @param token The token being paid in.\n    /// @param amount The amount being paid, as a fixed point number with the amount of decimals that the terminal's\n    /// accounting context specifies.\n    /// @param beneficiary The address to receive any platform tokens minted.\n    /// @param metadata Additional metadata to include with the payment.\n    function _efficientPay(\n        IJBTerminal terminal,\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        address beneficiary,\n        bytes memory metadata\n    )\n        internal\n    {\n        if (terminal == IJBTerminal(address(this))) {\n            _pay({\n                projectId: projectId,\n                token: token,\n                amount: amount,\n                payer: address(this),\n                beneficiary: beneficiary,\n                memo: \"\",\n                metadata: metadata\n            });\n        } else {\n            // Keep a reference to the amount that'll be paid in.\n            uint256 payValue = _payValueOf(token, amount);\n\n            // Send the fee.\n            // If this terminal's token is ETH, send it in msg.value.\n            // slither-disable-next-line unused-return\n            terminal.pay{value: payValue}({\n                projectId: projectId,\n                token: token,\n                amount: amount,\n                beneficiary: beneficiary,\n                minReturnedTokens: 0,\n                memo: \"\",\n                metadata: metadata\n            });\n        }\n    }\n\n    /// @notice Transfers tokens.\n    /// @param from The address the transfer should originate from.\n    /// @param to The address the transfer should go to.\n    /// @param token The token being transfered.\n    /// @param amount The number of tokens being transferred, as a fixed point number with the same number of decimals\n    /// as this terminal.\n    function _transferFrom(address from, address payable to, address token, uint256 amount) internal {\n        // If the token is the native token, transfer natively.\n        if (token == JBConstants.NATIVE_TOKEN) return Address.sendValue(to, amount);\n\n        if (from == address(this)) return IERC20(token).safeTransfer(to, amount);\n\n        // If there's sufficient approval, transfer normally.\n        if (IERC20(token).allowance(address(from), address(this)) >= amount) {\n            return IERC20(token).safeTransferFrom(from, to, amount);\n        }\n\n        // Make sure the amount being paid is less than the maximum permit2 allowance.\n        if (amount > type(uint160).max) revert OVERFLOW_ALERT();\n\n        // Otherwise we attempt to use the PERMIT2 method.\n        PERMIT2.transferFrom(from, to, uint160(amount), token);\n    }\n\n    /// @notice Logic to be triggered before transferring tokens from this terminal.\n    /// @param to The address the transfer is going to.\n    /// @param token The token being transferred.\n    /// @param amount The number of tokens being transferred, as a fixed point number with the same number of decimals\n    /// as this terminal.\n    function _beforeTransferTo(address to, address token, uint256 amount) internal {\n        // If the token is the native token, no allowance needed.\n        if (token == JBConstants.NATIVE_TOKEN) return;\n        IERC20(token).safeIncreaseAllowance(to, amount);\n    }\n}\n"
			},
			"src/interfaces/IJBFeeTerminal.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBFee} from \"../structs/JBFee.sol\";\nimport {IJBFeelessAddresses} from \"./IJBFeelessAddresses.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\n\n/// @notice A terminal that can process and hold fees.\ninterface IJBFeeTerminal is IJBTerminal {\n    event HoldFee(\n        uint256 indexed projectId,\n        address indexed token,\n        uint256 indexed amount,\n        uint256 fee,\n        address beneficiary,\n        address caller\n    );\n\n    event ProcessFee(\n        uint256 indexed projectId,\n        address indexed token,\n        uint256 indexed amount,\n        bool wasHeld,\n        address beneficiary,\n        address caller\n    );\n\n    event ReturnHeldFees(\n        uint256 indexed projectId,\n        address indexed token,\n        uint256 indexed amount,\n        uint256 returnedFees,\n        uint256 leftoverAmount,\n        address caller\n    );\n\n    event FeeReverted(\n        uint256 indexed projectId,\n        address indexed token,\n        uint256 indexed feeProjectId,\n        uint256 amount,\n        bytes reason,\n        address caller\n    );\n\n    function FEE() external view returns (uint256);\n\n    function FEELESS_ADDRESSES() external view returns (IJBFeelessAddresses);\n\n    function heldFeesOf(uint256 projectId, address token) external view returns (JBFee[] memory);\n\n    function processHeldFeesOf(uint256 projectId, address token) external;\n\n    function executeProcessFee(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        address beneficiary,\n        IJBTerminal feeTerminal\n    )\n        external;\n}\n"
			},
			"src/interfaces/IJBFeelessAddresses.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBFeelessAddresses {\n    event SetFeelessAddress(address indexed account, bool indexed isFeeless, address caller);\n\n    function isFeeless(address account) external view returns (bool);\n\n    function setFeelessAddress(address account, bool flag) external;\n}\n"
			},
			"src/interfaces/IJBMultiTerminal.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBDirectory} from \"./IJBDirectory.sol\";\nimport {IJBFeeTerminal} from \"./IJBFeeTerminal.sol\";\nimport {IJBPayoutTerminal} from \"./IJBPayoutTerminal.sol\";\nimport {IJBPermitTerminal} from \"./IJBPermitTerminal.sol\";\nimport {IJBProjects} from \"./IJBProjects.sol\";\nimport {IJBRedeemTerminal} from \"./IJBRedeemTerminal.sol\";\nimport {IJBRulesets} from \"./IJBRulesets.sol\";\nimport {IJBSplits} from \"./IJBSplits.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\nimport {IJBTerminalStore} from \"./IJBTerminalStore.sol\";\n\ninterface IJBMultiTerminal is IJBTerminal, IJBFeeTerminal, IJBRedeemTerminal, IJBPayoutTerminal, IJBPermitTerminal {\n    function STORE() external view returns (IJBTerminalStore);\n\n    function PROJECTS() external view returns (IJBProjects);\n\n    function DIRECTORY() external view returns (IJBDirectory);\n\n    function SPLITS() external view returns (IJBSplits);\n\n    function RULESETS() external view returns (IJBRulesets);\n}\n"
			},
			"src/interfaces/IJBPayoutTerminal.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBSplit} from \"../structs/JBSplit.sol\";\nimport {IJBSplits} from \"./IJBSplits.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\n\n/// @notice A terminal that can send payouts.\ninterface IJBPayoutTerminal is IJBTerminal {\n    event SendPayouts(\n        uint256 indexed rulesetId,\n        uint256 indexed rulesetCycleNumber,\n        uint256 indexed projectId,\n        address beneficiary,\n        uint256 amount,\n        uint256 amountPaidOut,\n        uint256 fee,\n        uint256 beneficiaryDistributionAmount,\n        address caller\n    );\n\n    event SendPayoutToSplit(\n        uint256 indexed projectId,\n        uint256 indexed rulesetId,\n        uint256 indexed group,\n        JBSplit split,\n        uint256 amount,\n        uint256 netAmount,\n        address caller\n    );\n\n    event UseAllowance(\n        uint256 indexed rulesetId,\n        uint256 indexed rulesetCycleNumber,\n        uint256 indexed projectId,\n        address beneficiary,\n        uint256 amount,\n        uint256 amountPaidOut,\n        uint256 netAmountPaidOut,\n        string memo,\n        address caller\n    );\n\n    event PayoutReverted(uint256 indexed projectId, JBSplit split, uint256 amount, bytes reason, address caller);\n\n    /// @notice Only callable by itself, included for testing.\n    function executePayout(\n        JBSplit calldata split,\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        address originalMessageSender\n    )\n        external\n        returns (uint256 netPayoutAmount);\n\n    function sendPayoutsOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        uint256 currency,\n        uint256 minTokensPaidOut\n    )\n        external\n        returns (uint256 netLeftoverPayoutAmount);\n\n    function useAllowanceOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        uint256 currency,\n        uint256 minTokensPaidOut,\n        address payable beneficiary,\n        string calldata memo\n    )\n        external\n        returns (uint256 netAmountPaidOut);\n}\n"
			},
			"src/interfaces/IJBPermitTerminal.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IPermit2} from \"@uniswap/permit2/src/interfaces/IPermit2.sol\";\n\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\n\ninterface IJBPermitTerminal is IJBTerminal {\n    function PERMIT2() external returns (IPermit2);\n}\n"
			},
			"src/interfaces/IJBRedeemTerminal.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBAfterRedeemRecordedContext} from \"../structs/JBAfterRedeemRecordedContext.sol\";\nimport {IJBRedeemHook} from \"./IJBRedeemHook.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\n\n/// @notice A terminal that can be redeemed from.\ninterface IJBRedeemTerminal is IJBTerminal {\n    event RedeemTokens(\n        uint256 indexed rulesetId,\n        uint256 indexed rulesetCycleNumber,\n        uint256 indexed projectId,\n        address holder,\n        address beneficiary,\n        uint256 tokenCount,\n        uint256 redemptionRate,\n        uint256 reclaimedAmount,\n        bytes metadata,\n        address caller\n    );\n\n    event HookAfterRecordRedeem(\n        IJBRedeemHook indexed hook,\n        JBAfterRedeemRecordedContext context,\n        uint256 specificationAmount,\n        uint256 fee,\n        address caller\n    );\n\n    function redeemTokensOf(\n        address holder,\n        uint256 projectId,\n        address tokenToReclaim,\n        uint256 redeemCount,\n        uint256 minTokensReclaimed,\n        address payable beneficiary,\n        bytes calldata metadata\n    )\n        external\n        returns (uint256 reclaimAmount);\n}\n"
			},
			"src/libraries/JBFees.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {mulDiv} from \"@prb/math/src/Common.sol\";\n\nimport {JBConstants} from \"./../libraries/JBConstants.sol\";\n\n/// @notice Fee calculations.\nlibrary JBFees {\n    /// @notice Returns the amount of tokens to pay as a fee out of the specified `amount`.\n    /// @dev The resulting fee will be `feePercent` of the REMAINING `amount` after subtracting the fee, not the full\n    /// `amount`.\n    /// @param amount The amount that the fee is based on, as a fixed point number.\n    /// @param feePercent The fee percent, out of `JBConstants.MAX_FEE`.\n    /// @return The amount of tokens to pay as a fee, as a fixed point number with the same number of decimals as the\n    /// provided `amount`.\n    function feeAmountIn(uint256 amount, uint256 feePercent) internal pure returns (uint256) {\n        // The amount of tokens from the `amount` to pay as a fee. If reverse, the fee taken from a payout of\n        // `amount`.\n        return amount - mulDiv(amount, JBConstants.MAX_FEE, feePercent + JBConstants.MAX_FEE);\n    }\n\n    /// @notice Returns the fee that would have been paid based on an `amount` which has already had the fee subtracted\n    /// from it.\n    /// @dev The resulting fee will be `feePercent` of the full `amount`.\n    /// @param amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as\n    /// this terminal.\n    /// @param feePercent The fee percent, out of `JBConstants.MAX_FEE`.\n    /// @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.\n    function feeAmountFrom(uint256 amount, uint256 feePercent) internal pure returns (uint256) {\n        // The amount of tokens from the `amount` to pay as a fee. If reverse, the fee taken from a payout of\n        // `amount`.\n        return mulDiv(amount, feePercent, JBConstants.MAX_FEE);\n    }\n}\n"
			},
			"src/libraries/JBMetadataResolver.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/**\n * @notice Library to parse and create metadata to store {id: data} entries.\n *\n * @dev    Metadata are built as:\n *         - 32B of reserved space for the protocol\n *         - a lookup table `Id: offset`, defining the offset of the data for a given 4 bytes id.\n *           The offset fits 1 bytes, the ID 4 bytes. This table is padded to 32B.\n *         - the data for each id, padded to 32B each\n *\n *            +-----------------------+ offset: 0\n *            | 32B reserved          |\n *            +-----------------------+ offset: 1 = end of first 32B\n *            |      (ID1,offset1)    |\n *            |      (ID2,offset2)    |\n *            |       0's padding     |\n *            +-----------------------+ offset: offset1 = 1 + number of words taken by the padded table\n *            |       id1 data1       |\n *            | 0's padding           |\n *            +-----------------------+ offset: offset2 = offset1 + number of words taken by the data1\n *            |       id2 data2       |\n *            | 0's padding           |\n *            +-----------------------+\n */\nlibrary JBMetadataResolver {\n    error DATA_NOT_PADDED();\n    error LENGTH_MISMATCH();\n    error METADATA_TOO_LONG();\n    error METADATA_TOO_SHORT();\n\n    // The various sizes used in bytes.\n    uint256 constant ID_SIZE = 4;\n    uint256 constant ID_OFFSET_SIZE = 1;\n    uint256 constant WORD_SIZE = 32;\n\n    // The size that an ID takes in the lookup table (Identifier + Offset).\n    uint256 constant TOTAL_ID_SIZE = 5; // ID_SIZE + ID_OFFSET_SIZE;\n\n    // The amount of bytes to go forward to get to the offset of the next ID (aka. the end of the offset of the current\n    // ID).\n    uint256 constant NEXT_ID_OFFSET = 9; // TOTAL_ID_SIZE + ID_SIZE;\n\n    // 1 word (32B) is reserved for the protocol .\n    uint256 constant RESERVED_SIZE = 32; // 1 * WORD_SIZE;\n    uint256 constant MIN_METADATA_LENGTH = 37; // RESERVED_SIZE + ID_SIZE + ID_OFFSET_SIZE;\n\n    /**\n     * @notice Parse the metadata to find the data for a specific ID\n     *\n     * @dev    Returns false and an empty bytes if no data is found\n     *\n     * @param  id             The ID to find\n     * @param  metadata       The metadata to parse\n     *\n     * @return found          Whether the {id:data} was found\n     * @return targetData The data for the ID (can be empty)\n     */\n    function getDataFor(bytes4 id, bytes memory metadata) internal pure returns (bool found, bytes memory targetData) {\n        // Either no data or empty one with only one selector (32+4+1)\n        if (metadata.length <= MIN_METADATA_LENGTH) return (false, \"\");\n\n        // Get the first data offset - upcast to avoid overflow (same for other offset)\n        uint256 firstOffset = uint8(metadata[RESERVED_SIZE + ID_SIZE]);\n\n        // Parse the id's to find id, stop when next offset == 0 or current = first offset\n        for (uint256 i = RESERVED_SIZE; metadata[i + ID_SIZE] != bytes1(0) && i < firstOffset * WORD_SIZE;) {\n            uint256 currentOffset = uint256(uint8(metadata[i + ID_SIZE]));\n\n            bytes4 parsedId;\n            assembly {\n                parsedId := mload(add(add(metadata, 0x20), i))\n            }\n\n            // _id found?\n            if (parsedId == id) {\n                // Are we at the end of the lookup table (either at the start of data's or next offset is 0/in the\n                // padding)\n                // If not, only return until from this offset to the begining of the next offset\n                uint256 end = (i + NEXT_ID_OFFSET >= firstOffset * WORD_SIZE || metadata[i + NEXT_ID_OFFSET] == 0)\n                    ? metadata.length\n                    : uint256(uint8(metadata[i + NEXT_ID_OFFSET])) * WORD_SIZE;\n\n                return (true, _sliceBytes(metadata, currentOffset * WORD_SIZE, end));\n            }\n            unchecked {\n                i += TOTAL_ID_SIZE;\n            }\n        }\n    }\n\n    /**\n     * @notice Add an {id: data} entry to an existing metadata. This is an append-only mechanism.\n     *\n     * @param originalMetadata The original metadata\n     * @param idToAdd          The id to add\n     * @param dataToAdd        The data to add\n     *\n     * @return newMetadata    The new metadata with the entry added\n     */\n    function addToMetadata(\n        bytes memory originalMetadata,\n        bytes4 idToAdd,\n        bytes memory dataToAdd\n    )\n        internal\n        pure\n        returns (bytes memory newMetadata)\n    {\n        // Empty original metadata and maybe something in the first 32 bytes: create new metadata\n        if (originalMetadata.length <= RESERVED_SIZE) {\n            return abi.encodePacked(bytes32(originalMetadata), bytes32(abi.encodePacked(idToAdd, uint8(2))), dataToAdd);\n        }\n\n        // There is something in the table offset, but not a valid entry - avoid overwriting\n        if (originalMetadata.length < RESERVED_SIZE + ID_SIZE + 1) revert METADATA_TOO_SHORT();\n\n        // Make sure the data is padded to 32 bytes.\n        if (dataToAdd.length < 32) revert DATA_NOT_PADDED();\n\n        // Get the first data offset - upcast to avoid overflow (same for other offset)...\n        uint256 firstOffset = uint8(originalMetadata[RESERVED_SIZE + ID_SIZE]);\n\n        // ...go back to the beginning of the previous word (ie the last word of the table, as it can be padded)\n        uint256 lastWordOfTable = firstOffset - 1;\n\n        // The last offset stored in the table and its index\n        uint256 lastOffset;\n\n        uint256 lastOffsetIndex;\n\n        // The number of words taken by the last data stored\n        uint256 numberOfWordslastData;\n\n        // Iterate to find the last entry of the table, lastOffset - we start from the end as the first value\n        // encountered\n        // will be the last offset\n        for (uint256 i = firstOffset * WORD_SIZE - 1; i > lastWordOfTable * WORD_SIZE - 1; i--) {\n            // If the byte is not 0, this is the last offset we're looking for\n            if (originalMetadata[i] != 0) {\n                lastOffset = uint8(originalMetadata[i]);\n                lastOffsetIndex = i;\n\n                // No rounding as this should be padded to 32B\n                numberOfWordslastData = (originalMetadata.length - lastOffset * WORD_SIZE) / WORD_SIZE;\n\n                // Copy the reserved word and the table and remove the previous padding\n                newMetadata = _sliceBytes(originalMetadata, 0, lastOffsetIndex + 1);\n\n                // Check if the new entry is still fitting in this word\n                if (i + TOTAL_ID_SIZE >= firstOffset * WORD_SIZE) {\n                    // Increment every offset by 1 (as the table now takes one more word)\n                    for (uint256 j = RESERVED_SIZE + ID_SIZE; j < lastOffsetIndex + 1; j += TOTAL_ID_SIZE) {\n                        newMetadata[j] = bytes1(uint8(originalMetadata[j]) + 1);\n                    }\n\n                    // Increment the last offset so the new offset will be properly set too\n                    lastOffset++;\n                }\n\n                break;\n            }\n        }\n\n        // Add the new entry after the last entry of the table, the new offset is the last offset + the number of words\n        // taken by the last data\n        newMetadata = abi.encodePacked(newMetadata, idToAdd, bytes1(uint8(lastOffset + numberOfWordslastData)));\n\n        // Pad as needed - inlined for gas saving\n        uint256 paddedLength =\n            newMetadata.length % WORD_SIZE == 0 ? newMetadata.length : (newMetadata.length / WORD_SIZE + 1) * WORD_SIZE;\n        assembly {\n            mstore(newMetadata, paddedLength)\n        }\n\n        // Add existing data at the end\n        newMetadata = abi.encodePacked(\n            newMetadata, _sliceBytes(originalMetadata, firstOffset * WORD_SIZE, originalMetadata.length)\n        );\n\n        // Pad as needed\n        paddedLength =\n            newMetadata.length % WORD_SIZE == 0 ? newMetadata.length : (newMetadata.length / WORD_SIZE + 1) * WORD_SIZE;\n        assembly {\n            mstore(newMetadata, paddedLength)\n        }\n\n        // Append new data at the end\n        newMetadata = abi.encodePacked(newMetadata, dataToAdd);\n\n        // Pad again again as needed\n        paddedLength =\n            newMetadata.length % WORD_SIZE == 0 ? newMetadata.length : (newMetadata.length / WORD_SIZE + 1) * WORD_SIZE;\n\n        assembly {\n            mstore(newMetadata, paddedLength)\n        }\n    }\n\n    /**\n     * @notice Create the metadata for a list of {id:data}\n     *\n     * @dev    Intended for offchain use (gas heavy)\n     *\n     * @param _ids             The list of ids\n     * @param _datas       The list of corresponding datas\n     *\n     * @return metadata       The resulting metadata\n     */\n    function createMetadata(\n        bytes4[] memory _ids,\n        bytes[] memory _datas\n    )\n        internal\n        pure\n        returns (bytes memory metadata)\n    {\n        if (_ids.length != _datas.length) revert LENGTH_MISMATCH();\n\n        // Add a first empty 32B for the protocol reserved word\n        metadata = abi.encodePacked(bytes32(0));\n\n        // First offset for the data is after the first reserved word...\n        uint256 _offset = 1;\n\n        // ... and after the id/offset lookup table, rounding up to 32 bytes words if not a multiple\n        _offset += ((_ids.length * JBMetadataResolver.TOTAL_ID_SIZE) - 1) / JBMetadataResolver.WORD_SIZE + 1;\n\n        // For each id, add it to the lookup table with the next free offset, then increment the offset by the data\n        // length (rounded up)\n        for (uint256 _i; _i < _ids.length; ++_i) {\n            if (_datas[_i].length < 32 || _datas[_i].length % JBMetadataResolver.WORD_SIZE != 0) {\n                revert DATA_NOT_PADDED();\n            }\n\n            metadata = abi.encodePacked(metadata, _ids[_i], bytes1(uint8(_offset)));\n            _offset += _datas[_i].length / JBMetadataResolver.WORD_SIZE;\n\n            // Overflowing a bytes1?\n            if (_offset > 255) revert METADATA_TOO_LONG();\n        }\n\n        // Pad the table to a multiple of 32B\n        uint256 _paddedLength = metadata.length % JBMetadataResolver.WORD_SIZE == 0\n            ? metadata.length\n            : (metadata.length / JBMetadataResolver.WORD_SIZE + 1) * JBMetadataResolver.WORD_SIZE;\n        assembly {\n            mstore(metadata, _paddedLength)\n        }\n\n        // Add each metadata to the array, each padded to 32 bytes\n        for (uint256 _i; _i < _datas.length; _i++) {\n            metadata = abi.encodePacked(metadata, _datas[_i]);\n            _paddedLength = metadata.length % JBMetadataResolver.WORD_SIZE == 0\n                ? metadata.length\n                : (metadata.length / JBMetadataResolver.WORD_SIZE + 1) * JBMetadataResolver.WORD_SIZE;\n\n            assembly {\n                mstore(metadata, _paddedLength)\n            }\n        }\n    }\n\n    /**\n     * @notice Returns an unique id following a suggested format\n     *         (`xor(address(this), purpose name)` where purpose name is a string\n     *         giving context to the id (Permit2, quoteForSwap, etc)\n     *\n     * @param purpose   A string describing the purpose associated with the id\n     *\n     * @return id       The resulting id\n     */\n    function getId(string memory purpose) internal view returns (bytes4) {\n        return getId(purpose, address(this));\n    }\n\n    /**\n     * @notice Returns an unique id following a suggested format\n     *         (`xor(address(this), purpose name)` where purpose name is a string\n     *         giving context to the id (Permit2, quoteForSwap, etc)\n     *\n     * @param purpose   A string describing the purpose associated with the id\n     * @param target          The target which will use the metadata\n     *\n     * @return id       The resulting id\n     */\n    function getId(string memory purpose, address target) internal pure returns (bytes4) {\n        return bytes4(bytes20(target) ^ bytes20(keccak256(bytes(purpose))));\n    }\n\n    /// @notice Slice bytes from a start index to an end index.\n    /// @param data The bytes array to slice\n    /// @param start The start index to slice at.\n    /// @param end The end index to slice at.\n    /// @param slicedBytes The sliced array.\n    function _sliceBytes(\n        bytes memory data,\n        uint256 start,\n        uint256 end\n    )\n        internal\n        pure\n        returns (bytes memory slicedBytes)\n    {\n        assembly {\n            let length := sub(end, start)\n\n            // Allocate memory at the freemem(add 0x20 to include the length)\n            slicedBytes := mload(0x40)\n            mstore(0x40, add(add(slicedBytes, length), 0x20))\n\n            // Store the length (first element)\n            mstore(slicedBytes, length)\n\n            // compute the actual data first offset only once\n            let startBytes := add(add(data, 0x20), start)\n\n            // same for the out array\n            let sliceBytesStartOfData := add(slicedBytes, 0x20)\n\n            // store dem data\n            for { let i := 0 } lt(i, end) { i := add(i, 0x20) } {\n                mstore(add(sliceBytesStartOfData, i), mload(add(startBytes, i)))\n            }\n        }\n    }\n}\n"
			},
			"src/structs/JBFee.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member amount The total amount the fee was taken from, as a fixed point number with the same number of\n/// decimals as the terminal in which this struct was created.\n/// @custom:member beneficiary The address that will receive the tokens that are minted as a result of the fee payment.\n/// @custom:member unlockTimestamp The timestamp at which the fee is unlocked and can be processed.\nstruct JBFee {\n    uint256 amount;\n    address beneficiary;\n    uint48 unlockTimestamp;\n}\n"
			},
			"src/structs/JBSingleAllowance.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member sigDeadline Deadline on the permit signature.\n/// @custom:member amount The maximum amount allowed to spend.\n/// @custom:member expiration Timestamp at which a spender's token allowances become invalid.\n/// @custom:member nonce An incrementing value indexed per owner,token,and spender for each signature.\n/// @custom:member signature The signature over the permit data. Supports EOA signatures, compact signatures defined by\n/// EIP-2098, and contract signatures defined by EIP-1271.\nstruct JBSingleAllowance {\n    uint256 sigDeadline;\n    uint160 amount;\n    uint48 expiration;\n    uint48 nonce;\n    bytes signature;\n}\n"
			}
		}
	}
}