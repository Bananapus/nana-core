{
	"solcVersion": "0.8.23",
	"solcLongVersion": "0.8.23",
	"id": "d72d671cb704a380777b1be08dd807eb",
	"input": {
		"language": "Solidity",
		"settings": {
			"viaIR": false,
			"optimizer": {
				"runs": 200,
				"enabled": true
			},
			"metadata": {
				"useLiteralContent": false,
				"bytecodeHash": "ipfs",
				"appendCBOR": true
			},
			"outputSelection": {
				"*": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"metadata",
						"storageLayout"
					]
				}
			},
			"evmVersion": "paris",
			"libraries": {},
			"remappings": [
				"@sphinx-labs/contracts/=lib/sphinx/packages/contracts/contracts/foundry/",
				"@bananapus/=node_modules/@bananapus/",
				"@chainlink/=node_modules/@chainlink/",
				"@eth-optimism/=node_modules/@eth-optimism/",
				"@openzeppelin/=node_modules/@openzeppelin/",
				"@prb/=node_modules/@prb/",
				"@scroll-tech/=node_modules/@scroll-tech/",
				"@uniswap/=node_modules/@uniswap/",
				"ds-test/=lib/forge-std/lib/ds-test/src/",
				"forge-std/=lib/forge-std/src/",
				"hardhat/=node_modules/hardhat/",
				"solmate/=node_modules/solmate/",
				"sphinx/=lib/sphinx/"
			]
		},
		"sources": {
			"node_modules/@bananapus/permission-ids/src/JBPermissionIds.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Permission IDs for `JBPermissions`, used throughout the Bananapus ecosystem. See\n/// https://github.com/Bananapus/nana-core/blob/main/src/JBPermissions.sol\n/// @dev `JBPermissions` allows one address to grant another address permission to call functions in Juicebox contracts\n/// on their behalf. Each ID in `JBPermissionIds` grants access to a specific set of these functions.\nlibrary JBPermissionIds {\n    uint256 internal constant ROOT = 1; // All permissions across every contract. Very dangerous. BE CAREFUL!\n\n    /* Used by `nana-core`: https://github.com/Bananapus/nana-core */\n    uint256 internal constant QUEUE_RULESETS = 2; // Permission to call `JBController.queueRulesetsOf` and\n        // `JBController.launchRulesetsFor`.\n    uint256 internal constant REDEEM_TOKENS = 3; // Permission to call `JBMultiTerminal.redeemTokensOf`.\n    uint256 internal constant SEND_PAYOUTS = 4; // Permission to call `JBMultiTerminal.sendPayoutsOf`.\n    uint256 internal constant MIGRATE_TERMINAL = 5; // Permission to call `JBMultiTerminal.migrateBalanceOf`.\n    uint256 internal constant SET_PROJECT_METADATA = 6; // Permission to call `JBController.setUriOf`.\n    uint256 internal constant DEPLOY_ERC20 = 7; // Permission to call `JBController.deployERC20For`.\n    uint256 internal constant SET_TOKEN = 8; // Permission to call `JBController.setTokenFor`.\n    uint256 internal constant MINT_TOKENS = 9; // Permission to call `JBController.mintTokensOf`.\n    uint256 internal constant BURN_TOKENS = 10; // Permission to call `JBController.burnTokensOf`.\n    uint256 internal constant CLAIM_TOKENS = 11; // Permission to call `JBController.claimTokensFor`.\n    uint256 internal constant TRANSFER_CREDITS = 12; // Permission to call `JBController.transferCreditsFrom`.\n    uint256 internal constant SET_CONTROLLER = 13; // Permission to call `JBDirectory.setControllerOf`.\n    uint256 internal constant SET_TERMINALS = 14; // Permission to call `JBDirectory.setTerminalsOf`.\n    uint256 internal constant SET_PRIMARY_TERMINAL = 15; // Permission to call `JBDirectory.setPrimaryTerminalOf`.\n    uint256 internal constant USE_ALLOWANCE = 16; // Permission to call `JBMultiTerminal.useAllowanceOf`.\n    uint256 internal constant SET_SPLIT_GROUPS = 17; // Permission to call `JBController.setSplitGroupsOf`.\n    uint256 internal constant ADD_PRICE_FEED = 18; // Permission to call `JBPrices.addPriceFeedFor`.\n    uint256 internal constant ADD_ACCOUNTING_CONTEXTS = 19; // Permission to call\n        // `JBMultiTerminal.addAccountingContextsFor`.\n\n    /* Used by `nana-project-handles`: https://github.com/Bananapus/nana-project-handles */\n    uint256 internal constant SET_ENS_NAME = 20; // Permission to call `JBProjectHandles.setEnsNamePartsFor`.\n\n    /* Used by `nana-721-hook`: https://github.com/Bananapus/nana-721-hook */\n    uint256 internal constant ADJUST_721_TIERS = 21; // Permission to call `JB721TiersHook.adjustTiers`.\n    uint256 internal constant SET_721_METADATA = 22; // Permission to call `JB721TiersHook.setMetadata`.\n    uint256 internal constant MINT_721 = 23; // Permission to call `JB721TiersHook.mintFor`.\n\n    /* Used by `nana-buyback-hook`: https://github.com/Bananapus/nana-buyback-hook */\n    uint256 internal constant SET_BUYBACK_TWAP = 24; // Permission to call `JBBuybackHook.setTwapWindowOf` and\n        // `JBBuybackHook.setTwapSlippageToleranceOf`.\n    uint256 internal constant SET_BUYBACK_POOL = 25; // Permission to call `JBBuybackHook.setPoolFor`.\n\n    /* Used by `nana-swap-terminal`: https://github.com/Bananapus/nana-swap-terminal */\n    uint256 internal constant ADD_SWAP_TERMINAL_POOL = 26; // Permission to call `JBSwapTerminal.addDefaultPool`.\n    uint256 internal constant ADD_SWAP_TERMINAL_TWAP_PARAMS = 27; // Permission to call\n        // `JBSwapTerminal.addTwapParamsFor`.\n\n    /* Used by `nana-suckers`: https://github.com/Bananapus/nana-suckers */\n    uint256 internal constant MAP_SUCKER_TOKEN = 28; // Permission to call `BPSucker.mapToken`.\n    uint256 internal constant DEPLOY_SUCKERS = 29; // Permission to call `BPSuckerRegistry.deploySuckersFor`.\n}\n"
			},
			"src/JBPermissions.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {JBPermissionIds} from \"@bananapus/permission-ids/src/JBPermissionIds.sol\";\n\nimport {IJBPermissions} from \"./interfaces/IJBPermissions.sol\";\nimport {JBPermissionsData} from \"./structs/JBPermissionsData.sol\";\n\n/// @notice Stores permissions for all addresses and operators. Addresses can give permissions to any other address\n/// (i.e. an *operator*) to execute specific operations on their behalf.\ncontract JBPermissions is IJBPermissions {\n    //*********************************************************************//\n    // --------------------------- custom errors ------------------------- //\n    //*********************************************************************//\n    error PERMISSION_ID_OUT_OF_BOUNDS();\n    error UNAUTHORIZED();\n\n    //*********************************************************************//\n    // ------------------------- public constants ------------------------ //\n    //*********************************************************************//\n\n    /// @notice The project ID considered a wildcard, meaning it will grant permissions to all projects.\n    uint256 public constant override WILDCARD_PROJECT_ID = 0;\n\n    //*********************************************************************//\n    // --------------------- public stored properties -------------------- //\n    //*********************************************************************//\n\n    /// @notice The permissions that an operator has been given by an account for a specific project.\n    /// @dev An account can give an operator permissions that only pertain to a specific project ID.\n    /// @dev There is no project with a ID of 0 – this ID is a wildcard which gives an operator permissions pertaining\n    /// to *all* project IDs on an account's behalf. Use this with caution.\n    /// @dev Permissions are stored in a packed `uint256`. Each of the 256 bits represents the on/off state of a\n    /// permission. Applications can specify the significance of each permission ID.\n    /// @custom:param operator The address of the operator.\n    /// @custom:param account The address of the account being operated on behalf of.\n    /// @custom:param projectId The project ID the permissions are scoped to. An ID of 0 grants permissions across all\n    /// projects.\n    mapping(address operator => mapping(address account => mapping(uint256 projectId => uint256))) public override\n        permissionsOf;\n\n    //*********************************************************************//\n    // ------------------------- external views -------------------------- //\n    //*********************************************************************//\n\n    /// @notice Check if an operator has a specific permission for a specific address and project ID.\n    /// @param operator The operator to check.\n    /// @param account The account being operated on behalf of.\n    /// @param projectId The project ID that the operator has permission to operate under. 0 represents all projects.\n    /// @param permissionId The permission ID to check for.\n    /// @param includeRoot A flag indicating if the return value should default to true if the operator has the ROOT\n    /// permission.\n    /// @param includeWildcardProjectId A flag indicating if the return value should return true if the operator has the\n    /// specified permission on the wildcard project ID.\n    /// true.\n    /// @return A flag indicating whether the operator has the specified permission.\n    function hasPermission(\n        address operator,\n        address account,\n        uint256 projectId,\n        uint256 permissionId,\n        bool includeRoot,\n        bool includeWildcardProjectId\n    )\n        public\n        view\n        override\n        returns (bool)\n    {\n        // Indexes above 255 don't exist\n        if (permissionId > 255) revert PERMISSION_ID_OUT_OF_BOUNDS();\n\n        // If the ROOT permission is set and should be included, return true.\n        if (\n            includeRoot\n                && (\n                    _includesPermission({\n                        permissions: permissionsOf[operator][account][projectId],\n                        permissionId: JBPermissionIds.ROOT\n                    })\n                        || (\n                            includeWildcardProjectId\n                                && _includesPermission({\n                                    permissions: permissionsOf[operator][account][WILDCARD_PROJECT_ID],\n                                    permissionId: JBPermissionIds.ROOT\n                                })\n                        )\n                )\n        ) {\n            return true;\n        }\n\n        // Otherwise return the t/f flag of the specified id.\n        return _includesPermission({\n            permissions: permissionsOf[operator][account][projectId],\n            permissionId: permissionId\n        })\n            || (\n                includeWildcardProjectId\n                    && _includesPermission({\n                        permissions: permissionsOf[operator][account][WILDCARD_PROJECT_ID],\n                        permissionId: permissionId\n                    })\n            );\n    }\n\n    /// @notice Check if an operator has all of the specified permissions for a specific address and project ID.\n    /// @param operator The operator to check.\n    /// @param account The account being operated on behalf of.\n    /// @param projectId The project ID that the operator has permission to operate under. 0 represents all projects.\n    /// @param permissionIds An array of permission IDs to check for.\n    /// @param includeRoot A flag indicating if the return value should default to true if the operator has the ROOT\n    /// permission.\n    /// @param includeWildcardProjectId A flag indicating if the return value should return true if the operator has the\n    /// specified permission on the wildcard project ID.\n    /// @return A flag indicating whether the operator has all specified permissions.\n    function hasPermissions(\n        address operator,\n        address account,\n        uint256 projectId,\n        uint256[] calldata permissionIds,\n        bool includeRoot,\n        bool includeWildcardProjectId\n    )\n        external\n        view\n        override\n        returns (bool)\n    {\n        // If the ROOT permission is set and should be included, return true.\n        if (\n            includeRoot\n                && (\n                    _includesPermission({\n                        permissions: permissionsOf[operator][account][projectId],\n                        permissionId: JBPermissionIds.ROOT\n                    })\n                        || (\n                            includeWildcardProjectId\n                                && _includesPermission({\n                                    permissions: permissionsOf[operator][account][WILDCARD_PROJECT_ID],\n                                    permissionId: JBPermissionIds.ROOT\n                                })\n                        )\n                )\n        ) {\n            return true;\n        }\n\n        // Keep a reference to the permission being iterated on.\n        uint256 permissionId;\n\n        // Keep a reference to the permission item being checked.\n        uint256 operatorAccountProjectPermissions = permissionsOf[operator][account][projectId];\n\n        // Keep a reference to the wildcard project permissions.\n        uint256 operatorAccountWildcardProjectPermissions =\n            includeWildcardProjectId ? permissionsOf[operator][account][WILDCARD_PROJECT_ID] : 0;\n\n        for (uint256 i; i < permissionIds.length; i++) {\n            // Set the permission being iterated on.\n            permissionId = permissionIds[i];\n\n            // Indexes above 255 don't exist\n            if (permissionId > 255) revert PERMISSION_ID_OUT_OF_BOUNDS();\n\n            // Check each permissionId\n            if (\n                !_includesPermission({permissions: operatorAccountProjectPermissions, permissionId: permissionId})\n                    && !_includesPermission({permissions: operatorAccountWildcardProjectPermissions, permissionId: permissionId})\n            ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    //*********************************************************************//\n    // ---------------------- external transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice Sets permissions for an operator.\n    /// @dev Only an address can give permissions to or revoke permissions from its operators.\n    /// @param account The account setting its operators' permissions.\n    /// @param permissionsData The data which specifies the permissions the operator is being given.\n    function setPermissionsFor(address account, JBPermissionsData calldata permissionsData) external override {\n        // Pack the permission IDs into a uint256.\n        uint256 packed = _packedPermissions(permissionsData.permissionIds);\n\n        // Enforce permissions. ROOT operators are allowed to set permissions so long as they are not setting another\n        // ROOT permission.\n        if (\n            msg.sender != account\n                && (\n                    _includesPermission({permissions: packed, permissionId: JBPermissionIds.ROOT})\n                        || !hasPermission({\n                            operator: msg.sender,\n                            account: account,\n                            projectId: permissionsData.projectId,\n                            permissionId: JBPermissionIds.ROOT,\n                            includeRoot: true,\n                            includeWildcardProjectId: true\n                        })\n                )\n        ) revert UNAUTHORIZED();\n\n        // Store the new value.\n        permissionsOf[permissionsData.operator][account][permissionsData.projectId] = packed;\n\n        emit OperatorPermissionsSet(\n            permissionsData.operator,\n            account,\n            permissionsData.projectId,\n            permissionsData.permissionIds,\n            packed,\n            msg.sender\n        );\n    }\n\n    //*********************************************************************//\n    // --------------------- internal helper functions ------------------- //\n    //*********************************************************************//\n\n    /// @notice Converts an array of permission IDs to a packed `uint256`.\n    /// @param permissionIds The IDs of the permissions to pack.\n    /// @return packed The packed value.\n    function _packedPermissions(uint256[] calldata permissionIds) internal pure returns (uint256 packed) {\n        // Keep a reference to the permission being iterated on.\n        uint256 permissionId;\n\n        for (uint256 i; i < permissionIds.length; i++) {\n            // Set the permission being iterated on.\n            permissionId = permissionIds[i];\n\n            if (permissionId > 255) revert PERMISSION_ID_OUT_OF_BOUNDS();\n\n            // Turn on the bit at the ID.\n            packed |= 1 << permissionId;\n        }\n    }\n\n    /// @notice Checks if a permission is included in a packed permissions data.\n    /// @param permissions The packed permissions to check.\n    /// @param permissionId The ID of the permission to check for.\n    /// @return A flag indicating whether the permission is included.\n    function _includesPermission(uint256 permissions, uint256 permissionId) internal pure returns (bool) {\n        return ((permissions >> permissionId) & 1) == 1;\n    }\n}\n"
			},
			"src/interfaces/IJBPermissions.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBPermissionsData} from \"./../structs/JBPermissionsData.sol\";\n\ninterface IJBPermissions {\n    event OperatorPermissionsSet(\n        address indexed operator,\n        address indexed account,\n        uint256 indexed projectId,\n        uint256[] permissionIds,\n        uint256 packed,\n        address caller\n    );\n\n    function WILDCARD_PROJECT_ID() external view returns (uint256);\n\n    function permissionsOf(address operator, address account, uint256 projectId) external view returns (uint256);\n\n    function hasPermission(\n        address operator,\n        address account,\n        uint256 projectId,\n        uint256 permissionId,\n        bool includeRoot,\n        bool includeWildcardProjectId\n    )\n        external\n        view\n        returns (bool);\n\n    function hasPermissions(\n        address operator,\n        address account,\n        uint256 projectId,\n        uint256[] calldata permissionIds,\n        bool includeRoot,\n        bool includeWildcardProjectId\n    )\n        external\n        view\n        returns (bool);\n\n    function setPermissionsFor(address account, JBPermissionsData calldata permissionsData) external;\n}\n"
			},
			"src/structs/JBPermissionsData.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member operator The address that permissions are being given to.\n/// @custom:member projectId The ID of the project the operator is being given permissions for. Operators only have\n/// permissions under this project's scope. An ID of 0 is a wildcard, which gives an operator permissions across all\n/// projects.\n/// @custom:member permissionIds The IDs of the permissions being given. See the `JBPermissionIds` library.\nstruct JBPermissionsData {\n    address operator;\n    uint256 projectId;\n    uint256[] permissionIds;\n}\n"
			},
			"node_modules/@openzeppelin/contracts/access/Ownable.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/interfaces/IERC5267.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.20;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
			},
			"node_modules/@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"./IERC721.sol\";\nimport {IERC721Receiver} from \"./IERC721Receiver.sol\";\nimport {IERC721Metadata} from \"./extensions/IERC721Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {Strings} from \"../../utils/Strings.sol\";\nimport {IERC165, ERC165} from \"../../utils/introspection/ERC165.sol\";\nimport {IERC721Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\nabstract contract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Errors {\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    mapping(uint256 tokenId => address) private _owners;\n\n    mapping(address owner => uint256) private _balances;\n\n    mapping(uint256 tokenId => address) private _tokenApprovals;\n\n    mapping(address owner => mapping(address operator => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n\n        return _getApproved(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        // Setting an \"auth\" arguments enables the `_isAuthorized` check which verifies that the token exists\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     *\n     * IMPORTANT: Any overrides to this function that add ownership of tokens not tracked by the\n     * core ERC721 logic MUST be matched with the use of {_increaseBalance} to keep balances\n     * consistent with ownership. The invariant to preserve is that for any address `a` the value returned by\n     * `balanceOf(a)` must be equal to the number of tokens such that `_ownerOf(tokenId)` is `a`.\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns the approved address for `tokenId`. Returns 0 if `tokenId` is not minted.\n     */\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `owner`'s tokens, or `tokenId` in\n     * particular (ignoring whether it is owned by `owner`).\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Checks if `spender` can operate on `tokenId`, assuming the provided `owner` is the actual owner.\n     * Reverts if `spender` does not have approval from the provided `owner` for the given token or for all its assets\n     * the `spender` for the specific `tokenId`.\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * NOTE: the value is limited to type(uint128).max. This protect against _balance overflow. It is unrealistic that\n     * a uint256 would ever overflow from increments when these increments are bounded to uint128 values.\n     *\n     * WARNING: Increasing an account's balance using this function tends to be paired with an override of the\n     * {_ownerOf} function to resolve the ownership of the corresponding tokens so that balances and ownership\n     * remain consistent with one another.\n     */\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        unchecked {\n            _balances[account] += value;\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from its current owner to `to`, or alternatively mints (or burns) if the current owner\n     * (or `to`) is the zero address. Returns the owner of the `tokenId` before the update.\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that\n     * `auth` is either the owner of the token, or approved to operate on the token (by the owner).\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: If overriding this function in a way that tracks balances, see also {_increaseBalance}.\n     */\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n\n    /**\n     * @dev Mints `tokenId`, transfers it to `to` and checks for `to` acceptance.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking that contract recipients\n     * are aware of the ERC721 standard to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is like {safeTransferFrom} in the sense that it invokes\n     * {IERC721Receiver-onERC721Received} on the receiver, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `tokenId` token must exist and be owned by `from`.\n     * - `to` cannot be the zero address.\n     * - `from` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeTransfer-address-address-uint256-}[`_safeTransfer`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that `auth` is\n     * either the owner of the token, or approved to operate on all tokens held by this owner.\n     *\n     * Emits an {Approval} event.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n\n    /**\n     * @dev Variant of `_approve` with an optional flag to enable or disable the {Approval} event. The event is not\n     * emitted in the context of transfers.\n     */\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Requirements:\n     * - operator can't be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` doesn't have a current owner (it hasn't been minted, or it has been burned).\n     * Returns the owner.\n     *\n     * Overrides to ownership logic should be done to {_ownerOf}.\n     */\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n\n    /**\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target address. This will revert if the\n     * recipient doesn't accept the token transfer. The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/Context.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/ShortStrings.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ShortStrings.sol)\n\npragma solidity ^0.8.20;\n\nimport {StorageSlot} from \"./StorageSlot.sol\";\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a \"normal\" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using\n     * {setWithFallback}.\n     *\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/StorageSlot.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/Strings.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.20;\n\nimport {MessageHashUtils} from \"./MessageHashUtils.sol\";\nimport {ShortStrings, ShortString} from \"../ShortStrings.sol\";\nimport {IERC5267} from \"../../interfaces/IERC5267.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the {_domainSeparatorV4} function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable\n */\nabstract contract EIP712 is IERC5267 {\n    using ShortStrings for *;\n\n    bytes32 private constant TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {IERC-5267}.\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _name which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Name() internal view returns (string memory) {\n        return _name.toStringWithFallback(_nameFallback);\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _version which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Version() internal view returns (string memory) {\n        return _version.toStringWithFallback(_versionFallback);\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\npragma solidity ^0.8.20;\n\nimport {Strings} from \"../Strings.sol\";\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/math/Math.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
			},
			"src/JBProjects.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {EIP712} from \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IJBProjects} from \"./interfaces/IJBProjects.sol\";\nimport {IJBTokenUriResolver} from \"./interfaces/IJBTokenUriResolver.sol\";\n\n/// @notice Stores project ownership and metadata.\n/// @dev Projects are represented as ERC-721s.\ncontract JBProjects is ERC721, Ownable, IJBProjects {\n    //*********************************************************************//\n    // --------------------- public stored properties -------------------- //\n    //*********************************************************************//\n\n    /// @notice The number of projects that have been created using this contract.\n    /// @dev The count is incremented with each new project created.\n    /// @dev The resulting ERC-721 token ID for each project is the newly incremented count value.\n    uint256 public override count = 0;\n\n    /// @notice The contract resolving each project ID to its ERC721 URI.\n    IJBTokenUriResolver public override tokenUriResolver;\n\n    //*********************************************************************//\n    // -------------------------- public views --------------------------- //\n    //*********************************************************************//\n\n    /// @notice Returns the URI where the ERC-721 standard JSON of a project is hosted.\n    /// @param projectId The ID of the project to get a URI of.\n    /// @return The token URI to use for the provided `projectId`.\n    function tokenURI(uint256 projectId) public view override returns (string memory) {\n        // Keep a reference to the resolver.\n        IJBTokenUriResolver resolver = tokenUriResolver;\n\n        // If there's no resolver, there's no URI.\n        if (resolver == IJBTokenUriResolver(address(0))) return \"\";\n\n        // Return the resolved URI.\n        return resolver.getUri(projectId);\n    }\n\n    /// @notice Indicates whether this contract adheres to the specified interface.\n    /// @dev See {IERC165-supportsInterface}.\n    /// @param interfaceId The ID of the interface to check for adherence to.\n    /// @return A flag indicating if the provided interface ID is supported.\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IJBProjects).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param owner The owner of the contract who can set metadata.\n    /// @param feeProjectOwner The address that will receive the fee-project. If `address(0)` the fee-project will not\n    /// be minted.\n    constructor(address owner, address feeProjectOwner) ERC721(\"Juicebox Projects\", \"JUICEBOX\") Ownable(owner) {\n        if (feeProjectOwner != address(0)) {\n            createFor(feeProjectOwner);\n        }\n    }\n\n    //*********************************************************************//\n    // ---------------------- public transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice Create a new project for the specified owner, which mints an NFT (ERC-721) into their wallet.\n    /// @dev Anyone can create a project on an owner's behalf.\n    /// @param owner The address that will be the owner of the project.\n    /// @return projectId The token ID of the newly created project.\n    function createFor(address owner) public override returns (uint256 projectId) {\n        // Increment the count, which will be used as the ID.\n        projectId = ++count;\n\n        // Mint the project.\n        _safeMint(owner, projectId);\n\n        emit Create(projectId, owner, _msgSender());\n    }\n\n    //*********************************************************************//\n    // ---------------------- external transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice Sets the address of the resolver used to retrieve the tokenURI of projects.\n    /// @param newResolver The address of the new resolver.\n    function setTokenUriResolver(IJBTokenUriResolver newResolver) external override onlyOwner {\n        // Store the new resolver.\n        tokenUriResolver = newResolver;\n\n        emit SetTokenUriResolver(newResolver, _msgSender());\n    }\n}\n"
			},
			"src/interfaces/IJBProjects.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport {IJBTokenUriResolver} from \"./IJBTokenUriResolver.sol\";\n\ninterface IJBProjects is IERC721 {\n    event Create(uint256 indexed projectId, address indexed owner, address caller);\n\n    event SetTokenUriResolver(IJBTokenUriResolver indexed resolver, address caller);\n\n    function count() external view returns (uint256);\n\n    function tokenUriResolver() external view returns (IJBTokenUriResolver);\n\n    function createFor(address owner) external returns (uint256 projectId);\n\n    function setTokenUriResolver(IJBTokenUriResolver newResolver) external;\n}\n"
			},
			"src/interfaces/IJBTokenUriResolver.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBTokenUriResolver {\n    function getUri(uint256 projectId) external view returns (string memory tokenUri);\n}\n"
			},
			"src/JBDirectory.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {JBPermissionIds} from \"@bananapus/permission-ids/src/JBPermissionIds.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBPermissioned} from \"./abstract/JBPermissioned.sol\";\nimport {IJBDirectory} from \"./interfaces/IJBDirectory.sol\";\nimport {IJBDirectoryAccessControl} from \"./interfaces/IJBDirectoryAccessControl.sol\";\nimport {IJBPermissions} from \"./interfaces/IJBPermissions.sol\";\nimport {IJBTerminal} from \"./interfaces/IJBTerminal.sol\";\nimport {IJBProjects} from \"./interfaces/IJBProjects.sol\";\n\n/// @notice `JBDirectory` tracks the terminals and the controller used by each project.\n/// @dev Tracks which `IJBTerminal`s each project is currently accepting funds through, and which `IJBController` is\n/// managing each project's tokens and rulesets.\ncontract JBDirectory is JBPermissioned, Ownable, IJBDirectory {\n    //*********************************************************************//\n    // --------------------------- custom errors ------------------------- //\n    //*********************************************************************//\n\n    error DUPLICATE_TERMINALS();\n    error INVALID_PROJECT_ID_IN_DIRECTORY();\n    error SET_CONTROLLER_NOT_ALLOWED();\n    error SET_TERMINALS_NOT_ALLOWED();\n    error TOKEN_NOT_ACCEPTED();\n\n    //*********************************************************************//\n    // ---------------- public immutable stored properties --------------- //\n    //*********************************************************************//\n\n    /// @notice Mints ERC-721s that represent project ownership and transfers.\n    IJBProjects public immutable override PROJECTS;\n\n    //*********************************************************************//\n    // --------------------- public stored properties -------------------- //\n    //*********************************************************************//\n\n    /// @notice The specified project's controller, which dictates how its terminals interact with its tokens and\n    /// rulesets.\n    /// @custom:param projectId The ID of the project to get the controller of.\n    mapping(uint256 projectId => IERC165) public override controllerOf;\n\n    /// @notice Whether the specified address is allowed to set a project's first controller on their behalf.\n    /// @dev These addresses/contracts have been vetted by this contract's owner.\n    /// @custom:param addr The address to check.\n    mapping(address addr => bool) public override isAllowedToSetFirstController;\n\n    //*********************************************************************//\n    // --------------------- internal stored properties ------------------ //\n    //*********************************************************************//\n\n    /// @notice The specified project's terminals.\n    /// @custom:param projectId The ID of the project to get the terminals of.\n    mapping(uint256 projectId => IJBTerminal[]) internal _terminalsOf;\n\n    /// @notice The primary terminal that a project uses for the specified token.\n    /// @custom:param projectId The ID of the project to get the primary terminal of.\n    /// @custom:param token The token that the terminal accepts.\n    mapping(uint256 projectId => mapping(address token => IJBTerminal)) internal _primaryTerminalOf;\n\n    //*********************************************************************//\n    // ------------------------- external views -------------------------- //\n    //*********************************************************************//\n\n    /// @notice The specified project's terminals.\n    /// @param projectId The ID of the project to get the terminals of.\n    /// @return An array of the project's terminal addresses.\n    function terminalsOf(uint256 projectId) external view override returns (IJBTerminal[] memory) {\n        return _terminalsOf[projectId];\n    }\n\n    /// @notice The primary terminal that a project uses for the specified token.\n    /// @dev Returns the first terminal that accepts the token if the project hasn't explicitly set a primary terminal\n    /// for it.\n    /// @dev Returns the zero address if no terminal accepts the token.\n    /// @param projectId The ID of the project to get the primary terminal of.\n    /// @param token The token that the terminal accepts.\n    /// @return The primary terminal's address.\n    function primaryTerminalOf(uint256 projectId, address token) external view override returns (IJBTerminal) {\n        // Keep a reference to the primary terminal for the provided project ID and token.\n        IJBTerminal primaryTerminal = _primaryTerminalOf[projectId][token];\n\n        // If a primary terminal for the token was explicitly set and it's one of the project's terminals, return it.\n        if (primaryTerminal != IJBTerminal(address(0)) && isTerminalOf(projectId, primaryTerminal)) {\n            return primaryTerminal;\n        }\n\n        // Keep a reference to the number of terminals the project has.\n        uint256 numberOfTerminals = _terminalsOf[projectId].length;\n\n        // Return the first terminal which accepts the specified token.\n        for (uint256 i; i < numberOfTerminals; i++) {\n            // Keep a reference to the terminal being iterated on.\n            IJBTerminal terminal = _terminalsOf[projectId][i];\n\n            // If the terminal accepts the specified token, return it.\n            if (terminal.accountingContextForTokenOf(projectId, token).token != address(0)) {\n                return terminal;\n            }\n        }\n\n        // Not found.\n        return IJBTerminal(address(0));\n    }\n\n    //*********************************************************************//\n    // -------------------------- public views --------------------------- //\n    //*********************************************************************//\n\n    /// @notice Check if a project uses a specific terminal.\n    /// @param projectId The ID of the project to check.\n    /// @param terminal The terminal to check for.\n    /// @return A flag indicating whether the project uses the terminal.\n    function isTerminalOf(uint256 projectId, IJBTerminal terminal) public view override returns (bool) {\n        // Keep a reference to the number of terminals the project has.\n        uint256 numberOfTerminals = _terminalsOf[projectId].length;\n\n        // Loop through and return true if the terminal is found.\n        for (uint256 i; i < numberOfTerminals; i++) {\n            if (_terminalsOf[projectId][i] == terminal) return true;\n        }\n\n        // Otherwise, return false.\n        return false;\n    }\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param permissions A contract storing permissions.\n    /// @param projects A contract which mints ERC-721s that represent project ownership and transfers.\n    /// @param owner The address that will own the contract.\n    constructor(\n        IJBPermissions permissions,\n        IJBProjects projects,\n        address owner\n    )\n        JBPermissioned(permissions)\n        Ownable(owner)\n    {\n        PROJECTS = projects;\n    }\n\n    //*********************************************************************//\n    // ---------------------- external transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice Set a project's controller. Controllers manage how terminals interact with tokens and rulesets.\n    /// @dev Can only be called if:\n    /// - The ruleset's metadata has `allowSetController` enabled, and the message's sender is the project's owner or an\n    /// address with the owner's permission to `SET_CONTROLLER`.\n    /// - OR the message's sender is the project's current controller.\n    /// - OR an address which `isAllowedToSetFirstController` is setting a project's first controller.\n    /// @param projectId The ID of the project whose controller is being set.\n    /// @param controller The address of the controller to set.\n    function setControllerOf(uint256 projectId, IERC165 controller) external override {\n        // Enforce permissions.\n        _requirePermissionAllowingOverrideFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.SET_CONTROLLER,\n            alsoGrantAccessIf: (isAllowedToSetFirstController[msg.sender] && address(controllerOf[projectId]) == address(0))\n        });\n        // The project must exist.\n        if (PROJECTS.count() < projectId) revert INVALID_PROJECT_ID_IN_DIRECTORY();\n\n        // Keep a reference to the current controller.\n        IERC165 currentController = controllerOf[projectId];\n\n        // Get a reference to a flag indicating whether the project is allowed to set its controller.\n        // Setting the controller is allowed if the project doesn't have a controller,\n        // OR if the caller is the current controller,\n        // OR if the project's ruleset allows setting the controller.\n        bool allowSetController = address(currentController) == address(0)\n            || !currentController.supportsInterface(type(IJBDirectoryAccessControl).interfaceId)\n            ? true\n            : IJBDirectoryAccessControl(address(currentController)).setControllerAllowed(projectId);\n\n        // If setting the controller is not allowed, revert.\n        if (!allowSetController) {\n            revert SET_CONTROLLER_NOT_ALLOWED();\n        }\n\n        // Set the new controller.\n        controllerOf[projectId] = controller;\n\n        emit SetController(projectId, controller, msg.sender);\n    }\n\n    /// @notice Set a project's terminals.\n    /// @dev Can only be called by the project's owner, an address with the owner's permission to `SET_TERMINALS`, or\n    /// the project's controller.\n    /// @dev Unless the caller is the project's controller, the project's ruleset must allow setting terminals.\n    /// @param projectId The ID of the project whose terminals are being set.\n    /// @param terminals An array of terminal addresses to set for the project.\n    function setTerminalsOf(uint256 projectId, IJBTerminal[] calldata terminals) external override {\n        // Enforce permissions.\n        _requirePermissionAllowingOverrideFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.SET_TERMINALS,\n            alsoGrantAccessIf: msg.sender == address(controllerOf[projectId])\n        });\n\n        // Keep a reference to the project's controller.\n        IERC165 controller = controllerOf[projectId];\n\n        // Get a reference to the flag indicating whether the project is allowed to set its terminals.\n        bool allowSetTerminals = !controller.supportsInterface(type(IJBDirectoryAccessControl).interfaceId)\n            || IJBDirectoryAccessControl(address(controller)).setTerminalsAllowed(projectId);\n\n        // If the caller is not the project's controller, the project's ruleset must allow setting terminals.\n        if (msg.sender != address(controllerOf[projectId]) && !allowSetTerminals) {\n            revert SET_TERMINALS_NOT_ALLOWED();\n        }\n\n        // Set the stored terminals for the project.\n        _terminalsOf[projectId] = terminals;\n\n        // Keep a reference to the number of terminals being iterated upon.\n        uint256 numberOfTerminals = terminals.length;\n\n        // If there are any duplicates, revert.\n        if (numberOfTerminals > 1) {\n            for (uint256 i; i < numberOfTerminals; i++) {\n                for (uint256 j = i + 1; j < numberOfTerminals; j++) {\n                    if (terminals[i] == terminals[j]) revert DUPLICATE_TERMINALS();\n                }\n            }\n        }\n        emit SetTerminals(projectId, terminals, msg.sender);\n    }\n\n    /// @notice Set a project's primary terminal for a token.\n    /// @dev The primary terminal for a token is where payments in that token are routed to by default.\n    /// @dev This is useful in cases where a project has multiple terminals which accept the same token.\n    /// @dev Can only be called by the project's owner, or an address with the owner's permission to\n    /// `SET_PRIMARY_TERMINAL`.\n    /// @param projectId The ID of the project whose primary terminal is being set.\n    /// @param token The token to set the primary terminal for.\n    /// @param terminal The terminal being set as the primary terminal.\n    function setPrimaryTerminalOf(uint256 projectId, address token, IJBTerminal terminal) external override {\n        // Enforce permissions.\n        _requirePermissionFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.SET_PRIMARY_TERMINAL\n        });\n\n        // If the terminal doesn't accept the token, revert.\n        if (terminal.accountingContextForTokenOf(projectId, token).token == address(0)) {\n            revert TOKEN_NOT_ACCEPTED();\n        }\n\n        // If the terminal hasn't already been added to the project, add it.\n        _addTerminalIfNeeded(projectId, terminal);\n\n        // Store the terminal as the project's primary terminal for the token.\n        _primaryTerminalOf[projectId][token] = terminal;\n\n        emit SetPrimaryTerminal(projectId, token, terminal, msg.sender);\n    }\n\n    /// @notice Add or remove an address/contract from a list of trusted addresses which are allowed to set a first\n    /// controller for projects.\n    /// @dev Only this contract's owner can call this function.\n    /// @dev These addresses are vetted controllers as well as contracts designed to launch new projects.\n    /// @dev A project can set its own controller without being on this list.\n    /// @dev If you would like to add an address/contract to this list, please reach out to this contract's owner.\n    /// @param addr The address to allow or not allow.\n    /// @param flag Whether the address is allowed to set first controllers for projects. Use `true` to allow and\n    /// `false` to not allow.\n    function setIsAllowedToSetFirstController(address addr, bool flag) external override onlyOwner {\n        // Set the flag in the allowlist.\n        isAllowedToSetFirstController[addr] = flag;\n\n        emit SetIsAllowedToSetFirstController(addr, flag, msg.sender);\n    }\n\n    //*********************************************************************//\n    // --------------------- internal helper functions ------------------- //\n    //*********************************************************************//\n\n    /// @notice If a terminal hasn't already been added to a project's list of terminals, add it.\n    /// @dev Unless the caller is the project's controller, the project's ruleset must have `allowSetTerminals` set to\n    /// `true`.\n    /// @param projectId The ID of the project to add the terminal to.\n    /// @param terminal The terminal to add.\n    function _addTerminalIfNeeded(uint256 projectId, IJBTerminal terminal) internal {\n        // Ensure that the terminal has not already been added.\n        if (isTerminalOf(projectId, terminal)) return;\n\n        // Keep a reference to the current controller.\n        IERC165 controller = controllerOf[projectId];\n\n        // Get a reference to a flag indicating whether the project is allowed to set its terminals.\n        bool allowSetTerminals = !controller.supportsInterface(type(IJBDirectoryAccessControl).interfaceId)\n            || IJBDirectoryAccessControl(address(controller)).setTerminalsAllowed(projectId);\n\n        // If the caller is not the project's controller, the project's ruleset must allow setting terminals.\n        if (msg.sender != address(controllerOf[projectId]) && !allowSetTerminals) {\n            revert SET_TERMINALS_NOT_ALLOWED();\n        }\n\n        // Add the new terminal.\n        _terminalsOf[projectId].push(terminal);\n\n        emit AddTerminal(projectId, terminal, msg.sender);\n    }\n}\n"
			},
			"src/abstract/JBPermissioned.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\n\nimport {IJBPermissioned} from \"./../interfaces/IJBPermissioned.sol\";\nimport {IJBPermissions} from \"./../interfaces/IJBPermissions.sol\";\n\n/// @notice Modifiers to allow access to transactions based on which permissions the message's sender has.\nabstract contract JBPermissioned is Context, IJBPermissioned {\n    //*********************************************************************//\n    // --------------------------- custom errors -------------------------- //\n    //*********************************************************************//\n    error UNAUTHORIZED();\n\n    //*********************************************************************//\n    // ---------------- public immutable stored properties --------------- //\n    //*********************************************************************//\n\n    /// @notice A contract storing permissions.\n    IJBPermissions public immutable override PERMISSIONS;\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param permissions A contract storing permissions.\n    constructor(IJBPermissions permissions) {\n        PERMISSIONS = permissions;\n    }\n\n    //*********************************************************************//\n    // -------------------------- internal views ------------------------- //\n    //*********************************************************************//\n\n    /// @notice Require the message sender to be the account or have the relevant permission.\n    /// @param account The account to allow.\n    /// @param projectId The project ID to check the permission under.\n    /// @param permissionId The required permission ID. The operator must have this permission within the specified\n    /// project ID.\n    function _requirePermissionFrom(address account, uint256 projectId, uint256 permissionId) internal view {\n        address sender = _msgSender();\n        if (\n            sender != account\n                && !PERMISSIONS.hasPermission({\n                    operator: sender,\n                    account: account,\n                    projectId: projectId,\n                    permissionId: permissionId,\n                    includeRoot: true,\n                    includeWildcardProjectId: true\n                })\n        ) revert UNAUTHORIZED();\n    }\n\n    /// @notice If the 'alsoGrantAccessIf' condition is truthy, proceed. Otherwise, require the message sender to be the\n    /// account or\n    /// have the relevant permission.\n    /// @param account The account to allow.\n    /// @param projectId The project ID to check the permission under.\n    /// @param permissionId The required permission ID. The operator must have this permission within the specified\n    /// project ID.\n    /// @param alsoGrantAccessIf An override condition which will allow access regardless of permissions.\n    function _requirePermissionAllowingOverrideFrom(\n        address account,\n        uint256 projectId,\n        uint256 permissionId,\n        bool alsoGrantAccessIf\n    )\n        internal\n        view\n    {\n        if (alsoGrantAccessIf) return;\n        _requirePermissionFrom(account, projectId, permissionId);\n    }\n}\n"
			},
			"src/interfaces/IJBDirectory.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IJBProjects} from \"./IJBProjects.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\n\ninterface IJBDirectory {\n    event SetController(uint256 indexed projectId, IERC165 indexed controller, address caller);\n\n    event AddTerminal(uint256 indexed projectId, IJBTerminal indexed terminal, address caller);\n\n    event SetTerminals(uint256 indexed projectId, IJBTerminal[] terminals, address caller);\n\n    event SetPrimaryTerminal(\n        uint256 indexed projectId, address indexed token, IJBTerminal indexed terminal, address caller\n    );\n\n    event SetIsAllowedToSetFirstController(address indexed addr, bool indexed flag, address caller);\n\n    function PROJECTS() external view returns (IJBProjects);\n\n    function controllerOf(uint256 projectId) external view returns (IERC165);\n\n    function isAllowedToSetFirstController(address account) external view returns (bool);\n\n    function terminalsOf(uint256 projectId) external view returns (IJBTerminal[] memory);\n\n    function isTerminalOf(uint256 projectId, IJBTerminal terminal) external view returns (bool);\n\n    function primaryTerminalOf(uint256 projectId, address token) external view returns (IJBTerminal);\n\n    function setControllerOf(uint256 projectId, IERC165 controller) external;\n\n    function setTerminalsOf(uint256 projectId, IJBTerminal[] calldata terminals) external;\n\n    function setPrimaryTerminalOf(uint256 projectId, address token, IJBTerminal terminal) external;\n\n    function setIsAllowedToSetFirstController(address account, bool flag) external;\n}\n"
			},
			"src/interfaces/IJBDirectoryAccessControl.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBDirectoryAccessControl {\n    function setTerminalsAllowed(uint256 projectId) external view returns (bool);\n    function setControllerAllowed(uint256 projectId) external view returns (bool);\n}\n"
			},
			"src/interfaces/IJBPayHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBAfterPayRecordedContext} from \"./../structs/JBAfterPayRecordedContext.sol\";\n\n/// @notice Hook called after a terminal's `pay(...)` logic completes (if passed by the ruleset's data hook).\ninterface IJBPayHook is IERC165 {\n    /// @notice This function is called by the terminal's `pay(...)` function after the payment has been recorded in the\n    /// terminal store.\n    /// @dev Critical business logic should be protected by appropriate access control.\n    /// @param context The context passed in by the terminal, as a `JBAfterPayRecordedContext` struct.\n    function afterPayRecordedWith(JBAfterPayRecordedContext calldata context) external payable;\n}\n"
			},
			"src/interfaces/IJBPermissioned.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPermissions} from \"./IJBPermissions.sol\";\n\ninterface IJBPermissioned {\n    function PERMISSIONS() external view returns (IJBPermissions);\n}\n"
			},
			"src/interfaces/IJBTerminal.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBAccountingContext} from \"../structs/JBAccountingContext.sol\";\nimport {JBAfterPayRecordedContext} from \"../structs/JBAfterPayRecordedContext.sol\";\nimport {IJBPayHook} from \"../interfaces/IJBPayHook.sol\";\n\n/// @notice A terminal that accepts payments and can be migrated.\ninterface IJBTerminal is IERC165 {\n    event MigrateTerminal(\n        uint256 indexed projectId, address indexed token, IJBTerminal indexed to, uint256 amount, address caller\n    );\n\n    event AddToBalance(\n        uint256 indexed projectId, uint256 amount, uint256 unlockedFees, string memo, bytes metadata, address caller\n    );\n\n    event SetAccountingContext(\n        uint256 indexed projectId, address indexed token, JBAccountingContext context, address caller\n    );\n\n    event Pay(\n        uint256 indexed rulesetId,\n        uint256 indexed rulesetCycleNumber,\n        uint256 indexed projectId,\n        address payer,\n        address beneficiary,\n        uint256 amount,\n        uint256 beneficiaryTokenCount,\n        string memo,\n        bytes metadata,\n        address caller\n    );\n\n    event HookAfterRecordPay(\n        IJBPayHook indexed hook, JBAfterPayRecordedContext context, uint256 specificationAmount, address caller\n    );\n\n    function accountingContextForTokenOf(\n        uint256 projectId,\n        address token\n    )\n        external\n        view\n        returns (JBAccountingContext memory);\n\n    function accountingContextsOf(uint256 projectId) external view returns (JBAccountingContext[] memory);\n\n    function currentSurplusOf(uint256 projectId, uint256 decimals, uint256 currency) external view returns (uint256);\n\n    function migrateBalanceOf(uint256 projectId, address token, IJBTerminal to) external returns (uint256 balance);\n\n    function addAccountingContextsFor(uint256 projectId, address[] calldata tokens) external;\n\n    function pay(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        address beneficiary,\n        uint256 minReturnedTokens,\n        string calldata memo,\n        bytes calldata metadata\n    )\n        external\n        payable\n        returns (uint256 beneficiaryTokenCount);\n\n    function addToBalanceOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        bool shouldReturnHeldFees,\n        string calldata memo,\n        bytes calldata metadata\n    )\n        external\n        payable;\n}\n"
			},
			"src/structs/JBAccountingContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member token The address of the token that accounting is being done with.\n/// @custom:member decimals The number of decimals expected in that token's fixed point accounting.\n/// @custom:member currency The currency that the token is priced in terms of.\nstruct JBAccountingContext {\n    address token;\n    uint8 decimals;\n    uint32 currency;\n}\n"
			},
			"src/structs/JBAfterPayRecordedContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTokenAmount} from \"./JBTokenAmount.sol\";\n\n/// @custom:member payer The address the payment originated from.\n/// @custom:member projectId The ID of the project being paid.\n/// @custom:member rulesetId The ID of the ruleset the payment is being made during.\n/// @custom:member amount The payment's token amount. Includes the token being paid, the value, the number of decimals\n/// included, and the currency of the amount.\n/// @custom:member forwardedAmount The token amount being forwarded to the pay hook. Includes the token\n/// being paid, the value, the number of decimals included, and the currency of the amount.\n/// @custom:member weight The current ruleset's weight (used to determine how many tokens should be minted).\n/// @custom:member projectTokenCount The number of project tokens minted for the beneficiary.\n/// @custom:member beneficiary The address which receives any tokens this payment yields.\n/// @custom:member hookMetadata Extra data specified by the data hook, which is sent to the pay hook.\n/// @custom:member payerMetadata Extra data specified by the payer, which is sent to the pay hook.\nstruct JBAfterPayRecordedContext {\n    address payer;\n    uint256 projectId;\n    uint256 rulesetId;\n    JBTokenAmount amount;\n    JBTokenAmount forwardedAmount;\n    uint256 weight;\n    uint256 projectTokenCount;\n    address beneficiary;\n    bytes hookMetadata;\n    bytes payerMetadata;\n}\n"
			},
			"src/structs/JBTokenAmount.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member token The token the payment was made in.\n/// @custom:member value The amount of tokens that was paid, as a fixed point number.\n/// @custom:member decimals The number of decimals included in the value fixed point number.\n/// @custom:member currency The expected currency of the value.\nstruct JBTokenAmount {\n    address token;\n    uint256 value;\n    uint256 decimals;\n    uint256 currency;\n}\n"
			},
			"src/JBSplits.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {JBControlled} from \"./abstract/JBControlled.sol\";\nimport {IJBDirectory} from \"./interfaces/IJBDirectory.sol\";\nimport {IJBSplitHook} from \"./interfaces/IJBSplitHook.sol\";\nimport {IJBSplits} from \"./interfaces/IJBSplits.sol\";\nimport {JBConstants} from \"./libraries/JBConstants.sol\";\nimport {JBSplit} from \"./structs/JBSplit.sol\";\nimport {JBSplitGroup} from \"./structs/JBSplitGroup.sol\";\n\n/// @notice Stores and manages splits for each project.\ncontract JBSplits is JBControlled, IJBSplits {\n    //*********************************************************************//\n    // --------------------------- custom errors ------------------------- //\n    //*********************************************************************//\n    error INVALID_LOCKED_UNTIL();\n    error INVALID_PROJECT_ID();\n    error INVALID_SPLIT_PERCENT();\n    error INVALID_TOTAL_PERCENT();\n    error PREVIOUS_LOCKED_SPLITS_NOT_INCLUDED();\n\n    //*********************************************************************//\n    // ------------------------- public constants ------------------------ //\n    //*********************************************************************//\n\n    /// @notice The ID of the ruleset that will be checked if nothing was found in the provided rulesetId.\n    uint256 public constant override FALLBACK_RULESET_ID = 0;\n\n    //*********************************************************************//\n    // --------------------- internal stored properties ------------------ //\n    //*********************************************************************//\n\n    /// @notice The number of splits currently stored in a group given a project ID, ruleset ID, and group ID.\n    /// @custom:param projectId The ID of the project the split applies to.\n    /// @custom:param rulesetId The ID of the ruleset that the group is specified within.\n    /// @custom:param groupId The ID of the group to count this splits of.\n    mapping(uint256 projectId => mapping(uint256 rulesetId => mapping(uint256 groupId => uint256))) internal\n        _splitCountOf;\n\n    /// @notice Packed split data given the split's project, ruleset, and group IDs, as well as the split's index within\n    /// that group.\n    /// @dev `preferAddToBalance` in bit 0, `percent` in bits 1-32, `projectId` in bits 33-88, and `beneficiary` in bits\n    /// 89-248\n    /// @custom:param projectId The ID of the project that the split applies to.\n    /// @custom:param rulesetId The ID of the ruleset that the group is in.\n    /// @custom:param groupId The ID of the group the split is in.\n    /// @custom:param index The split's index within the group (in the order that the split were set).\n    /// @custom:return The split's `preferAddToBalance`, `percent`, `projectId`, and `beneficiary` packed into one\n    /// `uint256`.\n    mapping(\n        uint256 projectId => mapping(uint256 rulesetId => mapping(uint256 groupId => mapping(uint256 index => uint256)))\n    ) internal _packedSplitParts1Of;\n\n    /// @notice More packed split data given the split's project, ruleset, and group IDs, as well as the split's index\n    /// within that group.\n    /// @dev `lockedUntil` in bits 0-47, `hook` address in bits 48-207.\n    /// @dev This packed data is often 0.\n    /// @custom:param projectId The ID of the project that the ruleset applies to.\n    /// @custom:param rulesetId The ID of the ruleset that the group is in.\n    /// @custom:param groupId The ID of the group the split is in.\n    /// @custom:param index The split's index within the group (in the order that the split were set).\n    /// @custom:return The split's `lockedUntil` and `hook` packed into one `uint256`.\n    mapping(\n        uint256 projectId => mapping(uint256 rulesetId => mapping(uint256 groupId => mapping(uint256 index => uint256)))\n    ) internal _packedSplitParts2Of;\n\n    //*********************************************************************//\n    // ------------------------- external views -------------------------- //\n    //*********************************************************************//\n\n    /// @notice Get the split structs for the specified project ID, within the specified ruleset, for the specified\n    /// group. The splits stored at ruleset 0 are used by default during a ruleset if the splits for the specific\n    /// ruleset aren't set.\n    /// @dev If splits aren't found at the given `rulesetId`, they'll be sought in the FALLBACK_RULESET_ID of 0.\n    /// @param projectId The ID of the project to get splits for.\n    /// @param rulesetId An identifier within which the returned splits should be considered active.\n    /// @param groupId The identifying group of the splits.\n    /// @return splits An array of all splits for the project.\n    function splitsOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        uint256 groupId\n    )\n        external\n        view\n        override\n        returns (JBSplit[] memory splits)\n    {\n        splits = _getStructsFor(projectId, rulesetId, groupId);\n\n        // Use the default splits if there aren't any for the ruleset.\n        if (splits.length == 0) {\n            splits = _getStructsFor({projectId: projectId, rulesetId: FALLBACK_RULESET_ID, groupId: groupId});\n        }\n    }\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param directory A contract storing directories of terminals and controllers for each project.\n    constructor(IJBDirectory directory) JBControlled(directory) {}\n\n    //*********************************************************************//\n    // ---------------------- external transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice Sets a project's split groups.\n    /// @dev Only a project's controller can set its splits.\n    /// @dev The new split groups must include any currently set splits that are locked.\n    /// @param projectId The ID of the project to set the split groups of.\n    /// @param rulesetId The ID of the ruleset the split groups should be active in. Send\n    /// 0 to set the default split that'll be active if no ruleset has specific splits set. The default's default is the\n    /// project's owner.\n    /// @param splitGroups An array of split groups to set.\n    function setSplitGroupsOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        JBSplitGroup[] calldata splitGroups\n    )\n        external\n        override\n        onlyControllerOf(projectId)\n    {\n        // Keep a reference to the number of split groups.\n        uint256 numberOfSplitGroups = splitGroups.length;\n\n        // Set each grouped splits.\n        for (uint256 i; i < numberOfSplitGroups; i++) {\n            // Get a reference to the grouped split being iterated on.\n            JBSplitGroup memory splitGroup = splitGroups[i];\n\n            // Set the splits for the group.\n            _setSplitsOf(projectId, rulesetId, splitGroup.groupId, splitGroup.splits);\n        }\n    }\n\n    //*********************************************************************//\n    // --------------------- internal helper functions ------------------- //\n    //*********************************************************************//\n\n    /// @notice Sets the splits for a group given a project, ruleset, and group ID.\n    /// @dev The new splits must include any currently set splits that are locked.\n    /// @dev The sum of the split `percent`s within one group must be less than 100%.\n    /// @param projectId The ID of the project splits are being set for.\n    /// @param rulesetId The ID of the ruleset the splits should be considered active within.\n    /// @param groupId The ID of the group to set the splits within.\n    /// @param splits An array of splits to set.\n    function _setSplitsOf(uint256 projectId, uint256 rulesetId, uint256 groupId, JBSplit[] memory splits) internal {\n        // Get a reference to the current split structs within the project, ruleset, and group.\n        JBSplit[] memory currentSplits = _getStructsFor(projectId, rulesetId, groupId);\n\n        // Keep a reference to the current number of splits within the group.\n        uint256 numberOfCurrentSplits = currentSplits.length;\n\n        // Check to see if all locked splits are included in the array of splits which is being set.\n        for (uint256 i; i < numberOfCurrentSplits; i++) {\n            // If not locked, continue.\n            if (block.timestamp < currentSplits[i].lockedUntil && !_includesLockedSplits(splits, currentSplits[i])) {\n                revert PREVIOUS_LOCKED_SPLITS_NOT_INCLUDED();\n            }\n        }\n\n        // Add up all the `percent`s to make sure their total is under 100%.\n        uint256 percentTotal;\n\n        // Keep a reference to the number of splits to set.\n        uint256 numberOfSplits = splits.length;\n\n        for (uint256 i; i < numberOfSplits; i++) {\n            // The percent should be greater than 0.\n            if (splits[i].percent == 0) revert INVALID_SPLIT_PERCENT();\n\n            // `projectId` should fit within a uint56\n            if (splits[i].projectId > type(uint56).max) revert INVALID_PROJECT_ID();\n\n            // Add to the `percent` total.\n            percentTotal = percentTotal + splits[i].percent;\n\n            // Ensure the total does not exceed 100%.\n            if (percentTotal > JBConstants.SPLITS_TOTAL_PERCENT) revert INVALID_TOTAL_PERCENT();\n\n            uint256 packedSplitParts1;\n\n            // Pack `preferAddToBalance` in bit 0.\n            if (splits[i].preferAddToBalance) packedSplitParts1 = 1;\n            // Pack `percent` in bits 1-32.\n            packedSplitParts1 |= splits[i].percent << 1;\n            // Pack `projectId` in bits 33-88.\n            packedSplitParts1 |= splits[i].projectId << 33;\n            // Pack `beneficiary` in bits 89-248.\n            packedSplitParts1 |= uint256(uint160(address(splits[i].beneficiary))) << 89;\n\n            // Store the first split part.\n            _packedSplitParts1Of[projectId][rulesetId][groupId][i] = packedSplitParts1;\n\n            // If there's data to store in the second packed split part, pack and store.\n            if (splits[i].lockedUntil > 0 || splits[i].hook != IJBSplitHook(address(0))) {\n                // `lockedUntil` should fit within a uint48\n                if (splits[i].lockedUntil > type(uint48).max) revert INVALID_LOCKED_UNTIL();\n\n                // Pack `lockedUntil` in bits 0-47.\n                uint256 packedSplitParts2 = uint48(splits[i].lockedUntil);\n                // Pack `hook` in bits 48-207.\n                packedSplitParts2 |= uint256(uint160(address(splits[i].hook))) << 48;\n\n                // Store the second split part.\n                _packedSplitParts2Of[projectId][rulesetId][groupId][i] = packedSplitParts2;\n            } else if (_packedSplitParts2Of[projectId][rulesetId][groupId][i] > 0) {\n                // If there's a value stored in the indexed position, delete it.\n                delete _packedSplitParts2Of[projectId][rulesetId][groupId][i];\n            }\n\n            emit SetSplit(projectId, rulesetId, groupId, splits[i], msg.sender);\n        }\n\n        // Store the number of splits for the project, ruleset, and group.\n        _splitCountOf[projectId][rulesetId][groupId] = numberOfSplits;\n    }\n\n    /// @notice Determine if the provided splits array includes the locked split.\n    /// @param splits The array of splits to check within.\n    /// @param lockedSplit The locked split.\n    /// @return A flag indicating if the `lockedSplit` is contained in the `splits`.\n    function _includesLockedSplits(JBSplit[] memory splits, JBSplit memory lockedSplit) internal pure returns (bool) {\n        // Keep a reference to the number of splits.\n        uint256 numberOfSplits = splits.length;\n\n        for (uint256 i; i < numberOfSplits; i++) {\n            // Check for sameness.\n            if (\n                splits[i].percent == lockedSplit.percent && splits[i].beneficiary == lockedSplit.beneficiary\n                    && splits[i].hook == lockedSplit.hook && splits[i].projectId == lockedSplit.projectId\n                    && splits[i].preferAddToBalance == lockedSplit.preferAddToBalance\n                // Allow the lock to be extended.\n                && splits[i].lockedUntil >= lockedSplit.lockedUntil\n            ) return true;\n        }\n\n        return false;\n    }\n\n    /// @notice Unpack an array of `JBSplit` structs for all of the splits in a group, given project, ruleset, and group\n    /// IDs.\n    /// @param projectId The ID of the project the splits belong to.\n    /// @param rulesetId The ID of the ruleset the group of splits should be considered active within.\n    /// @param groupId The ID of the group to get the splits structs of.\n    /// @return splits The split structs, as an array of `JBSplit`s.\n    function _getStructsFor(\n        uint256 projectId,\n        uint256 rulesetId,\n        uint256 groupId\n    )\n        internal\n        view\n        returns (JBSplit[] memory)\n    {\n        // Get a reference to the number of splits that need to be added to the returned array.\n        uint256 splitCount = _splitCountOf[projectId][rulesetId][groupId];\n\n        // Initialize an array to be returned that has the appropriate length.\n        JBSplit[] memory splits = new JBSplit[](splitCount);\n\n        // Loop through each split and unpack the values into structs.\n        for (uint256 i; i < splitCount; i++) {\n            // Get a reference to the first part of the split's packed data.\n            uint256 packedSplitPart1 = _packedSplitParts1Of[projectId][rulesetId][groupId][i];\n\n            // Populate the split struct.\n            JBSplit memory split;\n\n            // `preferAddToBalance` in bit 0.\n            split.preferAddToBalance = packedSplitPart1 & 1 == 1;\n            // `percent` in bits 1-32.\n            split.percent = uint256(uint32(packedSplitPart1 >> 1));\n            // `projectId` in bits 33-88.\n            split.projectId = uint256(uint56(packedSplitPart1 >> 33));\n            // `beneficiary` in bits 89-248.\n            split.beneficiary = payable(address(uint160(packedSplitPart1 >> 89)));\n\n            // Get a reference to the second part of the split's packed data.\n            uint256 packedSplitPart2 = _packedSplitParts2Of[projectId][rulesetId][groupId][i];\n\n            // If there's anything in it, unpack.\n            if (packedSplitPart2 > 0) {\n                // `lockedUntil` in bits 0-47.\n                split.lockedUntil = uint256(uint48(packedSplitPart2));\n                // `hook` in bits 48-207.\n                split.hook = IJBSplitHook(address(uint160(packedSplitPart2 >> 48)));\n            }\n\n            // Add the split to the value being returned.\n            splits[i] = split;\n        }\n\n        return splits;\n    }\n}\n"
			},
			"src/abstract/JBControlled.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBControlled} from \"./../interfaces/IJBControlled.sol\";\nimport {IJBDirectory} from \"./../interfaces/IJBDirectory.sol\";\n\n/// @notice Provides a modifier for contracts with functionality that can only be accessed by a project's controller.\nabstract contract JBControlled is IJBControlled {\n    //*********************************************************************//\n    // --------------------------- custom errors -------------------------- //\n    //*********************************************************************//\n    error CONTROLLER_UNAUTHORIZED();\n\n    //*********************************************************************//\n    // ---------------------------- modifiers ---------------------------- //\n    //*********************************************************************//\n\n    /// @notice Only allows the controller of the specified project to proceed.\n    /// @param projectId The ID of the project.\n    modifier onlyControllerOf(uint256 projectId) {\n        if (address(DIRECTORY.controllerOf(projectId)) != msg.sender) {\n            revert CONTROLLER_UNAUTHORIZED();\n        }\n        _;\n    }\n\n    //*********************************************************************//\n    // ---------------- public immutable stored properties --------------- //\n    //*********************************************************************//\n\n    /// @notice The directory of terminals and controllers for projects.\n    IJBDirectory public immutable override DIRECTORY;\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param directory A contract storing directories of terminals and controllers for each project.\n    constructor(IJBDirectory directory) {\n        DIRECTORY = directory;\n    }\n}\n"
			},
			"src/interfaces/IJBControlled.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBDirectory} from \"./IJBDirectory.sol\";\n\ninterface IJBControlled {\n    function DIRECTORY() external view returns (IJBDirectory);\n}\n"
			},
			"src/interfaces/IJBSplitHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBSplitHookContext} from \"../structs/JBSplitHookContext.sol\";\n\n/// @title Split hook\n/// @notice Allows processing a single split with custom logic.\n/// @dev The split hook's address should be set as the `hook` in the relevant split.\ninterface IJBSplitHook is IERC165 {\n    /// @notice If a split has a split hook, payment terminals and controllers call this function while processing the\n    /// split.\n    /// @dev Critical business logic should be protected by appropriate access control. The tokens and/or native tokens\n    /// are optimistically transferred to the split hook when this function is called.\n    /// @param context The context passed by the terminal/controller to the split hook as a `JBSplitHookContext` struct:\n    function processSplitWith(JBSplitHookContext calldata context) external payable;\n}\n"
			},
			"src/interfaces/IJBSplits.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBSplit} from \"./../structs/JBSplit.sol\";\nimport {JBSplitGroup} from \"./../structs/JBSplitGroup.sol\";\nimport {IJBProjects} from \"./IJBProjects.sol\";\n\ninterface IJBSplits {\n    event SetSplit(\n        uint256 indexed projectId, uint256 indexed rulesetId, uint256 indexed group, JBSplit split, address caller\n    );\n\n    function FALLBACK_RULESET_ID() external view returns (uint256);\n\n    function splitsOf(uint256 projectId, uint256 rulesetId, uint256 group) external view returns (JBSplit[] memory);\n\n    function setSplitGroupsOf(uint256 projectId, uint256 rulesetId, JBSplitGroup[] memory splitGroups) external;\n}\n"
			},
			"src/libraries/JBConstants.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice Global constants used across Juicebox contracts.\nlibrary JBConstants {\n    /// @notice Each chain's native token address in Juicebox is represented by\n    /// 0x000000000000000000000000000000000000EEEe.\n    address public constant NATIVE_TOKEN = address(0x000000000000000000000000000000000000EEEe);\n    uint256 public constant MAX_RESERVED_RATE = 10_000;\n    uint256 public constant MAX_REDEMPTION_RATE = 10_000;\n    uint256 public constant MAX_DECAY_RATE = 1_000_000_000;\n    uint256 public constant SPLITS_TOTAL_PERCENT = 1_000_000_000;\n    uint256 public constant MAX_FEE = 1000;\n    uint256 public constant MAX_FEE_DISCOUNT = 1_000_000_000;\n}\n"
			},
			"src/structs/JBSplit.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBSplitHook} from \"./../interfaces/IJBSplitHook.sol\";\n\n/// @notice Splits are used to send a percentage of a total token amount to a specific contract, project, or address.\n/// Splits are used to send payouts and reserved tokens.\n/// @dev 1. If a non-zero split hook contract is specified, this split's tokens are sent there along with this split's\n/// properties.\n/// @dev 2. Otherwise, if a non-zero project ID is specified, this split's tokens are used to `pay` it through its\n/// terminal if possible, or sent to the project's owner if not. If this payment yields tokens, those go to the split's\n/// `beneficiary`.\n/// @dev 3. Otherwise, this split's tokens are sent directly to the `beneficiary`.\n/// @dev To summarize, this split's tokens are sent according to the following priority: `split hook` > `projectId` >\n/// `beneficiary`.\n/// @custom:member preferAddToBalance If this split were to `pay` a project through its terminal, this flag indicates\n/// whether it should prefer using the terminal's `addToBalance` function instead.\n/// @custom:member percent The percent of the total token amount that this split sends. This number is out of\n/// `JBConstants.SPLITS_TOTAL_PERCENT`.\n/// @custom:member projectId The ID of a project to `pay`, if applicable. Resulting tokens will be routed to the\n/// `beneficiary`.\n/// @custom:member beneficiary Receives this split's tokens if the `hook` and `projectId` are zero. If the `projectId`\n/// is specified, the `beneficiary` receives any project tokens minted by this split.\n/// @custom:member lockedUntil The split cannot be changed until this timestamp. The `lockedUntil` timestamp can be\n/// increased while a split is locked. If `lockedUntil` is zero, this split can be changed at any time.\n/// @custom:member hook A contract which will receive this split's tokens and properties, and can define custom\n/// behavior.\nstruct JBSplit {\n    bool preferAddToBalance;\n    uint256 percent;\n    uint256 projectId;\n    address payable beneficiary;\n    uint256 lockedUntil;\n    IJBSplitHook hook;\n}\n"
			},
			"src/structs/JBSplitGroup.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBSplit} from \"./JBSplit.sol\";\n\n/// @custom:member groupId An identifier for the group.\n/// @custom:member splits The splits in the group.\nstruct JBSplitGroup {\n    uint256 groupId;\n    JBSplit[] splits;\n}\n"
			},
			"src/structs/JBSplitHookContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBSplit} from \"./JBSplit.sol\";\n\n/// @custom:member token The token being sent to the split hook.\n/// @custom:member amount The amount being sent to the split hook, as a fixed point number.\n/// @custom:member decimals The number of decimals in the amount.\n/// @custom:member projectId The project the split belongs to.\n/// @custom:member groupId The group the split belongs to.\n/// @custom:member split The split which specified the hook.\nstruct JBSplitHookContext {\n    address token;\n    uint256 amount;\n    uint256 decimals;\n    uint256 projectId;\n    uint256 groupId;\n    JBSplit split;\n}\n"
			},
			"node_modules/@prb/math/src/Common.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.19;\n\n// Common.sol\n//\n// Common mathematical functions used in both SD59x18 and UD60x18. Note that these global functions do not\n// always operate with SD59x18 and UD60x18 numbers.\n\n/*//////////////////////////////////////////////////////////////////////////\n                                CUSTOM ERRORS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Thrown when the resultant value in {mulDiv} overflows uint256.\nerror PRBMath_MulDiv_Overflow(uint256 x, uint256 y, uint256 denominator);\n\n/// @notice Thrown when the resultant value in {mulDiv18} overflows uint256.\nerror PRBMath_MulDiv18_Overflow(uint256 x, uint256 y);\n\n/// @notice Thrown when one of the inputs passed to {mulDivSigned} is `type(int256).min`.\nerror PRBMath_MulDivSigned_InputTooSmall();\n\n/// @notice Thrown when the resultant value in {mulDivSigned} overflows int256.\nerror PRBMath_MulDivSigned_Overflow(int256 x, int256 y);\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    CONSTANTS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @dev The maximum value a uint128 number can have.\nuint128 constant MAX_UINT128 = type(uint128).max;\n\n/// @dev The maximum value a uint40 number can have.\nuint40 constant MAX_UINT40 = type(uint40).max;\n\n/// @dev The unit number, which the decimal precision of the fixed-point types.\nuint256 constant UNIT = 1e18;\n\n/// @dev The unit number inverted mod 2^256.\nuint256 constant UNIT_INVERSE = 78156646155174841979727994598816262306175212592076161876661_508869554232690281;\n\n/// @dev The the largest power of two that divides the decimal value of `UNIT`. The logarithm of this value is the least significant\n/// bit in the binary representation of `UNIT`.\nuint256 constant UNIT_LPOTD = 262144;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                    FUNCTIONS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Calculates the binary exponent of x using the binary fraction method.\n/// @dev Has to use 192.64-bit fixed-point numbers. See https://ethereum.stackexchange.com/a/96594/24693.\n/// @param x The exponent as an unsigned 192.64-bit fixed-point number.\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\n/// @custom:smtchecker abstract-function-nondet\nfunction exp2(uint256 x) pure returns (uint256 result) {\n    unchecked {\n        // Start from 0.5 in the 192.64-bit fixed-point format.\n        result = 0x800000000000000000000000000000000000000000000000;\n\n        // The following logic multiplies the result by $\\sqrt{2^{-i}}$ when the bit at position i is 1. Key points:\n        //\n        // 1. Intermediate results will not overflow, as the starting point is 2^191 and all magic factors are under 2^65.\n        // 2. The rationale for organizing the if statements into groups of 8 is gas savings. If the result of performing\n        // a bitwise AND operation between x and any value in the array [0x80; 0x40; 0x20; 0x10; 0x08; 0x04; 0x02; 0x01] is 1,\n        // we know that `x & 0xFF` is also 1.\n        if (x & 0xFF00000000000000 > 0) {\n            if (x & 0x8000000000000000 > 0) {\n                result = (result * 0x16A09E667F3BCC909) >> 64;\n            }\n            if (x & 0x4000000000000000 > 0) {\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\n            }\n            if (x & 0x2000000000000000 > 0) {\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\n            }\n            if (x & 0x1000000000000000 > 0) {\n                result = (result * 0x10B5586CF9890F62A) >> 64;\n            }\n            if (x & 0x800000000000000 > 0) {\n                result = (result * 0x1059B0D31585743AE) >> 64;\n            }\n            if (x & 0x400000000000000 > 0) {\n                result = (result * 0x102C9A3E778060EE7) >> 64;\n            }\n            if (x & 0x200000000000000 > 0) {\n                result = (result * 0x10163DA9FB33356D8) >> 64;\n            }\n            if (x & 0x100000000000000 > 0) {\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\n            }\n        }\n\n        if (x & 0xFF000000000000 > 0) {\n            if (x & 0x80000000000000 > 0) {\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\n            }\n            if (x & 0x40000000000000 > 0) {\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\n            }\n            if (x & 0x20000000000000 > 0) {\n                result = (result * 0x100162F3904051FA1) >> 64;\n            }\n            if (x & 0x10000000000000 > 0) {\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\n            }\n            if (x & 0x8000000000000 > 0) {\n                result = (result * 0x100058BA01FB9F96D) >> 64;\n            }\n            if (x & 0x4000000000000 > 0) {\n                result = (result * 0x10002C5CC37DA9492) >> 64;\n            }\n            if (x & 0x2000000000000 > 0) {\n                result = (result * 0x1000162E525EE0547) >> 64;\n            }\n            if (x & 0x1000000000000 > 0) {\n                result = (result * 0x10000B17255775C04) >> 64;\n            }\n        }\n\n        if (x & 0xFF0000000000 > 0) {\n            if (x & 0x800000000000 > 0) {\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\n            }\n            if (x & 0x400000000000 > 0) {\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\n            }\n            if (x & 0x200000000000 > 0) {\n                result = (result * 0x10000162E43F4F831) >> 64;\n            }\n            if (x & 0x100000000000 > 0) {\n                result = (result * 0x100000B1721BCFC9A) >> 64;\n            }\n            if (x & 0x80000000000 > 0) {\n                result = (result * 0x10000058B90CF1E6E) >> 64;\n            }\n            if (x & 0x40000000000 > 0) {\n                result = (result * 0x1000002C5C863B73F) >> 64;\n            }\n            if (x & 0x20000000000 > 0) {\n                result = (result * 0x100000162E430E5A2) >> 64;\n            }\n            if (x & 0x10000000000 > 0) {\n                result = (result * 0x1000000B172183551) >> 64;\n            }\n        }\n\n        if (x & 0xFF00000000 > 0) {\n            if (x & 0x8000000000 > 0) {\n                result = (result * 0x100000058B90C0B49) >> 64;\n            }\n            if (x & 0x4000000000 > 0) {\n                result = (result * 0x10000002C5C8601CC) >> 64;\n            }\n            if (x & 0x2000000000 > 0) {\n                result = (result * 0x1000000162E42FFF0) >> 64;\n            }\n            if (x & 0x1000000000 > 0) {\n                result = (result * 0x10000000B17217FBB) >> 64;\n            }\n            if (x & 0x800000000 > 0) {\n                result = (result * 0x1000000058B90BFCE) >> 64;\n            }\n            if (x & 0x400000000 > 0) {\n                result = (result * 0x100000002C5C85FE3) >> 64;\n            }\n            if (x & 0x200000000 > 0) {\n                result = (result * 0x10000000162E42FF1) >> 64;\n            }\n            if (x & 0x100000000 > 0) {\n                result = (result * 0x100000000B17217F8) >> 64;\n            }\n        }\n\n        if (x & 0xFF000000 > 0) {\n            if (x & 0x80000000 > 0) {\n                result = (result * 0x10000000058B90BFC) >> 64;\n            }\n            if (x & 0x40000000 > 0) {\n                result = (result * 0x1000000002C5C85FE) >> 64;\n            }\n            if (x & 0x20000000 > 0) {\n                result = (result * 0x100000000162E42FF) >> 64;\n            }\n            if (x & 0x10000000 > 0) {\n                result = (result * 0x1000000000B17217F) >> 64;\n            }\n            if (x & 0x8000000 > 0) {\n                result = (result * 0x100000000058B90C0) >> 64;\n            }\n            if (x & 0x4000000 > 0) {\n                result = (result * 0x10000000002C5C860) >> 64;\n            }\n            if (x & 0x2000000 > 0) {\n                result = (result * 0x1000000000162E430) >> 64;\n            }\n            if (x & 0x1000000 > 0) {\n                result = (result * 0x10000000000B17218) >> 64;\n            }\n        }\n\n        if (x & 0xFF0000 > 0) {\n            if (x & 0x800000 > 0) {\n                result = (result * 0x1000000000058B90C) >> 64;\n            }\n            if (x & 0x400000 > 0) {\n                result = (result * 0x100000000002C5C86) >> 64;\n            }\n            if (x & 0x200000 > 0) {\n                result = (result * 0x10000000000162E43) >> 64;\n            }\n            if (x & 0x100000 > 0) {\n                result = (result * 0x100000000000B1721) >> 64;\n            }\n            if (x & 0x80000 > 0) {\n                result = (result * 0x10000000000058B91) >> 64;\n            }\n            if (x & 0x40000 > 0) {\n                result = (result * 0x1000000000002C5C8) >> 64;\n            }\n            if (x & 0x20000 > 0) {\n                result = (result * 0x100000000000162E4) >> 64;\n            }\n            if (x & 0x10000 > 0) {\n                result = (result * 0x1000000000000B172) >> 64;\n            }\n        }\n\n        if (x & 0xFF00 > 0) {\n            if (x & 0x8000 > 0) {\n                result = (result * 0x100000000000058B9) >> 64;\n            }\n            if (x & 0x4000 > 0) {\n                result = (result * 0x10000000000002C5D) >> 64;\n            }\n            if (x & 0x2000 > 0) {\n                result = (result * 0x1000000000000162E) >> 64;\n            }\n            if (x & 0x1000 > 0) {\n                result = (result * 0x10000000000000B17) >> 64;\n            }\n            if (x & 0x800 > 0) {\n                result = (result * 0x1000000000000058C) >> 64;\n            }\n            if (x & 0x400 > 0) {\n                result = (result * 0x100000000000002C6) >> 64;\n            }\n            if (x & 0x200 > 0) {\n                result = (result * 0x10000000000000163) >> 64;\n            }\n            if (x & 0x100 > 0) {\n                result = (result * 0x100000000000000B1) >> 64;\n            }\n        }\n\n        if (x & 0xFF > 0) {\n            if (x & 0x80 > 0) {\n                result = (result * 0x10000000000000059) >> 64;\n            }\n            if (x & 0x40 > 0) {\n                result = (result * 0x1000000000000002C) >> 64;\n            }\n            if (x & 0x20 > 0) {\n                result = (result * 0x10000000000000016) >> 64;\n            }\n            if (x & 0x10 > 0) {\n                result = (result * 0x1000000000000000B) >> 64;\n            }\n            if (x & 0x8 > 0) {\n                result = (result * 0x10000000000000006) >> 64;\n            }\n            if (x & 0x4 > 0) {\n                result = (result * 0x10000000000000003) >> 64;\n            }\n            if (x & 0x2 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n            if (x & 0x1 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n        }\n\n        // In the code snippet below, two operations are executed simultaneously:\n        //\n        // 1. The result is multiplied by $(2^n + 1)$, where $2^n$ represents the integer part, and the additional 1\n        // accounts for the initial guess of 0.5. This is achieved by subtracting from 191 instead of 192.\n        // 2. The result is then converted to an unsigned 60.18-decimal fixed-point format.\n        //\n        // The underlying logic is based on the relationship $2^{191-ip} = 2^{ip} / 2^{191}$, where $ip$ denotes the,\n        // integer part, $2^n$.\n        result *= UNIT;\n        result >>= (191 - (x >> 64));\n    }\n}\n\n/// @notice Finds the zero-based index of the first 1 in the binary representation of x.\n///\n/// @dev See the note on \"msb\" in this Wikipedia article: https://en.wikipedia.org/wiki/Find_first_set\n///\n/// Each step in this implementation is equivalent to this high-level code:\n///\n/// ```solidity\n/// if (x >= 2 ** 128) {\n///     x >>= 128;\n///     result += 128;\n/// }\n/// ```\n///\n/// Where 128 is replaced with each respective power of two factor. See the full high-level implementation here:\n/// https://gist.github.com/PaulRBerg/f932f8693f2733e30c4d479e8e980948\n///\n/// The Yul instructions used below are:\n///\n/// - \"gt\" is \"greater than\"\n/// - \"or\" is the OR bitwise operator\n/// - \"shl\" is \"shift left\"\n/// - \"shr\" is \"shift right\"\n///\n/// @param x The uint256 number for which to find the index of the most significant bit.\n/// @return result The index of the most significant bit as a uint256.\n/// @custom:smtchecker abstract-function-nondet\nfunction msb(uint256 x) pure returns (uint256 result) {\n    // 2^128\n    assembly (\"memory-safe\") {\n        let factor := shl(7, gt(x, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^64\n    assembly (\"memory-safe\") {\n        let factor := shl(6, gt(x, 0xFFFFFFFFFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^32\n    assembly (\"memory-safe\") {\n        let factor := shl(5, gt(x, 0xFFFFFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^16\n    assembly (\"memory-safe\") {\n        let factor := shl(4, gt(x, 0xFFFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^8\n    assembly (\"memory-safe\") {\n        let factor := shl(3, gt(x, 0xFF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^4\n    assembly (\"memory-safe\") {\n        let factor := shl(2, gt(x, 0xF))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^2\n    assembly (\"memory-safe\") {\n        let factor := shl(1, gt(x, 0x3))\n        x := shr(factor, x)\n        result := or(result, factor)\n    }\n    // 2^1\n    // No need to shift x any more.\n    assembly (\"memory-safe\") {\n        let factor := gt(x, 0x1)\n        result := or(result, factor)\n    }\n}\n\n/// @notice Calculates x*y÷denominator with 512-bit precision.\n///\n/// @dev Credits to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n///\n/// Notes:\n/// - The result is rounded toward zero.\n///\n/// Requirements:\n/// - The denominator must not be zero.\n/// - The result must fit in uint256.\n///\n/// @param x The multiplicand as a uint256.\n/// @param y The multiplier as a uint256.\n/// @param denominator The divisor as a uint256.\n/// @return result The result as a uint256.\n/// @custom:smtchecker abstract-function-nondet\nfunction mulDiv(uint256 x, uint256 y, uint256 denominator) pure returns (uint256 result) {\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n    // use the Chinese Remainder Theorem to reconstruct the 512-bit result. The result is stored in two 256\n    // variables such that product = prod1 * 2^256 + prod0.\n    uint256 prod0; // Least significant 256 bits of the product\n    uint256 prod1; // Most significant 256 bits of the product\n    assembly (\"memory-safe\") {\n        let mm := mulmod(x, y, not(0))\n        prod0 := mul(x, y)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    // Handle non-overflow cases, 256 by 256 division.\n    if (prod1 == 0) {\n        unchecked {\n            return prod0 / denominator;\n        }\n    }\n\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\n    if (prod1 >= denominator) {\n        revert PRBMath_MulDiv_Overflow(x, y, denominator);\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n    // 512 by 256 division\n    ////////////////////////////////////////////////////////////////////////////\n\n    // Make division exact by subtracting the remainder from [prod1 prod0].\n    uint256 remainder;\n    assembly (\"memory-safe\") {\n        // Compute remainder using the mulmod Yul instruction.\n        remainder := mulmod(x, y, denominator)\n\n        // Subtract 256 bit number from 512-bit number.\n        prod1 := sub(prod1, gt(remainder, prod0))\n        prod0 := sub(prod0, remainder)\n    }\n\n    unchecked {\n        // Calculate the largest power of two divisor of the denominator using the unary operator ~. This operation cannot overflow\n        // because the denominator cannot be zero at this point in the function execution. The result is always >= 1.\n        // For more detail, see https://cs.stackexchange.com/q/138556/92363.\n        uint256 lpotdod = denominator & (~denominator + 1);\n        uint256 flippedLpotdod;\n\n        assembly (\"memory-safe\") {\n            // Factor powers of two out of denominator.\n            denominator := div(denominator, lpotdod)\n\n            // Divide [prod1 prod0] by lpotdod.\n            prod0 := div(prod0, lpotdod)\n\n            // Get the flipped value `2^256 / lpotdod`. If the `lpotdod` is zero, the flipped value is one.\n            // `sub(0, lpotdod)` produces the two's complement version of `lpotdod`, which is equivalent to flipping all the bits.\n            // However, `div` interprets this value as an unsigned value: https://ethereum.stackexchange.com/q/147168/24693\n            flippedLpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n        }\n\n        // Shift in bits from prod1 into prod0.\n        prod0 |= prod1 * flippedLpotdod;\n\n        // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n        // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n        // four bits. That is, denominator * inv = 1 mod 2^4.\n        uint256 inverse = (3 * denominator) ^ 2;\n\n        // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n        // in modular arithmetic, doubling the correct bits in each step.\n        inverse *= 2 - denominator * inverse; // inverse mod 2^8\n        inverse *= 2 - denominator * inverse; // inverse mod 2^16\n        inverse *= 2 - denominator * inverse; // inverse mod 2^32\n        inverse *= 2 - denominator * inverse; // inverse mod 2^64\n        inverse *= 2 - denominator * inverse; // inverse mod 2^128\n        inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n        // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n        // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n        // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inverse;\n    }\n}\n\n/// @notice Calculates x*y÷1e18 with 512-bit precision.\n///\n/// @dev A variant of {mulDiv} with constant folding, i.e. in which the denominator is hard coded to 1e18.\n///\n/// Notes:\n/// - The body is purposely left uncommented; to understand how this works, see the documentation in {mulDiv}.\n/// - The result is rounded toward zero.\n/// - We take as an axiom that the result cannot be `MAX_UINT256` when x and y solve the following system of equations:\n///\n/// $$\n/// \\begin{cases}\n///     x * y = MAX\\_UINT256 * UNIT \\\\\n///     (x * y) \\% UNIT \\geq \\frac{UNIT}{2}\n/// \\end{cases}\n/// $$\n///\n/// Requirements:\n/// - Refer to the requirements in {mulDiv}.\n/// - The result must fit in uint256.\n///\n/// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n/// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\n/// @custom:smtchecker abstract-function-nondet\nfunction mulDiv18(uint256 x, uint256 y) pure returns (uint256 result) {\n    uint256 prod0;\n    uint256 prod1;\n    assembly (\"memory-safe\") {\n        let mm := mulmod(x, y, not(0))\n        prod0 := mul(x, y)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    if (prod1 == 0) {\n        unchecked {\n            return prod0 / UNIT;\n        }\n    }\n\n    if (prod1 >= UNIT) {\n        revert PRBMath_MulDiv18_Overflow(x, y);\n    }\n\n    uint256 remainder;\n    assembly (\"memory-safe\") {\n        remainder := mulmod(x, y, UNIT)\n        result :=\n            mul(\n                or(\n                    div(sub(prod0, remainder), UNIT_LPOTD),\n                    mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, UNIT_LPOTD), UNIT_LPOTD), 1))\n                ),\n                UNIT_INVERSE\n            )\n    }\n}\n\n/// @notice Calculates x*y÷denominator with 512-bit precision.\n///\n/// @dev This is an extension of {mulDiv} for signed numbers, which works by computing the signs and the absolute values separately.\n///\n/// Notes:\n/// - The result is rounded toward zero.\n///\n/// Requirements:\n/// - Refer to the requirements in {mulDiv}.\n/// - None of the inputs can be `type(int256).min`.\n/// - The result must fit in int256.\n///\n/// @param x The multiplicand as an int256.\n/// @param y The multiplier as an int256.\n/// @param denominator The divisor as an int256.\n/// @return result The result as an int256.\n/// @custom:smtchecker abstract-function-nondet\nfunction mulDivSigned(int256 x, int256 y, int256 denominator) pure returns (int256 result) {\n    if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\n        revert PRBMath_MulDivSigned_InputTooSmall();\n    }\n\n    // Get hold of the absolute values of x, y and the denominator.\n    uint256 xAbs;\n    uint256 yAbs;\n    uint256 dAbs;\n    unchecked {\n        xAbs = x < 0 ? uint256(-x) : uint256(x);\n        yAbs = y < 0 ? uint256(-y) : uint256(y);\n        dAbs = denominator < 0 ? uint256(-denominator) : uint256(denominator);\n    }\n\n    // Compute the absolute value of x*y÷denominator. The result must fit in int256.\n    uint256 resultAbs = mulDiv(xAbs, yAbs, dAbs);\n    if (resultAbs > uint256(type(int256).max)) {\n        revert PRBMath_MulDivSigned_Overflow(x, y);\n    }\n\n    // Get the signs of x, y and the denominator.\n    uint256 sx;\n    uint256 sy;\n    uint256 sd;\n    assembly (\"memory-safe\") {\n        // \"sgt\" is the \"signed greater than\" assembly instruction and \"sub(0,1)\" is -1 in two's complement.\n        sx := sgt(x, sub(0, 1))\n        sy := sgt(y, sub(0, 1))\n        sd := sgt(denominator, sub(0, 1))\n    }\n\n    // XOR over sx, sy and sd. What this does is to check whether there are 1 or 3 negative signs in the inputs.\n    // If there are, the result should be negative. Otherwise, it should be positive.\n    unchecked {\n        result = sx ^ sy ^ sd == 0 ? -int256(resultAbs) : int256(resultAbs);\n    }\n}\n\n/// @notice Calculates the square root of x using the Babylonian method.\n///\n/// @dev See https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n///\n/// Notes:\n/// - If x is not a perfect square, the result is rounded down.\n/// - Credits to OpenZeppelin for the explanations in comments below.\n///\n/// @param x The uint256 number for which to calculate the square root.\n/// @return result The result as a uint256.\n/// @custom:smtchecker abstract-function-nondet\nfunction sqrt(uint256 x) pure returns (uint256 result) {\n    if (x == 0) {\n        return 0;\n    }\n\n    // For our first guess, we calculate the biggest power of 2 which is smaller than the square root of x.\n    //\n    // We know that the \"msb\" (most significant bit) of x is a power of 2 such that we have:\n    //\n    // $$\n    // msb(x) <= x <= 2*msb(x)$\n    // $$\n    //\n    // We write $msb(x)$ as $2^k$, and we get:\n    //\n    // $$\n    // k = log_2(x)\n    // $$\n    //\n    // Thus, we can write the initial inequality as:\n    //\n    // $$\n    // 2^{log_2(x)} <= x <= 2*2^{log_2(x)+1} \\\\\n    // sqrt(2^k) <= sqrt(x) < sqrt(2^{k+1}) \\\\\n    // 2^{k/2} <= sqrt(x) < 2^{(k+1)/2} <= 2^{(k/2)+1}\n    // $$\n    //\n    // Consequently, $2^{log_2(x) /2} is a good first approximation of sqrt(x) with at least one correct bit.\n    uint256 xAux = uint256(x);\n    result = 1;\n    if (xAux >= 2 ** 128) {\n        xAux >>= 128;\n        result <<= 64;\n    }\n    if (xAux >= 2 ** 64) {\n        xAux >>= 64;\n        result <<= 32;\n    }\n    if (xAux >= 2 ** 32) {\n        xAux >>= 32;\n        result <<= 16;\n    }\n    if (xAux >= 2 ** 16) {\n        xAux >>= 16;\n        result <<= 8;\n    }\n    if (xAux >= 2 ** 8) {\n        xAux >>= 8;\n        result <<= 4;\n    }\n    if (xAux >= 2 ** 4) {\n        xAux >>= 4;\n        result <<= 2;\n    }\n    if (xAux >= 2 ** 2) {\n        result <<= 1;\n    }\n\n    // At this point, `result` is an estimation with at least one bit of precision. We know the true value has at\n    // most 128 bits, since it is the square root of a uint256. Newton's method converges quadratically (precision\n    // doubles at every iteration). We thus need at most 7 iteration to turn our partial result with one bit of\n    // precision into the expected uint128 result.\n    unchecked {\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n        result = (result + x / result) >> 1;\n\n        // If x is not a perfect square, round the result toward zero.\n        uint256 roundedResult = x / result;\n        if (result >= roundedResult) {\n            result = roundedResult;\n        }\n    }\n}\n"
			},
			"src/JBRulesets.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {mulDiv} from \"@prb/math/src/Common.sol\";\n\nimport {JBControlled} from \"./abstract/JBControlled.sol\";\nimport {JBApprovalStatus} from \"./enums/JBApprovalStatus.sol\";\nimport {IJBDirectory} from \"./interfaces/IJBDirectory.sol\";\nimport {IJBRulesetApprovalHook} from \"./interfaces/IJBRulesetApprovalHook.sol\";\nimport {IJBRulesets} from \"./interfaces/IJBRulesets.sol\";\nimport {JBConstants} from \"./libraries/JBConstants.sol\";\nimport {JBRuleset} from \"./structs/JBRuleset.sol\";\nimport {JBRulesetWeightCache} from \"./structs/JBRulesetWeightCache.sol\";\n\n/// @notice Manages rulesets and queuing.\n/// @dev Rulesets dictate how a project behaves for a period of time. To learn more about their functionality, see the\n/// `JBRuleset` data structure.\n/// @dev Throughout this contract, `rulesetId` is an identifier for each ruleset. The `rulesetId` is the unix timestamp\n/// when the ruleset was initialized.\n/// @dev `approvable` means a ruleset which may or may not be approved.\ncontract JBRulesets is JBControlled, IJBRulesets {\n    //*********************************************************************//\n    // --------------------------- custom errors ------------------------- //\n    //*********************************************************************//\n    error INVALID_RULESET_APPROVAL_HOOK();\n    error INVALID_DECAY_RATE();\n    error INVALID_RULESET_DURATION();\n    error INVALID_RULESET_END_TIME();\n    error INVALID_WEIGHT();\n\n    //*********************************************************************//\n    // ------------------------- internal constants ----------------------- //\n    //*********************************************************************//\n\n    /// @notice The maximum number of decay rate multiples that can be cached at a time.\n    uint256 internal constant _MAX_DECAY_MULTIPLE_CACHE_THRESHOLD = 50_000;\n\n    /// @notice The number of decay rate multiples before a cached value is sought.\n    uint256 internal constant _DECAY_MULTIPLE_CACHE_LOOKUP_THRESHOLD = 1000;\n\n    //*********************************************************************//\n    // --------------------- public stored properties -------------------- //\n    //*********************************************************************//\n\n    /// @notice The ID of the ruleset with the latest start time for a specific project, whether the ruleset has been\n    /// approved or not.\n    /// @dev If a project has multiple rulesets queued, the `latestRulesetIdOf` will be the last one. This is the\n    /// \"changeable\" cycle.\n    /// @custom:param projectId The ID of the project to get the latest ruleset ID of.\n    /// @return latestRulesetIdOf The `rulesetId` of the project's latest ruleset.\n    mapping(uint256 projectId => uint256) public override latestRulesetIdOf;\n\n    //*********************************************************************//\n    // --------------------- internal stored properties ------------------- //\n    //*********************************************************************//\n\n    /// @notice The user-defined properties of each ruleset, packed into one storage slot.\n    /// @custom:param projectId The ID of the project to get the user-defined properties of.\n    /// @custom:param rulesetId The ID of the ruleset to get the user-defined properties of.\n    mapping(uint256 projectId => mapping(uint256 rulesetId => uint256)) internal _packedUserPropertiesOf;\n\n    /// @notice The mechanism-added properties to manage and schedule each ruleset, packed into one storage slot.\n    /// @custom:param projectId The ID of the project to get the intrinsic properties of.\n    /// @custom:param rulesetId The ID of the ruleset to get the intrinsic properties of.\n    mapping(uint256 projectId => mapping(uint256 rulesetId => uint256)) internal _packedIntrinsicPropertiesOf;\n\n    /// @notice The metadata for each ruleset, packed into one storage slot.\n    /// @custom:param projectId The ID of the project to get metadata of.\n    /// @custom:param rulesetId The ID of the ruleset to get metadata of.\n    mapping(uint256 projectId => mapping(uint256 rulesetId => uint256)) internal _metadataOf;\n\n    /// @notice Cached weight values to derive rulesets from.\n    /// @custom:param projectId The ID of the project to which the cache applies.\n    /// @custom:param rulesetId The ID of the ruleset to which the cache applies.\n    mapping(uint256 projectId => mapping(uint256 rulesetId => JBRulesetWeightCache)) internal _weightCacheOf;\n\n    //*********************************************************************//\n    // ------------------------- external views -------------------------- //\n    //*********************************************************************//\n\n    /// @notice Get the ruleset struct for a given `rulesetId` and `projectId`.\n    /// @param projectId The ID of the project to which the ruleset belongs.\n    /// @param rulesetId The ID of the ruleset to get the struct of.\n    /// @return ruleset The ruleset struct.\n    function getRulesetOf(\n        uint256 projectId,\n        uint256 rulesetId\n    )\n        external\n        view\n        override\n        returns (JBRuleset memory ruleset)\n    {\n        return _getStructFor(projectId, rulesetId);\n    }\n\n    /// @notice The latest ruleset queued for a project. Returns the ruleset's struct and its current approval status.\n    /// @dev Returns struct and status for the ruleset initialized furthest in the future (at the end of the rulset\n    /// queue).\n    /// @param projectId The ID of the project to get the latest queued ruleset of.\n    /// @return ruleset The project's latest queued ruleset's struct.\n    /// @return approvalStatus The approval hook's status for the ruleset.\n    function latestQueuedRulesetOf(uint256 projectId)\n        external\n        view\n        override\n        returns (JBRuleset memory ruleset, JBApprovalStatus approvalStatus)\n    {\n        // Get a reference to the latest ruleset's ID.\n        uint256 rulesetId = latestRulesetIdOf[projectId];\n\n        // Resolve the struct for the latest ruleset.\n        ruleset = _getStructFor(projectId, rulesetId);\n\n        // Resolve the approval status.\n        approvalStatus = _approvalStatusOf({\n            projectId: projectId,\n            rulesetId: ruleset.id,\n            start: ruleset.start,\n            approvalHookRulesetId: ruleset.basedOnId\n        });\n    }\n\n    /// @notice Get an array of a project's rulesets up to a maximum array size, sorted from latest to earliest.\n    /// @param projectId The ID of the project to get the rulesets of.\n    /// @param startingId The ID of the ruleset to begin with. This will be the latest ruleset in the result. If 0 is\n    /// passed, the project's latest ruleset will be used.\n    /// @param size The maximum number of rulesets to return.\n    /// @return rulesets The rulesets as an array of `JBRuleset` structs.\n    function rulesetsOf(\n        uint256 projectId,\n        uint256 startingId,\n        uint256 size\n    )\n        external\n        view\n        override\n        returns (JBRuleset[] memory rulesets)\n    {\n        // If no starting ID was provided, set it to the latest ruleset's ID.\n        if (startingId == 0) startingId = latestRulesetIdOf[projectId];\n\n        // Keep a reference to the number of rulesets being returned.\n        uint256 count = 0;\n\n        // Keep a reference to the starting ruleset.\n        JBRuleset memory ruleset = _getStructFor(projectId, startingId);\n\n        // First, count the number of rulesets to include in the result by iterating backwards from the starting\n        // ruleset.\n        while (ruleset.id != 0 && count < size) {\n            // Increment the counter.\n            count++;\n\n            // Iterate to the ruleset it was based on.\n            ruleset = _getStructFor(projectId, ruleset.basedOnId);\n        }\n\n        // Keep a reference to the array of rulesets that'll be populated.\n        rulesets = new JBRuleset[](count);\n\n        // Return an empty array if there are no rulesets to return.\n        if (count == 0) {\n            return rulesets;\n        }\n\n        // Reset the ruleset being iterated on to the starting ruleset.\n        ruleset = _getStructFor(projectId, startingId);\n\n        // Set the counter.\n        uint256 i;\n\n        // Populate the array of rulesets to return.\n        while (i < count) {\n            // Add the ruleset to the array.\n            rulesets[i++] = ruleset;\n\n            // Get the ruleset it was based on if needed.\n            if (i != count) ruleset = _getStructFor(projectId, ruleset.basedOnId);\n        }\n    }\n\n    /// @notice The ruleset that's up next for a project.\n    /// @dev If an upcoming ruleset is not found for the project, returns an empty ruleset with all properties set to 0.\n    /// @param projectId The ID of the project to get the upcoming ruleset of.\n    /// @return ruleset The struct for the project's upcoming ruleset.\n    function upcomingOf(uint256 projectId) external view override returns (JBRuleset memory ruleset) {\n        // If the project does not have a latest ruleset, return an empty struct.\n        // slither-disable-next-line incorrect-equality\n        if (latestRulesetIdOf[projectId] == 0) return _getStructFor(0, 0);\n\n        // Get a reference to the upcoming approvable ruleset's ID.\n        uint256 upcomingApprovableRulesetId = _upcomingApprovableRulesetIdOf(projectId);\n\n        // Keep a reference to its approval status.\n        JBApprovalStatus approvalStatus;\n\n        // If an upcoming approvable ruleset has been queued, and it's approval status is Approved or ApprovalExpected,\n        // return its ruleset struct\n        if (upcomingApprovableRulesetId != 0) {\n            ruleset = _getStructFor(projectId, upcomingApprovableRulesetId);\n\n            // Get a reference to the approval status.\n            approvalStatus = _approvalStatusOf(projectId, ruleset);\n\n            // If the approval hook is empty, expects approval, or has approved the ruleset, return it.\n            if (\n                approvalStatus == JBApprovalStatus.Approved || approvalStatus == JBApprovalStatus.ApprovalExpected\n                    || approvalStatus == JBApprovalStatus.Empty\n            ) return ruleset;\n\n            // Resolve the ruleset for the ruleset the upcoming approvable ruleset was based on.\n            ruleset = _getStructFor(projectId, ruleset.basedOnId);\n        } else {\n            // Resolve the ruleset for the latest queued ruleset.\n            ruleset = _getStructFor(projectId, latestRulesetIdOf[projectId]);\n\n            // If the latest ruleset starts in the future, it must start in the distant future\n            // Since its not the upcoming approvable ruleset. In this case, base the upcoming ruleset on the base\n            // ruleset.\n            while (ruleset.start > block.timestamp) {\n                ruleset = _getStructFor(projectId, ruleset.basedOnId);\n            }\n        }\n\n        // There's no queued if the current has a duration of 0.\n        if (ruleset.duration == 0) return _getStructFor(0, 0);\n\n        // Get a reference to the approval status.\n        approvalStatus = _approvalStatusOf(projectId, ruleset);\n\n        // Check to see if this ruleset's approval hook hasn't failed.\n        // If so, return a ruleset based on it.\n        if (approvalStatus == JBApprovalStatus.Approved || approvalStatus == JBApprovalStatus.Empty) {\n            return _simulateCycledRulesetBasedOn({projectId: projectId, baseRuleset: ruleset, allowMidRuleset: false});\n        }\n\n        // Get the ruleset of its base ruleset, which carries the last approved configuration.\n        ruleset = _getStructFor(projectId, ruleset.basedOnId);\n\n        // There's no queued if the base, which must still be the current, has a duration of 0.\n        if (ruleset.duration == 0) return _getStructFor(0, 0);\n\n        // Return a simulated cycled ruleset.\n        return _simulateCycledRulesetBasedOn({projectId: projectId, baseRuleset: ruleset, allowMidRuleset: false});\n    }\n\n    /// @notice The ruleset that is currently active for the specified project.\n    /// @dev If a current ruleset of the project is not found, returns an empty ruleset with all properties set to 0.\n    /// @param projectId The ID of the project to get the current ruleset of.\n    /// @return ruleset The project's current ruleset.\n    function currentOf(uint256 projectId) external view override returns (JBRuleset memory ruleset) {\n        // If the project does not have a ruleset, return an empty struct.\n        // slither-disable-next-line incorrect-equality\n        if (latestRulesetIdOf[projectId] == 0) return _getStructFor(0, 0);\n\n        // Get a reference to the currently approvable ruleset's ID.\n        uint256 rulesetId = _currentlyApprovableRulesetIdOf(projectId);\n\n        // If a currently approvable ruleset exists...\n        if (rulesetId != 0) {\n            // Resolve the struct for the currently approvable ruleset.\n            ruleset = _getStructFor(projectId, rulesetId);\n\n            // Get a reference to the approval status.\n            JBApprovalStatus approvalStatus = _approvalStatusOf(projectId, ruleset);\n\n            // Check to see if this ruleset's approval hook is approved if it exists.\n            // If so, return it.\n            if (approvalStatus == JBApprovalStatus.Approved || approvalStatus == JBApprovalStatus.Empty) {\n                return ruleset;\n            }\n\n            // If it hasn't been approved, set the ruleset configuration to be the configuration of the ruleset that\n            // it's based on,\n            // which carries the last approved configuration.\n            rulesetId = ruleset.basedOnId;\n\n            // Keep a reference to its ruleset.\n            ruleset = _getStructFor(projectId, rulesetId);\n        } else {\n            // No upcoming ruleset found that is currently approvable,\n            // so use the latest ruleset ID.\n            rulesetId = latestRulesetIdOf[projectId];\n\n            // Get the struct for the latest ID.\n            ruleset = _getStructFor(projectId, rulesetId);\n\n            // Get a reference to the approval status.\n            JBApprovalStatus approvalStatus = _approvalStatusOf(projectId, ruleset);\n\n            // While the ruleset has a approval hook that isn't approved or if it hasn't yet started, get a reference to\n            // the ruleset that the latest is based on, which has the latest approved configuration.\n            while (\n                (approvalStatus != JBApprovalStatus.Approved && approvalStatus != JBApprovalStatus.Empty)\n                    || block.timestamp < ruleset.start\n            ) {\n                rulesetId = ruleset.basedOnId;\n                ruleset = _getStructFor(projectId, rulesetId);\n                approvalStatus = _approvalStatusOf(projectId, ruleset);\n            }\n        }\n\n        // If the base has no duration, it's still the current one.\n        if (ruleset.duration == 0) return ruleset;\n\n        // Return a simulation of the current ruleset.\n        return _simulateCycledRulesetBasedOn({projectId: projectId, baseRuleset: ruleset, allowMidRuleset: true});\n    }\n\n    /// @notice The current approval status of a given project's latest ruleset.\n    /// @param projectId The ID of the project to check the approval status of.\n    /// @return The project's current approval status.\n    function currentApprovalStatusForLatestRulesetOf(uint256 projectId)\n        external\n        view\n        override\n        returns (JBApprovalStatus)\n    {\n        // Get a reference to the latest ruleset ID.\n        uint256 rulesetId = latestRulesetIdOf[projectId];\n\n        // Resolve the struct for the latest ruleset.\n        JBRuleset memory ruleset = _getStructFor(projectId, rulesetId);\n\n        return _approvalStatusOf({\n            projectId: projectId,\n            rulesetId: ruleset.id,\n            start: ruleset.start,\n            approvalHookRulesetId: ruleset.basedOnId\n        });\n    }\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param directory A contract storing directories of terminals and controllers for each project.\n    // solhint-disable-next-line no-empty-blocks\n    constructor(IJBDirectory directory) JBControlled(directory) {}\n\n    //*********************************************************************//\n    // ---------------------- external transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice Queues the upcoming approvable ruleset for the specified project.\n    /// @dev Only a project's current controller can queue its rulesets.\n    /// @param projectId The ID of the project the ruleset is being queued for.\n    /// @param duration The number of seconds the ruleset lasts for, after which a new ruleset will start. A\n    /// duration of 0 means that the ruleset will stay active until the project owner explicitly issues a\n    /// reconfiguration,\n    /// at which point a new ruleset will immediately start with the updated properties. If the duration is greater than\n    /// 0,\n    /// a project owner cannot make changes to a ruleset's parameters while it is active – any proposed changes will\n    /// apply\n    /// to the subsequent ruleset. If no changes are proposed, a ruleset rolls over to another one with the same\n    /// properties\n    /// but new `start` timestamp and a decayed `weight`.\n    /// @param weight A fixed point number with 18 decimals that contracts can use to base arbitrary calculations\n    /// on. For example, payment terminals can use this to determine how many tokens should be minted when a payment is\n    /// received.\n    /// @param decayRate A percent by how much the `weight` of the subsequent ruleset should be reduced, if the\n    /// project owner hasn't queued the subsequent ruleset with an explicit `weight`. If it's 0, each ruleset will have\n    /// equal weight. If the number is 90%, the next ruleset will have a 10% smaller weight. This weight is out of\n    /// `JBConstants.MAX_DECAY_RATE`.\n    /// @param approvalHook An address of a contract that says whether a proposed ruleset should be accepted or\n    /// rejected. It\n    /// can be used to create rules around how a project owner can change ruleset parameters over time.\n    /// @param metadata Arbitrary extra data to associate with this ruleset. This metadata is not used by `JBRulesets`.\n    /// @param mustStartAtOrAfter The earliest time the ruleset can start. The ruleset cannot start before this\n    /// timestamp.\n    /// @return The struct of the new ruleset.\n    function queueFor(\n        uint256 projectId,\n        uint256 duration,\n        uint256 weight,\n        uint256 decayRate,\n        IJBRulesetApprovalHook approvalHook,\n        uint256 metadata,\n        uint256 mustStartAtOrAfter\n    )\n        external\n        override\n        onlyControllerOf(projectId)\n        returns (JBRuleset memory)\n    {\n        // Duration must fit in a uint32.\n        if (duration > type(uint32).max) revert INVALID_RULESET_DURATION();\n\n        // Decay rate must be less than or equal to 100%.\n        if (decayRate > JBConstants.MAX_DECAY_RATE) {\n            revert INVALID_DECAY_RATE();\n        }\n\n        // Weight must fit into a uint88.\n        if (weight > type(uint88).max) revert INVALID_WEIGHT();\n\n        // If the start date is not set, set it to be the current timestamp.\n        if (mustStartAtOrAfter == 0) {\n            mustStartAtOrAfter = block.timestamp;\n        }\n\n        // Make sure the min start date fits in a uint56, and that the start date of the following ruleset will also fit\n        // within the max.\n        if (mustStartAtOrAfter + duration > type(uint56).max) {\n            revert INVALID_RULESET_END_TIME();\n        }\n\n        // Approval hook should be a valid contract, supporting the correct interface\n        if (approvalHook != IJBRulesetApprovalHook(address(0))) {\n            // Revert if there isn't a contract at the address\n            if (address(approvalHook).code.length == 0) revert INVALID_RULESET_APPROVAL_HOOK();\n\n            // Make sure the approval hook supports the expected interface.\n            try approvalHook.supportsInterface(type(IJBRulesetApprovalHook).interfaceId) returns (bool doesSupport) {\n                if (!doesSupport) revert INVALID_RULESET_APPROVAL_HOOK(); // Contract exists at the address but with the\n                    // wrong interface\n            } catch {\n                revert INVALID_RULESET_APPROVAL_HOOK(); // No ERC165 support\n            }\n        }\n\n        // Get a reference to the latest ruleset's ID.\n        uint256 latestId = latestRulesetIdOf[projectId];\n\n        // The new rulesetId timestamp is now, or an increment from now if the current timestamp is taken.\n        uint256 rulesetId = latestId >= block.timestamp ? latestId + 1 : block.timestamp;\n\n        // Set up the ruleset by configuring intrinsic properties.\n        _configureIntrinsicPropertiesFor(projectId, rulesetId, weight, mustStartAtOrAfter);\n\n        // Efficiently stores the ruleset's user-defined properties.\n        // If all user config properties are zero, no need to store anything as the default value will have the same\n        // outcome.\n        if (approvalHook != IJBRulesetApprovalHook(address(0)) || duration > 0 || decayRate > 0) {\n            // approval hook in bits 0-159 bytes.\n            uint256 packed = uint160(address(approvalHook));\n\n            // duration in bits 160-191 bytes.\n            packed |= duration << 160;\n\n            // decayRate in bits 192-223 bytes.\n            packed |= decayRate << 192;\n\n            // Set in storage.\n            _packedUserPropertiesOf[projectId][rulesetId] = packed;\n        }\n\n        // Set the metadata if needed.\n        if (metadata > 0) _metadataOf[projectId][rulesetId] = metadata;\n\n        emit RulesetQueued(\n            rulesetId, projectId, duration, weight, decayRate, approvalHook, metadata, mustStartAtOrAfter, msg.sender\n        );\n\n        // Return the struct for the new ruleset's ID.\n        return _getStructFor(projectId, rulesetId);\n    }\n\n    /// @notice Cache the value of the ruleset weight.\n    /// @param projectId The ID of the project having its ruleset weight cached.\n    function updateRulesetWeightCache(uint256 projectId) external override {\n        // Keep a reference to the struct for the latest queued ruleset.\n        // The cached value will be based on this struct.\n        JBRuleset memory latestQueuedRuleset = _getStructFor(projectId, latestRulesetIdOf[projectId]);\n\n        // Nothing to cache if the latest ruleset doesn't have a duration or a decay rate.\n        if (latestQueuedRuleset.duration == 0 || latestQueuedRuleset.decayRate == 0) return;\n\n        // Get a reference to the current cache.\n        JBRulesetWeightCache storage cache = _weightCacheOf[projectId][latestQueuedRuleset.id];\n\n        // Determine the largest start timestamp the cache can be filled to.\n        uint256 maxStart = latestQueuedRuleset.start\n            + (cache.decayMultiple + _MAX_DECAY_MULTIPLE_CACHE_THRESHOLD) * latestQueuedRuleset.duration;\n\n        // Determine the start timestamp to derive a weight from for the cache.\n        uint256 start = block.timestamp < maxStart ? block.timestamp : maxStart;\n\n        // The difference between the start of the latest queued ruleset and the start of the ruleset we're caching the\n        // weight of.\n        uint256 startDistance = start - latestQueuedRuleset.start;\n\n        // Calculate the decay multiple.\n        uint256 decayMultiple;\n        unchecked {\n            decayMultiple = startDistance / latestQueuedRuleset.duration;\n        }\n\n        // Store the new values.\n        cache.weight = _deriveWeightFrom({projectId: projectId, baseRuleset: latestQueuedRuleset, start: start});\n        cache.decayMultiple = decayMultiple;\n    }\n\n    //*********************************************************************//\n    // --------------------- internal helper functions ------------------- //\n    //*********************************************************************//\n\n    /// @notice Updates the latest ruleset for this project if it exists. If there is no ruleset, initializes one.\n    /// @param projectId The ID of the project to update the latest ruleset for.\n    /// @param rulesetId The timestamp of when the ruleset was queued.\n    /// @param weight The weight to store in the queued ruleset.\n    /// @param mustStartAtOrAfter The earliest time the ruleset can start. The ruleset cannot start before this\n    /// timestamp.\n    function _configureIntrinsicPropertiesFor(\n        uint256 projectId,\n        uint256 rulesetId,\n        uint256 weight,\n        uint256 mustStartAtOrAfter\n    )\n        internal\n    {\n        // Keep a reference to the project's latest ruleset's ID.\n        uint256 latestId = latestRulesetIdOf[projectId];\n\n        // If the project doesn't have a ruleset yet, initialize one.\n        // slither-disable-next-line incorrect-equality\n        if (latestId == 0) {\n            // Use an empty ruleset as the base.\n            return _initializeRulesetFor({\n                projectId: projectId,\n                baseRuleset: _getStructFor(0, 0),\n                rulesetId: rulesetId,\n                mustStartAtOrAfter: mustStartAtOrAfter,\n                weight: weight\n            });\n        }\n\n        // Get a reference to the latest ruleset's struct.\n        JBRuleset memory baseRuleset = _getStructFor(projectId, latestId);\n\n        // Get a reference to the approval status.\n        JBApprovalStatus approvalStatus = _approvalStatusOf(projectId, baseRuleset);\n\n        // If the base ruleset has started but wasn't approved if a approval hook exists\n        // OR it hasn't started but is currently approved\n        // OR it hasn't started but it is likely to be approved and takes place before the proposed one,\n        // set the struct to be the ruleset it's based on, which carries the latest approved ruleset.\n        if (\n            (\n                block.timestamp >= baseRuleset.start && approvalStatus != JBApprovalStatus.Approved\n                    && approvalStatus != JBApprovalStatus.Empty\n            )\n                || (\n                    block.timestamp < baseRuleset.start && mustStartAtOrAfter < baseRuleset.start + baseRuleset.duration\n                        && approvalStatus != JBApprovalStatus.Approved\n                )\n                || (\n                    block.timestamp < baseRuleset.start && mustStartAtOrAfter >= baseRuleset.start + baseRuleset.duration\n                        && approvalStatus != JBApprovalStatus.Approved && approvalStatus != JBApprovalStatus.ApprovalExpected\n                        && approvalStatus != JBApprovalStatus.Empty\n                )\n        ) {\n            baseRuleset = _getStructFor(projectId, baseRuleset.basedOnId);\n        }\n\n        // The time when the duration of the base ruleset's approval hook has finished.\n        // If the provided ruleset has no approval hook, return the current timestamp.\n        uint256 timestampAfterApprovalHook = baseRuleset.approvalHook == IJBRulesetApprovalHook(address(0))\n            ? 0\n            : rulesetId + baseRuleset.approvalHook.DURATION();\n\n        _initializeRulesetFor({\n            projectId: projectId,\n            baseRuleset: baseRuleset,\n            rulesetId: rulesetId,\n            // Can only start after the approval hook.\n            mustStartAtOrAfter: timestampAfterApprovalHook > mustStartAtOrAfter\n                ? timestampAfterApprovalHook\n                : mustStartAtOrAfter,\n            weight: weight\n        });\n    }\n\n    /// @notice Initializes a ruleset with the specified properties.\n    /// @param projectId The ID of the project to initialize the ruleset for.\n    /// @param baseRuleset The ruleset struct to base the newly initialized one on.\n    /// @param rulesetId The `rulesetId` for the ruleset being initialized.\n    /// @param mustStartAtOrAfter The earliest time the ruleset can start. The ruleset cannot start before this\n    /// timestamp.\n    /// @param weight The weight to give the newly initialized ruleset.\n    function _initializeRulesetFor(\n        uint256 projectId,\n        JBRuleset memory baseRuleset,\n        uint256 rulesetId,\n        uint256 mustStartAtOrAfter,\n        uint256 weight\n    )\n        internal\n    {\n        // If there is no base, initialize a first ruleset.\n        if (baseRuleset.cycleNumber == 0) {\n            // Set fresh intrinsic properties.\n            _packAndStoreIntrinsicPropertiesOf({\n                rulesetId: rulesetId,\n                projectId: projectId,\n                rulesetCycleNumber: 1,\n                weight: weight,\n                basedOnId: baseRuleset.id,\n                start: mustStartAtOrAfter\n            });\n        } else {\n            // Derive the correct next start time from the base.\n            uint256 start = _deriveStartFrom(baseRuleset, mustStartAtOrAfter);\n\n            // A weight of 1 is treated as a weight of 0.\n            // This is to allow a weight of 0 (default) to represent inheriting the decayed weight of the previous\n            // ruleset.\n            weight = weight > 0 ? (weight == 1 ? 0 : weight) : _deriveWeightFrom(projectId, baseRuleset, start);\n\n            // Derive the correct ruleset cycle number.\n            uint256 rulesetCycleNumber = _deriveCycleNumberFrom(baseRuleset, start);\n\n            // Update the intrinsic properties.\n            _packAndStoreIntrinsicPropertiesOf({\n                rulesetId: rulesetId,\n                projectId: projectId,\n                rulesetCycleNumber: rulesetCycleNumber,\n                weight: weight,\n                basedOnId: baseRuleset.id,\n                start: start\n            });\n        }\n\n        // Set the project's latest ruleset configuration.\n        latestRulesetIdOf[projectId] = rulesetId;\n\n        emit RulesetInitialized(rulesetId, projectId, baseRuleset.id);\n    }\n\n    /// @notice Efficiently stores the provided intrinsic properties of a ruleset.\n    /// @param rulesetId The `rulesetId` of the ruleset to pack and store for.\n    /// @param projectId The ID of the project the ruleset belongs to.\n    /// @param rulesetCycleNumber The cycle number of the ruleset.\n    /// @param weight The weight of the ruleset.\n    /// @param basedOnId The `rulesetId` of the ruleset this ruleset was based on.\n    /// @param start The start time of this ruleset.\n    function _packAndStoreIntrinsicPropertiesOf(\n        uint256 rulesetId,\n        uint256 projectId,\n        uint256 rulesetCycleNumber,\n        uint256 weight,\n        uint256 basedOnId,\n        uint256 start\n    )\n        internal\n    {\n        // `weight` in bits 0-87.\n        uint256 packed = weight;\n\n        // `basedOnId` in bits 88-143.\n        packed |= basedOnId << 88;\n\n        // `start` in bits 144-199.\n        packed |= start << 144;\n\n        // cycle number in bits 200-255.\n        packed |= rulesetCycleNumber << 200;\n\n        // Store the packed value.\n        _packedIntrinsicPropertiesOf[projectId][rulesetId] = packed;\n    }\n\n    /// @notice The ruleset up next for a project, if one exists, whether or not that ruleset has been approved.\n    /// @dev A value of 0 is returned if no ruleset was found.\n    /// @dev Assumes the project has a `latestRulesetIdOf` value.\n    /// @param projectId The ID of the project to check for an upcoming approvable ruleset.\n    /// @return rulesetId The `rulesetId` of the upcoming approvable ruleset if one exists, or 0 if one doesn't exist.\n    function _upcomingApprovableRulesetIdOf(uint256 projectId) internal view returns (uint256 rulesetId) {\n        // Get a reference to the ID of the project's latest ruleset.\n        rulesetId = latestRulesetIdOf[projectId];\n\n        // Get the struct for the latest ruleset.\n        JBRuleset memory ruleset = _getStructFor(projectId, rulesetId);\n\n        // There is no upcoming ruleset if the latest ruleset has already started.\n        if (block.timestamp >= ruleset.start) return 0;\n\n        // If this is the first ruleset, it is queued.\n        if (ruleset.cycleNumber == 1) return rulesetId;\n\n        // Get a reference to the ID of the ruleset the latest ruleset was based on.\n        uint256 basedOnId = ruleset.basedOnId;\n\n        // Get the necessary properties for the base ruleset.\n        JBRuleset memory baseRuleset;\n\n        // Find the base ruleset that is not still queued.\n        while (true) {\n            baseRuleset = _getStructFor(projectId, basedOnId);\n\n            // If the base ruleset starts in the future,\n            if (block.timestamp < baseRuleset.start) {\n                // Set the `rulesetId` to the one found.\n                rulesetId = baseRuleset.id;\n                // Check the ruleset it was based on in the next iteration.\n                basedOnId = baseRuleset.basedOnId;\n            } else {\n                // Break out of the loop when a base ruleset which has already started is found.\n                break;\n            }\n        }\n\n        // Get the ruleset struct for the ID found.\n        ruleset = _getStructFor(projectId, rulesetId);\n\n        // If the latest ruleset doesn't start until after another base ruleset return 0.\n        if (baseRuleset.duration != 0 && block.timestamp < ruleset.start - baseRuleset.duration) {\n            return 0;\n        }\n    }\n\n    /// @notice The ID of the ruleset which has started and hasn't expired yet, whether or not it has been approved, for\n    /// a given project. If approved, this is the active ruleset.\n    /// @dev A value of 0 is returned if no ruleset was found.\n    /// @dev Assumes the project has a latest ruleset.\n    /// @param projectId The ID of the project to check for a currently approvable ruleset.\n    /// @return The ID of a currently approvable ruleset if one exists, or 0 if one doesn't exist.\n    function _currentlyApprovableRulesetIdOf(uint256 projectId) internal view returns (uint256) {\n        // Get a reference to the project's latest ruleset.\n        uint256 rulesetId = latestRulesetIdOf[projectId];\n\n        // Get the struct for the latest ruleset.\n        JBRuleset memory ruleset = _getStructFor(projectId, rulesetId);\n\n        // Loop through all most recently queued rulesets until an approvable one is found, or we've proven one can't\n        // exist.\n        do {\n            // If the latest ruleset is expired, return an empty ruleset.\n            // A ruleset with a duration of 0 cannot expire.\n            if (ruleset.duration != 0 && block.timestamp >= ruleset.start + ruleset.duration) {\n                return 0;\n            }\n\n            // Return the ruleset's `rulesetId` if it has started.\n            if (block.timestamp >= ruleset.start) {\n                return ruleset.id;\n            }\n\n            ruleset = _getStructFor(projectId, ruleset.basedOnId);\n        } while (ruleset.cycleNumber != 0);\n\n        return 0;\n    }\n\n    /// @notice A simulated view of the ruleset that would be created if the provided one cycled over (if the project\n    /// doesn't queue a new ruleset).\n    /// @dev Returns an empty ruleset if a ruleset can't be simulated based on the provided one.\n    /// @dev Assumes a simulated ruleset will never be based on a ruleset with a duration of 0.\n    /// @param projectId The ID of the project of the ruleset.\n    /// @param baseRuleset The ruleset that the simulated ruleset should be based on.\n    /// @param allowMidRuleset A flag indicating if the simulated ruleset is allowed to already be mid ruleset.\n    /// @return A simulated ruleset struct: the next ruleset by default. This will be overwritten if a new ruleset is\n    /// queued for the project.\n    function _simulateCycledRulesetBasedOn(\n        uint256 projectId,\n        JBRuleset memory baseRuleset,\n        bool allowMidRuleset\n    )\n        internal\n        view\n        returns (JBRuleset memory)\n    {\n        // Get the distance from the current time to the start of the next possible ruleset.\n        // If the simulated ruleset must not yet have started, the start time of the simulated ruleset must be in the\n        // future.\n        uint256 mustStartAtOrAfter = !allowMidRuleset ? block.timestamp + 1 : block.timestamp - baseRuleset.duration + 1;\n\n        // Calculate what the start time should be.\n        uint256 start = _deriveStartFrom(baseRuleset, mustStartAtOrAfter);\n\n        // Calculate what the cycle number should be.\n        uint256 rulesetCycleNumber = _deriveCycleNumberFrom(baseRuleset, start);\n\n        return JBRuleset({\n            cycleNumber: rulesetCycleNumber,\n            id: baseRuleset.id,\n            basedOnId: baseRuleset.basedOnId,\n            start: start,\n            duration: baseRuleset.duration,\n            weight: _deriveWeightFrom(projectId, baseRuleset, start),\n            decayRate: baseRuleset.decayRate,\n            approvalHook: baseRuleset.approvalHook,\n            metadata: baseRuleset.metadata\n        });\n    }\n\n    /// @notice The date that is the nearest multiple of the base ruleset's duration from the start of the next cycle.\n    /// @param baseRuleset The ruleset to base the calculation on (the previous ruleset).\n    /// @param mustStartAtOrAfter The earliest time the next ruleset can start. The ruleset cannot start before this\n    /// timestamp.\n    /// @return start The next start time.\n    function _deriveStartFrom(\n        JBRuleset memory baseRuleset,\n        uint256 mustStartAtOrAfter\n    )\n        internal\n        pure\n        returns (uint256 start)\n    {\n        // A subsequent ruleset to one with a duration of 0 should start as soon as possible.\n        if (baseRuleset.duration == 0) return mustStartAtOrAfter;\n\n        // The time when the ruleset immediately after the specified ruleset starts.\n        uint256 nextImmediateStart = baseRuleset.start + baseRuleset.duration;\n\n        // If the next immediate start is now or in the future, return it.\n        if (nextImmediateStart >= mustStartAtOrAfter) {\n            return nextImmediateStart;\n        }\n\n        // The amount of seconds since the `mustStartAtOrAfter` time which results in a start time that might satisfy\n        // the specified limits.\n        // slither-disable-next-line weak-prng\n        uint256 timeFromImmediateStartMultiple = (mustStartAtOrAfter - nextImmediateStart) % baseRuleset.duration;\n\n        // A reference to the first possible start timestamp.\n        start = mustStartAtOrAfter - timeFromImmediateStartMultiple;\n\n        // Add increments of duration as necessary to satisfy the threshold.\n        while (mustStartAtOrAfter > start) {\n            start = start + baseRuleset.duration;\n        }\n    }\n\n    /// @notice The accumulated weight change since the specified ruleset.\n    /// @param projectId The ID of the project to which the ruleset weights apply.\n    /// @param baseRuleset The ruleset to base the calculation on (the previous ruleset).\n    /// @param start The start time of the ruleset to derive a weight for.\n    /// @return weight The derived weight, as a fixed point number with 18 decimals.\n    function _deriveWeightFrom(\n        uint256 projectId,\n        JBRuleset memory baseRuleset,\n        uint256 start\n    )\n        internal\n        view\n        returns (uint256 weight)\n    {\n        // A subsequent ruleset to one with a duration of 0 should have the next possible weight.\n        if (baseRuleset.duration == 0) {\n            return mulDiv(\n                baseRuleset.weight, JBConstants.MAX_DECAY_RATE - baseRuleset.decayRate, JBConstants.MAX_DECAY_RATE\n            );\n        }\n\n        // The weight should be based off the base ruleset's weight.\n        weight = baseRuleset.weight;\n\n        // If the decay is 0, the weight doesn't change.\n        if (baseRuleset.decayRate == 0) return weight;\n\n        // The difference between the start of the base ruleset and the proposed start.\n        uint256 startDistance = start - baseRuleset.start;\n\n        // Apply the base ruleset's decay rate for each ruleset that has passed.\n        uint256 decayMultiple;\n        unchecked {\n            decayMultiple = startDistance / baseRuleset.duration; // Non-null duration is excluded above\n        }\n\n        // Check the cache if needed.\n        if (decayMultiple > _DECAY_MULTIPLE_CACHE_LOOKUP_THRESHOLD) {\n            // Get a cached weight for the rulesetId.\n            JBRulesetWeightCache memory cache = _weightCacheOf[projectId][baseRuleset.id];\n\n            // If a cached value is available, use it.\n            if (cache.decayMultiple > 0) {\n                // Set the starting weight to be the cached value.\n                weight = cache.weight;\n\n                // Set the decay multiple to be the difference between the cached value and the total decay multiple\n                // that should be applied.\n                decayMultiple -= cache.decayMultiple;\n            }\n        }\n\n        for (uint256 i; i < decayMultiple; i++) {\n            // The number of times to apply the decay rate.\n            // Base the new weight on the specified ruleset's weight.\n            weight = mulDiv(weight, JBConstants.MAX_DECAY_RATE - baseRuleset.decayRate, JBConstants.MAX_DECAY_RATE);\n\n            // The calculation doesn't need to continue if the weight is 0.\n            if (weight == 0) break;\n        }\n    }\n\n    /// @notice The cycle number of the next ruleset given the specified ruleset.\n    /// @dev Each time a ruleset starts, whether it was queued or cycled over, the cycle number is incremented by 1.\n    /// @param baseRuleset The previously queued ruleset, to base the calculation on.\n    /// @param start The start time of the ruleset to derive a cycle number for.\n    /// @return The ruleset's cycle number.\n    function _deriveCycleNumberFrom(JBRuleset memory baseRuleset, uint256 start) internal pure returns (uint256) {\n        // A subsequent ruleset to one with a duration of 0 should be the next number.\n        if (baseRuleset.duration == 0) {\n            return baseRuleset.cycleNumber + 1;\n        }\n\n        // The difference between the start of the base ruleset and the proposed start.\n        uint256 startDistance = start - baseRuleset.start;\n\n        // Find the number of base rulesets that fit in the start distance.\n        return baseRuleset.cycleNumber + (startDistance / baseRuleset.duration);\n    }\n\n    /// @notice The approval status of a given project and ruleset struct according to the relevant approval hook.\n    /// @param projectId The ID of the project that the ruleset belongs to.\n    /// @param ruleset The ruleset to get an approval flag for.\n    /// @return The approval status of the project's ruleset.\n    function _approvalStatusOf(uint256 projectId, JBRuleset memory ruleset) internal view returns (JBApprovalStatus) {\n        return _approvalStatusOf({\n            projectId: projectId,\n            rulesetId: ruleset.id,\n            start: ruleset.start,\n            approvalHookRulesetId: ruleset.basedOnId\n        });\n    }\n\n    /// @notice The approval status of a given ruleset (ID) for a given project (ID).\n    /// @param projectId The ID of the project the ruleset belongs to.\n    /// @param rulesetId The ID of the ruleset to get the approval status of.\n    /// @param start The start time of the ruleset to get the approval status of.\n    /// @param approvalHookRulesetId The ID of the ruleset with the approval hook that should be checked against.\n    /// @return The approval status of the project.\n    function _approvalStatusOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        uint256 start,\n        uint256 approvalHookRulesetId\n    )\n        internal\n        view\n        returns (JBApprovalStatus)\n    {\n        // If there is no ruleset ID to check the approval hook of, the approval hook is empty.\n        if (approvalHookRulesetId == 0) return JBApprovalStatus.Empty;\n\n        // Get the struct of the ruleset with the approval hook.\n        JBRuleset memory approvalHookRuleset = _getStructFor(projectId, approvalHookRulesetId);\n\n        // If there is no approval hook, it's considered empty.\n        if (approvalHookRuleset.approvalHook == IJBRulesetApprovalHook(address(0))) {\n            return JBApprovalStatus.Empty;\n        }\n\n        // Return the approval hook's approval status.\n        return approvalHookRuleset.approvalHook.approvalStatusOf(projectId, rulesetId, start);\n    }\n\n    /// @notice Unpack a ruleset's packed stored values into an easy-to-work-with ruleset struct.\n    /// @param projectId The ID of the project the ruleset belongs to.\n    /// @param rulesetId The ID of the ruleset to get the full struct for.\n    /// @return ruleset A ruleset struct.\n    function _getStructFor(uint256 projectId, uint256 rulesetId) internal view returns (JBRuleset memory ruleset) {\n        // Return an empty ruleset if the specified `rulesetId` is 0.\n        // slither-disable-next-line incorrect-equality\n        if (rulesetId == 0) return ruleset;\n\n        ruleset.id = rulesetId;\n\n        uint256 packedIntrinsicProperties = _packedIntrinsicPropertiesOf[projectId][rulesetId];\n\n        // `weight` in bits 0-87 bits.\n        ruleset.weight = uint256(uint88(packedIntrinsicProperties));\n        // `basedOnId` in bits 88-143 bits.\n        ruleset.basedOnId = uint256(uint56(packedIntrinsicProperties >> 88));\n        // `start` in bits 144-199 bits.\n        ruleset.start = uint256(uint56(packedIntrinsicProperties >> 144));\n        // `cycleNumber` in bits 200-255 bits.\n        ruleset.cycleNumber = uint256(uint56(packedIntrinsicProperties >> 200));\n\n        uint256 packedUserProperties = _packedUserPropertiesOf[projectId][rulesetId];\n\n        // approval hook in bits 0-159 bits.\n        ruleset.approvalHook = IJBRulesetApprovalHook(address(uint160(packedUserProperties)));\n        // `duration` in bits 160-191 bits.\n        ruleset.duration = uint256(uint32(packedUserProperties >> 160));\n        // decay rate in bits 192-223 bits.\n        ruleset.decayRate = uint256(uint32(packedUserProperties >> 192));\n\n        ruleset.metadata = _metadataOf[projectId][rulesetId];\n    }\n}\n"
			},
			"src/enums/JBApprovalStatus.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice A ruleset's approval status in a ruleset approval hook.\nenum JBApprovalStatus {\n    Empty,\n    Upcoming,\n    Active,\n    ApprovalExpected,\n    Approved,\n    Failed\n}\n"
			},
			"src/interfaces/IJBRulesetApprovalHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBApprovalStatus} from \"./../enums/JBApprovalStatus.sol\";\n\n/// @notice `IJBRulesetApprovalHook`s are used to determine whether the next ruleset in the ruleset queue is approved or\n/// rejected.\n/// @dev Project rulesets are stored in a queue. Rulesets take effect after the previous ruleset in the queue ends, and\n/// only if they are approved by the previous ruleset's approval hook.\ninterface IJBRulesetApprovalHook is IERC165 {\n    function DURATION() external view returns (uint256);\n\n    function approvalStatusOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        uint256 start\n    )\n        external\n        view\n        returns (JBApprovalStatus);\n}\n"
			},
			"src/interfaces/IJBRulesets.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBApprovalStatus} from \"./../enums/JBApprovalStatus.sol\";\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {IJBRulesetApprovalHook} from \"./IJBRulesetApprovalHook.sol\";\n\ninterface IJBRulesets {\n    event RulesetQueued(\n        uint256 indexed rulesetId,\n        uint256 indexed projectId,\n        uint256 duration,\n        uint256 weight,\n        uint256 decayRate,\n        IJBRulesetApprovalHook hook,\n        uint256 metadata,\n        uint256 mustStartAtOrAfter,\n        address caller\n    );\n\n    event RulesetInitialized(uint256 indexed rulesetId, uint256 indexed projectId, uint256 indexed basedOnId);\n\n    function latestRulesetIdOf(uint256 projectId) external view returns (uint256);\n\n    function getRulesetOf(uint256 projectId, uint256 rulesetId) external view returns (JBRuleset memory);\n\n    function latestQueuedRulesetOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory ruleset, JBApprovalStatus approvalStatus);\n\n    function rulesetsOf(\n        uint256 projectId,\n        uint256 startingId,\n        uint256 size\n    )\n        external\n        view\n        returns (JBRuleset[] memory rulesets);\n\n    function upcomingOf(uint256 projectId) external view returns (JBRuleset memory ruleset);\n\n    function currentOf(uint256 projectId) external view returns (JBRuleset memory ruleset);\n\n    function currentApprovalStatusForLatestRulesetOf(uint256 projectId) external view returns (JBApprovalStatus);\n\n    function queueFor(\n        uint256 projectId,\n        uint256 duration,\n        uint256 weight,\n        uint256 decayRate,\n        IJBRulesetApprovalHook approvalHook,\n        uint256 metadata,\n        uint256 mustStartAtOrAfter\n    )\n        external\n        returns (JBRuleset memory ruleset);\n\n    function updateRulesetWeightCache(uint256 projectId) external;\n}\n"
			},
			"src/structs/JBRuleset.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBRulesetApprovalHook} from \"./../interfaces/IJBRulesetApprovalHook.sol\";\n\n/// @dev `JBRuleset` timestamps are unix timestamps (seconds since 00:00 January 1st, 1970 UTC).\n/// @custom:member cycleNumber The ruleset's cycle number. Each ruleset's `cycleNumber` is the previous ruleset's\n/// `cycleNumber` plus one. Each project's first ruleset has a `cycleNumber` of 1.\n/// @custom:member id The ruleset's ID, which is a timestamp of when this ruleset's rules were initialized. The\n/// `rulesetId` stays the same for rulesets that automatically cycle over from a manually queued ruleset.\n/// @custom:member basedOnId The `rulesetId` of the ruleset which was active when this ruleset was created.\n/// @custom:member start The timestamp from which this ruleset is considered active.\n/// @custom:member duration The number of seconds the ruleset lasts for. After this duration, a new ruleset will start.\n/// The project owner can queue new rulesets at any time, which will take effect once the current ruleset's duration is\n/// over. If the `duration` is 0, newly queued rulesets will take effect immediately. If a ruleset ends and there are no\n/// new rulesets queued, the current ruleset cycles over to another one with the same properties but a new `start`\n/// timestamp and a `weight` reduced by the ruleset's `decayRate`.\n/// @custom:member weight A fixed point number with 18 decimals which is typically used by payment terminals to\n/// determine how many tokens should be minted when a payment is received. This can be used by other contracts for\n/// arbitrary calculations.\n/// @custom:member decayRate The percentage by which to reduce the `weight` each time a new ruleset starts. `weight` is\n/// a percentage out of `JBConstants.MAX_DECAY_RATE`. If it's 0, the next ruleset will have the same `weight` by\n/// default. If it's 90%, the next ruleset's `weight` will be 10% smaller. If a ruleset explicitly sets a new `weight`,\n/// the `decayRate` doesn't apply.\n/// @custom:member approvalHook An address of a contract that says whether a queued ruleset should be approved or\n/// rejected. If a\n/// ruleset is rejected, it won't go into effect. An approval hook can be used to create rules which dictate how a\n/// project owner can change their ruleset over time.\n/// @custom:member metadata Extra data associated with a ruleset which can be used by other contracts.\nstruct JBRuleset {\n    uint256 cycleNumber;\n    uint256 id;\n    uint256 basedOnId;\n    uint256 start;\n    uint256 duration;\n    uint256 weight;\n    uint256 decayRate;\n    IJBRulesetApprovalHook approvalHook;\n    uint256 metadata;\n}\n"
			},
			"src/structs/JBRulesetWeightCache.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member weight The cached weight value.\n/// @custom:member decayMultiple The decay multiple that produces the given weight.\nstruct JBRulesetWeightCache {\n    uint256 weight;\n    uint256 decayMultiple;\n}\n"
			},
			"node_modules/@openzeppelin/contracts/governance/utils/IVotes.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (governance/utils/IVotes.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Common interface for {ERC20Votes}, {ERC721Votes}, and other {Votes}-enabled contracts.\n */\ninterface IVotes {\n    /**\n     * @dev The signature used has expired.\n     */\n    error VotesExpiredSignature(uint256 expiry);\n\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of voting units.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousVotes, uint256 newVotes);\n\n    /**\n     * @dev Returns the current amount of votes that `account` has.\n     */\n    function getVotes(address account) external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     */\n    function getPastVotes(address account, uint256 timepoint) external view returns (uint256);\n\n    /**\n     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     */\n    function getPastTotalSupply(uint256 timepoint) external view returns (uint256);\n\n    /**\n     * @dev Returns the delegate that `account` has chosen.\n     */\n    function delegates(address account) external view returns (address);\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) external;\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`.\n     */\n    function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external;\n}\n"
			},
			"node_modules/@openzeppelin/contracts/governance/utils/Votes.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (governance/utils/Votes.sol)\npragma solidity ^0.8.20;\n\nimport {IERC5805} from \"../../interfaces/IERC5805.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {Nonces} from \"../../utils/Nonces.sol\";\nimport {EIP712} from \"../../utils/cryptography/EIP712.sol\";\nimport {Checkpoints} from \"../../utils/structs/Checkpoints.sol\";\nimport {SafeCast} from \"../../utils/math/SafeCast.sol\";\nimport {ECDSA} from \"../../utils/cryptography/ECDSA.sol\";\nimport {Time} from \"../../utils/types/Time.sol\";\n\n/**\n * @dev This is a base abstract contract that tracks voting units, which are a measure of voting power that can be\n * transferred, and provides a system of vote delegation, where an account can delegate its voting units to a sort of\n * \"representative\" that will pool delegated voting units from different accounts and can then use it to vote in\n * decisions. In fact, voting units _must_ be delegated in order to count as actual votes, and an account has to\n * delegate those votes to itself if it wishes to participate in decisions and does not have a trusted representative.\n *\n * This contract is often combined with a token contract such that voting units correspond to token units. For an\n * example, see {ERC721Votes}.\n *\n * The full history of delegate votes is tracked on-chain so that governance protocols can consider votes as distributed\n * at a particular block number to protect against flash loans and double voting. The opt-in delegate system makes the\n * cost of this history tracking optional.\n *\n * When using this module the derived contract must implement {_getVotingUnits} (for example, make it return\n * {ERC721-balanceOf}), and can use {_transferVotingUnits} to track a change in the distribution of those units (in the\n * previous example, it would be included in {ERC721-_update}).\n */\nabstract contract Votes is Context, EIP712, Nonces, IERC5805 {\n    using Checkpoints for Checkpoints.Trace208;\n\n    bytes32 private constant DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    mapping(address account => address) private _delegatee;\n\n    mapping(address delegatee => Checkpoints.Trace208) private _delegateCheckpoints;\n\n    Checkpoints.Trace208 private _totalCheckpoints;\n\n    /**\n     * @dev The clock was incorrectly modified.\n     */\n    error ERC6372InconsistentClock();\n\n    /**\n     * @dev Lookup to future votes is not available.\n     */\n    error ERC5805FutureLookup(uint256 timepoint, uint48 clock);\n\n    /**\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based\n     * checkpoints (and voting), in which case {CLOCK_MODE} should be overridden as well to match.\n     */\n    function clock() public view virtual returns (uint48) {\n        return Time.blockNumber();\n    }\n\n    /**\n     * @dev Machine-readable description of the clock as specified in EIP-6372.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() public view virtual returns (string memory) {\n        // Check that the clock was not modified\n        if (clock() != Time.blockNumber()) {\n            revert ERC6372InconsistentClock();\n        }\n        return \"mode=blocknumber&from=default\";\n    }\n\n    /**\n     * @dev Returns the current amount of votes that `account` has.\n     */\n    function getVotes(address account) public view virtual returns (uint256) {\n        return _delegateCheckpoints[account].latest();\n    }\n\n    /**\n     * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     *\n     * Requirements:\n     *\n     * - `timepoint` must be in the past. If operating using block numbers, the block must be already mined.\n     */\n    function getPastVotes(address account, uint256 timepoint) public view virtual returns (uint256) {\n        uint48 currentTimepoint = clock();\n        if (timepoint >= currentTimepoint) {\n            revert ERC5805FutureLookup(timepoint, currentTimepoint);\n        }\n        return _delegateCheckpoints[account].upperLookupRecent(SafeCast.toUint48(timepoint));\n    }\n\n    /**\n     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     *\n     * Requirements:\n     *\n     * - `timepoint` must be in the past. If operating using block numbers, the block must be already mined.\n     */\n    function getPastTotalSupply(uint256 timepoint) public view virtual returns (uint256) {\n        uint48 currentTimepoint = clock();\n        if (timepoint >= currentTimepoint) {\n            revert ERC5805FutureLookup(timepoint, currentTimepoint);\n        }\n        return _totalCheckpoints.upperLookupRecent(SafeCast.toUint48(timepoint));\n    }\n\n    /**\n     * @dev Returns the current total supply of votes.\n     */\n    function _getTotalSupply() internal view virtual returns (uint256) {\n        return _totalCheckpoints.latest();\n    }\n\n    /**\n     * @dev Returns the delegate that `account` has chosen.\n     */\n    function delegates(address account) public view virtual returns (address) {\n        return _delegatee[account];\n    }\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) public virtual {\n        address account = _msgSender();\n        _delegate(account, delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`.\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (block.timestamp > expiry) {\n            revert VotesExpiredSignature(expiry);\n        }\n        address signer = ECDSA.recover(\n            _hashTypedDataV4(keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        _useCheckedNonce(signer, nonce);\n        _delegate(signer, delegatee);\n    }\n\n    /**\n     * @dev Delegate all of `account`'s voting units to `delegatee`.\n     *\n     * Emits events {IVotes-DelegateChanged} and {IVotes-DelegateVotesChanged}.\n     */\n    function _delegate(address account, address delegatee) internal virtual {\n        address oldDelegate = delegates(account);\n        _delegatee[account] = delegatee;\n\n        emit DelegateChanged(account, oldDelegate, delegatee);\n        _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));\n    }\n\n    /**\n     * @dev Transfers, mints, or burns voting units. To register a mint, `from` should be zero. To register a burn, `to`\n     * should be zero. Total supply of voting units will be adjusted with mints and burns.\n     */\n    function _transferVotingUnits(address from, address to, uint256 amount) internal virtual {\n        if (from == address(0)) {\n            _push(_totalCheckpoints, _add, SafeCast.toUint208(amount));\n        }\n        if (to == address(0)) {\n            _push(_totalCheckpoints, _subtract, SafeCast.toUint208(amount));\n        }\n        _moveDelegateVotes(delegates(from), delegates(to), amount);\n    }\n\n    /**\n     * @dev Moves delegated votes from one delegate to another.\n     */\n    function _moveDelegateVotes(address from, address to, uint256 amount) private {\n        if (from != to && amount > 0) {\n            if (from != address(0)) {\n                (uint256 oldValue, uint256 newValue) = _push(\n                    _delegateCheckpoints[from],\n                    _subtract,\n                    SafeCast.toUint208(amount)\n                );\n                emit DelegateVotesChanged(from, oldValue, newValue);\n            }\n            if (to != address(0)) {\n                (uint256 oldValue, uint256 newValue) = _push(\n                    _delegateCheckpoints[to],\n                    _add,\n                    SafeCast.toUint208(amount)\n                );\n                emit DelegateVotesChanged(to, oldValue, newValue);\n            }\n        }\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function _numCheckpoints(address account) internal view virtual returns (uint32) {\n        return SafeCast.toUint32(_delegateCheckpoints[account].length());\n    }\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function _checkpoints(\n        address account,\n        uint32 pos\n    ) internal view virtual returns (Checkpoints.Checkpoint208 memory) {\n        return _delegateCheckpoints[account].at(pos);\n    }\n\n    function _push(\n        Checkpoints.Trace208 storage store,\n        function(uint208, uint208) view returns (uint208) op,\n        uint208 delta\n    ) private returns (uint208, uint208) {\n        return store.push(clock(), op(store.latest(), delta));\n    }\n\n    function _add(uint208 a, uint208 b) private pure returns (uint208) {\n        return a + b;\n    }\n\n    function _subtract(uint208 a, uint208 b) private pure returns (uint208) {\n        return a - b;\n    }\n\n    /**\n     * @dev Must return the voting units held by an account.\n     */\n    function _getVotingUnits(address) internal view virtual returns (uint256);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/interfaces/IERC5805.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5805.sol)\n\npragma solidity ^0.8.20;\n\nimport {IVotes} from \"../governance/utils/IVotes.sol\";\nimport {IERC6372} from \"./IERC6372.sol\";\n\ninterface IERC5805 is IERC6372, IVotes {}\n"
			},
			"node_modules/@openzeppelin/contracts/interfaces/IERC6372.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC6372.sol)\n\npragma solidity ^0.8.20;\n\ninterface IERC6372 {\n    /**\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\n     */\n    function clock() external view returns (uint48);\n\n    /**\n     * @dev Description of the clock\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() external view returns (string memory);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20Permit} from \"./IERC20Permit.sol\";\nimport {ERC20} from \"../ERC20.sol\";\nimport {ECDSA} from \"../../../utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"../../../utils/cryptography/EIP712.sol\";\nimport {Nonces} from \"../../../utils/Nonces.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712, Nonces {\n    bytes32 private constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Permit deadline has expired.\n     */\n    error ERC2612ExpiredSignature(uint256 deadline);\n\n    /**\n     * @dev Mismatched signature.\n     */\n    error ERC2612InvalidSigner(address signer, address owner);\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (block.timestamp > deadline) {\n            revert ERC2612ExpiredSignature(deadline);\n        }\n\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        if (signer != owner) {\n            revert ERC2612InvalidSigner(signer, owner);\n        }\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function nonces(address owner) public view virtual override(IERC20Permit, Nonces) returns (uint256) {\n        return super.nonces(owner);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view virtual returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Votes.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC20} from \"../ERC20.sol\";\nimport {Votes} from \"../../../governance/utils/Votes.sol\";\nimport {Checkpoints} from \"../../../utils/structs/Checkpoints.sol\";\n\n/**\n * @dev Extension of ERC20 to support Compound-like voting and delegation. This version is more generic than Compound's,\n * and supports token supply up to 2^208^ - 1, while COMP is limited to 2^96^ - 1.\n *\n * NOTE: This contract does not provide interface compatibility with Compound's COMP token.\n *\n * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\n * power can be queried through the public accessors {getVotes} and {getPastVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n */\nabstract contract ERC20Votes is ERC20, Votes {\n    /**\n     * @dev Total supply cap has been exceeded, introducing a risk of votes overflowing.\n     */\n    error ERC20ExceededSafeSupply(uint256 increasedSupply, uint256 cap);\n\n    /**\n     * @dev Maximum token supply. Defaults to `type(uint208).max` (2^208^ - 1).\n     *\n     * This maximum is enforced in {_update}. It limits the total supply of the token, which is otherwise a uint256,\n     * so that checkpoints can be stored in the Trace208 structure used by {{Votes}}. Increasing this value will not\n     * remove the underlying limitation, and will cause {_update} to fail because of a math overflow in\n     * {_transferVotingUnits}. An override could be used to further restrict the total supply (to a lower value) if\n     * additional logic requires it. When resolving override conflicts on this function, the minimum should be\n     * returned.\n     */\n    function _maxSupply() internal view virtual returns (uint256) {\n        return type(uint208).max;\n    }\n\n    /**\n     * @dev Move voting power when tokens are transferred.\n     *\n     * Emits a {IVotes-DelegateVotesChanged} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual override {\n        super._update(from, to, value);\n        if (from == address(0)) {\n            uint256 supply = totalSupply();\n            uint256 cap = _maxSupply();\n            if (supply > cap) {\n                revert ERC20ExceededSafeSupply(supply, cap);\n            }\n        }\n        _transferVotingUnits(from, to, value);\n    }\n\n    /**\n     * @dev Returns the voting units of an `account`.\n     *\n     * WARNING: Overriding this function may compromise the internal vote accounting.\n     * `ERC20Votes` assumes tokens map to voting units 1:1 and this is not easy to change.\n     */\n    function _getVotingUnits(address account) internal view virtual override returns (uint256) {\n        return balanceOf(account);\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return _numCheckpoints(account);\n    }\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoints.Checkpoint208 memory) {\n        return _checkpoints(account, pos);\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/Nonces.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Nonces.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides tracking nonces for addresses. Nonces will only increment.\n */\nabstract contract Nonces {\n    /**\n     * @dev The nonce used for an `account` is not the expected current nonce.\n     */\n    error InvalidAccountNonce(address account, uint256 currentNonce);\n\n    mapping(address account => uint256) private _nonces;\n\n    /**\n     * @dev Returns the next unused nonce for an address.\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        return _nonces[owner];\n    }\n\n    /**\n     * @dev Consumes a nonce.\n     *\n     * Returns the current value and increments nonce.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256) {\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\n        // decremented or reset. This guarantees that the nonce never overflows.\n        unchecked {\n            // It is important to do x++ and not ++x here.\n            return _nonces[owner]++;\n        }\n    }\n\n    /**\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\n     */\n    function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\n        uint256 current = _useNonce(owner);\n        if (nonce != current) {\n            revert InvalidAccountNonce(owner, current);\n        }\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/structs/Checkpoints.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/Checkpoints.sol)\n// This file was procedurally generated from scripts/generate/templates/Checkpoints.js.\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"../math/Math.sol\";\n\n/**\n * @dev This library defines the `Trace*` struct, for checkpointing values as they change at different points in\n * time, and later looking up past values by block number. See {Votes} as an example.\n *\n * To create a history of checkpoints define a variable type `Checkpoints.Trace*` in your contract, and store a new\n * checkpoint for the current transaction block using the {push} function.\n */\nlibrary Checkpoints {\n    /**\n     * @dev A value was attempted to be inserted on a past checkpoint.\n     */\n    error CheckpointUnorderedInsertion();\n\n    struct Trace224 {\n        Checkpoint224[] _checkpoints;\n    }\n\n    struct Checkpoint224 {\n        uint32 _key;\n        uint224 _value;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into a Trace224 so that it is stored as the checkpoint.\n     *\n     * Returns previous value and new value.\n     *\n     * IMPORTANT: Never accept `key` as a user input, since an arbitrary `type(uint32).max` key set will disable the\n     * library.\n     */\n    function push(Trace224 storage self, uint32 key, uint224 value) internal returns (uint224, uint224) {\n        return _insert(self._checkpoints, key, value);\n    }\n\n    /**\n     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if\n     * there is none.\n     */\n    function lowerLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero\n     * if there is none.\n     */\n    function upperLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero\n     * if there is none.\n     *\n     * NOTE: This is a variant of {upperLookup} that is optimised to find \"recent\" checkpoint (checkpoints with high\n     * keys).\n     */\n    function upperLookupRecent(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - Math.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(Trace224 storage self) internal view returns (uint224) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\n     * in the most recent checkpoint.\n     */\n    function latestCheckpoint(Trace224 storage self) internal view returns (bool exists, uint32 _key, uint224 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint224 memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._key, ckpt._value);\n        }\n    }\n\n    /**\n     * @dev Returns the number of checkpoint.\n     */\n    function length(Trace224 storage self) internal view returns (uint256) {\n        return self._checkpoints.length;\n    }\n\n    /**\n     * @dev Returns checkpoint at given position.\n     */\n    function at(Trace224 storage self, uint32 pos) internal view returns (Checkpoint224 memory) {\n        return self._checkpoints[pos];\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\n     * or by updating the last one.\n     */\n    function _insert(Checkpoint224[] storage self, uint32 key, uint224 value) private returns (uint224, uint224) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            // Copying to memory is important here.\n            Checkpoint224 memory last = _unsafeAccess(self, pos - 1);\n\n            // Checkpoint keys must be non-decreasing.\n            if (last._key > key) {\n                revert CheckpointUnorderedInsertion();\n            }\n\n            // Update or push new checkpoint\n            if (last._key == key) {\n                _unsafeAccess(self, pos - 1)._value = value;\n            } else {\n                self.push(Checkpoint224({_key: key, _value: value}));\n            }\n            return (last._value, value);\n        } else {\n            self.push(Checkpoint224({_key: key, _value: value}));\n            return (0, value);\n        }\n    }\n\n    /**\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high`\n     * if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and exclusive\n     * `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _upperBinaryLookup(\n        Checkpoint224[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or\n     * `high` if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and\n     * exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _lowerBinaryLookup(\n        Checkpoint224[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(\n        Checkpoint224[] storage self,\n        uint256 pos\n    ) private pure returns (Checkpoint224 storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n\n    struct Trace208 {\n        Checkpoint208[] _checkpoints;\n    }\n\n    struct Checkpoint208 {\n        uint48 _key;\n        uint208 _value;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into a Trace208 so that it is stored as the checkpoint.\n     *\n     * Returns previous value and new value.\n     *\n     * IMPORTANT: Never accept `key` as a user input, since an arbitrary `type(uint48).max` key set will disable the\n     * library.\n     */\n    function push(Trace208 storage self, uint48 key, uint208 value) internal returns (uint208, uint208) {\n        return _insert(self._checkpoints, key, value);\n    }\n\n    /**\n     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if\n     * there is none.\n     */\n    function lowerLookup(Trace208 storage self, uint48 key) internal view returns (uint208) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero\n     * if there is none.\n     */\n    function upperLookup(Trace208 storage self, uint48 key) internal view returns (uint208) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero\n     * if there is none.\n     *\n     * NOTE: This is a variant of {upperLookup} that is optimised to find \"recent\" checkpoint (checkpoints with high\n     * keys).\n     */\n    function upperLookupRecent(Trace208 storage self, uint48 key) internal view returns (uint208) {\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - Math.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(Trace208 storage self) internal view returns (uint208) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\n     * in the most recent checkpoint.\n     */\n    function latestCheckpoint(Trace208 storage self) internal view returns (bool exists, uint48 _key, uint208 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint208 memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._key, ckpt._value);\n        }\n    }\n\n    /**\n     * @dev Returns the number of checkpoint.\n     */\n    function length(Trace208 storage self) internal view returns (uint256) {\n        return self._checkpoints.length;\n    }\n\n    /**\n     * @dev Returns checkpoint at given position.\n     */\n    function at(Trace208 storage self, uint32 pos) internal view returns (Checkpoint208 memory) {\n        return self._checkpoints[pos];\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\n     * or by updating the last one.\n     */\n    function _insert(Checkpoint208[] storage self, uint48 key, uint208 value) private returns (uint208, uint208) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            // Copying to memory is important here.\n            Checkpoint208 memory last = _unsafeAccess(self, pos - 1);\n\n            // Checkpoint keys must be non-decreasing.\n            if (last._key > key) {\n                revert CheckpointUnorderedInsertion();\n            }\n\n            // Update or push new checkpoint\n            if (last._key == key) {\n                _unsafeAccess(self, pos - 1)._value = value;\n            } else {\n                self.push(Checkpoint208({_key: key, _value: value}));\n            }\n            return (last._value, value);\n        } else {\n            self.push(Checkpoint208({_key: key, _value: value}));\n            return (0, value);\n        }\n    }\n\n    /**\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high`\n     * if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and exclusive\n     * `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _upperBinaryLookup(\n        Checkpoint208[] storage self,\n        uint48 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or\n     * `high` if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and\n     * exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _lowerBinaryLookup(\n        Checkpoint208[] storage self,\n        uint48 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(\n        Checkpoint208[] storage self,\n        uint256 pos\n    ) private pure returns (Checkpoint208 storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n\n    struct Trace160 {\n        Checkpoint160[] _checkpoints;\n    }\n\n    struct Checkpoint160 {\n        uint96 _key;\n        uint160 _value;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into a Trace160 so that it is stored as the checkpoint.\n     *\n     * Returns previous value and new value.\n     *\n     * IMPORTANT: Never accept `key` as a user input, since an arbitrary `type(uint96).max` key set will disable the\n     * library.\n     */\n    function push(Trace160 storage self, uint96 key, uint160 value) internal returns (uint160, uint160) {\n        return _insert(self._checkpoints, key, value);\n    }\n\n    /**\n     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if\n     * there is none.\n     */\n    function lowerLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero\n     * if there is none.\n     */\n    function upperLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero\n     * if there is none.\n     *\n     * NOTE: This is a variant of {upperLookup} that is optimised to find \"recent\" checkpoint (checkpoints with high\n     * keys).\n     */\n    function upperLookupRecent(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - Math.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(Trace160 storage self) internal view returns (uint160) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\n     * in the most recent checkpoint.\n     */\n    function latestCheckpoint(Trace160 storage self) internal view returns (bool exists, uint96 _key, uint160 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint160 memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._key, ckpt._value);\n        }\n    }\n\n    /**\n     * @dev Returns the number of checkpoint.\n     */\n    function length(Trace160 storage self) internal view returns (uint256) {\n        return self._checkpoints.length;\n    }\n\n    /**\n     * @dev Returns checkpoint at given position.\n     */\n    function at(Trace160 storage self, uint32 pos) internal view returns (Checkpoint160 memory) {\n        return self._checkpoints[pos];\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\n     * or by updating the last one.\n     */\n    function _insert(Checkpoint160[] storage self, uint96 key, uint160 value) private returns (uint160, uint160) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            // Copying to memory is important here.\n            Checkpoint160 memory last = _unsafeAccess(self, pos - 1);\n\n            // Checkpoint keys must be non-decreasing.\n            if (last._key > key) {\n                revert CheckpointUnorderedInsertion();\n            }\n\n            // Update or push new checkpoint\n            if (last._key == key) {\n                _unsafeAccess(self, pos - 1)._value = value;\n            } else {\n                self.push(Checkpoint160({_key: key, _value: value}));\n            }\n            return (last._value, value);\n        } else {\n            self.push(Checkpoint160({_key: key, _value: value}));\n            return (0, value);\n        }\n    }\n\n    /**\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high`\n     * if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and exclusive\n     * `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _upperBinaryLookup(\n        Checkpoint160[] storage self,\n        uint96 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or\n     * `high` if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and\n     * exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _lowerBinaryLookup(\n        Checkpoint160[] storage self,\n        uint96 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(\n        Checkpoint160[] storage self,\n        uint256 pos\n    ) private pure returns (Checkpoint160 storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/types/Time.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/types/Time.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"../math/Math.sol\";\nimport {SafeCast} from \"../math/SafeCast.sol\";\n\n/**\n * @dev This library provides helpers for manipulating time-related objects.\n *\n * It uses the following types:\n * - `uint48` for timepoints\n * - `uint32` for durations\n *\n * While the library doesn't provide specific types for timepoints and duration, it does provide:\n * - a `Delay` type to represent duration that can be programmed to change value automatically at a given point\n * - additional helper functions\n */\nlibrary Time {\n    using Time for *;\n\n    /**\n     * @dev Get the block timestamp as a Timepoint.\n     */\n    function timestamp() internal view returns (uint48) {\n        return SafeCast.toUint48(block.timestamp);\n    }\n\n    /**\n     * @dev Get the block number as a Timepoint.\n     */\n    function blockNumber() internal view returns (uint48) {\n        return SafeCast.toUint48(block.number);\n    }\n\n    // ==================================================== Delay =====================================================\n    /**\n     * @dev A `Delay` is a uint32 duration that can be programmed to change value automatically at a given point in the\n     * future. The \"effect\" timepoint describes when the transitions happens from the \"old\" value to the \"new\" value.\n     * This allows updating the delay applied to some operation while keeping some guarantees.\n     *\n     * In particular, the {update} function guarantees that if the delay is reduced, the old delay still applies for\n     * some time. For example if the delay is currently 7 days to do an upgrade, the admin should not be able to set\n     * the delay to 0 and upgrade immediately. If the admin wants to reduce the delay, the old delay (7 days) should\n     * still apply for some time.\n     *\n     *\n     * The `Delay` type is 112 bits long, and packs the following:\n     *\n     * ```\n     *   | [uint48]: effect date (timepoint)\n     *   |           | [uint32]: value before (duration)\n     *   ↓           ↓       ↓ [uint32]: value after (duration)\n     * 0xAAAAAAAAAAAABBBBBBBBCCCCCCCC\n     * ```\n     *\n     * NOTE: The {get} and {withUpdate} functions operate using timestamps. Block number based delays are not currently\n     * supported.\n     */\n    type Delay is uint112;\n\n    /**\n     * @dev Wrap a duration into a Delay to add the one-step \"update in the future\" feature\n     */\n    function toDelay(uint32 duration) internal pure returns (Delay) {\n        return Delay.wrap(duration);\n    }\n\n    /**\n     * @dev Get the value at a given timepoint plus the pending value and effect timepoint if there is a scheduled\n     * change after this timepoint. If the effect timepoint is 0, then the pending value should not be considered.\n     */\n    function _getFullAt(Delay self, uint48 timepoint) private pure returns (uint32, uint32, uint48) {\n        (uint32 valueBefore, uint32 valueAfter, uint48 effect) = self.unpack();\n        return effect <= timepoint ? (valueAfter, 0, 0) : (valueBefore, valueAfter, effect);\n    }\n\n    /**\n     * @dev Get the current value plus the pending value and effect timepoint if there is a scheduled change. If the\n     * effect timepoint is 0, then the pending value should not be considered.\n     */\n    function getFull(Delay self) internal view returns (uint32, uint32, uint48) {\n        return _getFullAt(self, timestamp());\n    }\n\n    /**\n     * @dev Get the current value.\n     */\n    function get(Delay self) internal view returns (uint32) {\n        (uint32 delay, , ) = self.getFull();\n        return delay;\n    }\n\n    /**\n     * @dev Update a Delay object so that it takes a new duration after a timepoint that is automatically computed to\n     * enforce the old delay at the moment of the update. Returns the updated Delay object and the timestamp when the\n     * new delay becomes effective.\n     */\n    function withUpdate(\n        Delay self,\n        uint32 newValue,\n        uint32 minSetback\n    ) internal view returns (Delay updatedDelay, uint48 effect) {\n        uint32 value = self.get();\n        uint32 setback = uint32(Math.max(minSetback, value > newValue ? value - newValue : 0));\n        effect = timestamp() + setback;\n        return (pack(value, newValue, effect), effect);\n    }\n\n    /**\n     * @dev Split a delay into its components: valueBefore, valueAfter and effect (transition timepoint).\n     */\n    function unpack(Delay self) internal pure returns (uint32 valueBefore, uint32 valueAfter, uint48 effect) {\n        uint112 raw = Delay.unwrap(self);\n\n        valueAfter = uint32(raw);\n        valueBefore = uint32(raw >> 32);\n        effect = uint48(raw >> 64);\n\n        return (valueBefore, valueAfter, effect);\n    }\n\n    /**\n     * @dev pack the components into a Delay object.\n     */\n    function pack(uint32 valueBefore, uint32 valueAfter, uint48 effect) internal pure returns (Delay) {\n        return Delay.wrap((uint112(effect) << 64) | (uint112(valueBefore) << 32) | uint112(valueAfter));\n    }\n}\n"
			},
			"src/JBERC20.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ERC20Permit, Nonces} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport {ERC20Votes, ERC20} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\";\n\nimport {IJBToken} from \"./interfaces/IJBToken.sol\";\n\n/// @notice An ERC-20 token that can be used by a project in `JBTokens` and `JBController`.\n/// @dev By default, a project uses \"credits\" to track balances. Once a project sets their `IJBToken` using\n/// `JBController.deployERC20For(...)` or `JBController.setTokenFor(...)`, credits can be redeemed to claim tokens.\n/// @dev `JBController.deployERC20For(...)` deploys a `JBERC20` contract and sets it as the project's token.\ncontract JBERC20 is ERC20Votes, ERC20Permit, Ownable, IJBToken {\n    //*********************************************************************//\n    // --------------------- internal stored properties ------------------ //\n    //*********************************************************************//\n\n    /// @notice The token's name.\n    string private _name;\n\n    /// @notice The token's symbol.\n    string private _symbol;\n\n    //*********************************************************************//\n    // -------------------------- public views --------------------------- //\n    //*********************************************************************//\n\n    /// @notice The token's name.\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /// @notice The token's symbol.\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /// @notice The number of decimals used for this token's fixed point accounting.\n    /// @return The number of decimals.\n    function decimals() public view override(ERC20, IJBToken) returns (uint8) {\n        return super.decimals();\n    }\n\n    /// @notice The total supply of this ERC20 i.e. the total number of tokens in existence.\n    /// @return The total supply of this ERC20, as a fixed point number.\n    function totalSupply() public view override(ERC20, IJBToken) returns (uint256) {\n        return super.totalSupply();\n    }\n\n    /// @notice The balance of the given address.\n    /// @param account The account to get the balance of.\n    /// @return The number of tokens owned by the `account`, as a fixed point number with 18 decimals.\n    function balanceOf(address account) public view override(ERC20, IJBToken) returns (uint256) {\n        return super.balanceOf(account);\n    }\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    constructor() Ownable(address(this)) ERC20(\"invalid\", \"invalid\") ERC20Permit(\"JBToken\") {}\n\n    //*********************************************************************//\n    // ---------------------- external transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice Mints more of this token.\n    /// @dev Can only be called by this contract's owner.\n    /// @param account The address to mint the new tokens to.\n    /// @param amount The amount of tokens to mint, as a fixed point number with 18 decimals.\n    function mint(address account, uint256 amount) external override onlyOwner {\n        return _mint(account, amount);\n    }\n\n    /// @notice Burn some outstanding tokens.\n    /// @dev Can only be called by this contract's owner.\n    /// @param account The address to burn tokens from.\n    /// @param amount The amount of tokens to burn, as a fixed point number with 18 decimals.\n    function burn(address account, uint256 amount) external override onlyOwner {\n        return _burn(account, amount);\n    }\n\n    //*********************************************************************//\n    // ----------------------- public transactions ----------------------- //\n    //*********************************************************************//\n\n    /// @notice Initializes the token.\n    /// @param name_ The token's name.\n    /// @param symbol_ The token's symbol.\n    /// @param owner The token contract's owner.\n    function initialize(string memory name_, string memory symbol_, address owner) public override {\n        // Prevent re-initialization by reverting if a name is already set or if the provided name is empty.\n        if (bytes(_name).length != 0 || bytes(name_).length == 0) revert();\n\n        _name = name_;\n        _symbol = symbol_;\n\n        // Transfer ownership to the owner.\n        _transferOwnership(owner);\n    }\n\n    /// @notice Required override.\n    function nonces(address owner) public view virtual override(ERC20Permit, Nonces) returns (uint256) {\n        return super.nonces(owner);\n    }\n\n    //*********************************************************************//\n    // ---------------------- internal transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice Required override.\n    function _update(address from, address to, uint256 value) internal virtual override(ERC20, ERC20Votes) {\n        super._update(from, to, value);\n    }\n}\n"
			},
			"src/interfaces/IJBToken.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBToken {\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function mint(address account, uint256 amount) external;\n\n    function burn(address account, uint256 amount) external;\n\n    function initialize(string memory name, string memory symbol, address owner) external;\n}\n"
			},
			"node_modules/@openzeppelin/contracts/proxy/Clones.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n */\nlibrary Clones {\n    /**\n     * @dev A clone instance deployment failed.\n     */\n    error ERC1167FailedCreateClone();\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        if (instance == address(0)) {\n            revert ERC1167FailedCreateClone();\n        }\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        if (instance == address(0)) {\n            revert ERC1167FailedCreateClone();\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
			},
			"src/JBTokens.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {Clones} from \"@openzeppelin/contracts/proxy/Clones.sol\";\n\nimport {JBControlled} from \"./abstract/JBControlled.sol\";\nimport {IJBDirectory} from \"./interfaces/IJBDirectory.sol\";\nimport {IJBToken} from \"./interfaces/IJBToken.sol\";\nimport {IJBTokens} from \"./interfaces/IJBTokens.sol\";\nimport {JBERC20} from \"./JBERC20.sol\";\n\n/// @notice Manages minting, burning, and balances of projects' tokens and token credits.\n/// @dev Token balances can either be ERC-20s or token credits. This contract manages these two representations and\n/// allows credit -> ERC-20 claiming.\n/// @dev The total supply of a project's tokens and the balance of each account are calculated in this contract.\n/// @dev An ERC-20 contract must be set by a project's owner for ERC-20 claiming to become available. Projects can bring\n/// their own IJBToken if they prefer.\ncontract JBTokens is JBControlled, IJBTokens {\n    //*********************************************************************//\n    // --------------------------- custom errors ------------------------- //\n    //*********************************************************************//\n\n    error TOKEN_ALREADY_SET();\n    error EMPTY_NAME();\n    error EMPTY_SYMBOL();\n    error EMPTY_TOKEN();\n    error INSUFFICIENT_FUNDS();\n    error INSUFFICIENT_CREDITS();\n    error PROJECT_ALREADY_HAS_TOKEN();\n    error RECIPIENT_ZERO_ADDRESS();\n    error TOKEN_NOT_FOUND();\n    error TOKENS_MUST_HAVE_18_DECIMALS();\n    error OVERFLOW_ALERT();\n\n    //*********************************************************************//\n    // --------------- public immutable stored properties ---------------- //\n    //*********************************************************************//\n\n    IJBToken public immutable TOKEN;\n\n    //*********************************************************************//\n    // --------------------- public stored properties -------------------- //\n    //*********************************************************************//\n\n    /// @notice Each project's attached token contract.\n    /// @custom:param projectId The ID of the project the token belongs to.\n    mapping(uint256 projectId => IJBToken) public override tokenOf;\n\n    /// @notice Each token's project.\n    /// @custom:param token The address of the token associated with the project.\n    mapping(IJBToken token => uint256) public override projectIdOf;\n\n    /// @notice The total supply of credits for each project.\n    /// @custom:param projectId The ID of the project to which the credits belong.\n    mapping(uint256 projectId => uint256) public override totalCreditSupplyOf;\n\n    /// @notice Each holder's credit balance for each project.\n    /// @custom:param holder The credit holder.\n    /// @custom:param projectId The ID of the project to which the credits belong.\n    mapping(address holder => mapping(uint256 projectId => uint256)) public override creditBalanceOf;\n\n    //*********************************************************************//\n    // ------------------------- external views -------------------------- //\n    //*********************************************************************//\n\n    /// @notice The total balance a holder has for a specified project, including both tokens and token credits.\n    /// @param holder The holder to get a balance for.\n    /// @param projectId The project to get the `_holder`s balance for.\n    /// @return balance The combined token and token credit balance of the `_holder\n    function totalBalanceOf(address holder, uint256 projectId) external view override returns (uint256 balance) {\n        // Get a reference to the holder's credits for the project.\n        balance = creditBalanceOf[holder][projectId];\n\n        // Get a reference to the project's current token.\n        IJBToken token = tokenOf[projectId];\n\n        // If the project has a current token, add the holder's balance to the total.\n        if (token != IJBToken(address(0))) {\n            balance = balance + token.balanceOf(holder);\n        }\n    }\n\n    //*********************************************************************//\n    // --------------------------- public views -------------------------- //\n    //*********************************************************************//\n\n    /// @notice The total supply for a specific project, including both tokens and token credits.\n    /// @param projectId The ID of the project to get the total supply of.\n    /// @return totalSupply The total supply of the project's tokens and token credits.\n    function totalSupplyOf(uint256 projectId) public view override returns (uint256 totalSupply) {\n        // Get a reference to the total supply of the project's credits\n        totalSupply = totalCreditSupplyOf[projectId];\n\n        // Get a reference to the project's current token.\n        IJBToken token = tokenOf[projectId];\n\n        // If the project has a current token, add its total supply to the total.\n        if (token != IJBToken(address(0))) {\n            totalSupply = totalSupply + token.totalSupply();\n        }\n    }\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param directory A contract storing directories of terminals and controllers for each project.\n    /// @param token The implementation of the token contract that project can deploy.\n    constructor(IJBDirectory directory, IJBToken token) JBControlled(directory) {\n        TOKEN = token;\n    }\n\n    //*********************************************************************//\n    // ---------------------- external transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice Deploys an ERC-20 token for a project. It will be used when claiming tokens.\n    /// @dev Deploys a project's ERC-20 token contract.\n    /// @dev Only a project's controller can deploy its token.\n    /// @param projectId The ID of the project to deploy an ERC-20 token for.\n    /// @param name The ERC-20's name.\n    /// @param symbol The ERC-20's symbol.\n    /// @return token The address of the token that was deployed.\n    function deployERC20For(\n        uint256 projectId,\n        string calldata name,\n        string calldata symbol,\n        bytes32 salt\n    )\n        external\n        override\n        onlyControllerOf(projectId)\n        returns (IJBToken token)\n    {\n        // There must be a name.\n        if (bytes(name).length == 0) revert EMPTY_NAME();\n\n        // There must be a symbol.\n        if (bytes(symbol).length == 0) revert EMPTY_SYMBOL();\n\n        // The project shouldn't already have a token.\n        if (tokenOf[projectId] != IJBToken(address(0))) revert PROJECT_ALREADY_HAS_TOKEN();\n\n        token = salt == bytes32(0)\n            ? IJBToken(Clones.clone(address(TOKEN)))\n            : IJBToken(Clones.cloneDeterministic(address(TOKEN), keccak256(abi.encode(msg.sender, salt))));\n\n        // Store the token contract.\n        tokenOf[projectId] = token;\n\n        // Store the project for the token.\n        projectIdOf[token] = projectId;\n\n        // Initialize the token.\n        token.initialize({name: name, symbol: symbol, owner: address(this)});\n\n        emit DeployERC20(projectId, token, name, symbol, salt, msg.sender);\n    }\n\n    /// @notice Set a project's token if not already set.\n    /// @dev Only a project's controller can set its token.\n    /// @param projectId The ID of the project to set the token of.\n    /// @param token The new token's address.\n    function setTokenFor(uint256 projectId, IJBToken token) external override onlyControllerOf(projectId) {\n        // Can't set to the zero address.\n        if (token == IJBToken(address(0))) revert EMPTY_TOKEN();\n\n        // Can't set a token if the project is already associated with another token.\n        if (tokenOf[projectId] != IJBToken(address(0))) revert TOKEN_ALREADY_SET();\n\n        // Can't set a token if it's already associated with another project.\n        if (projectIdOf[token] != 0) revert TOKEN_ALREADY_SET();\n\n        // Can't change to a token that doesn't use 18 decimals.\n        if (token.decimals() != 18) revert TOKENS_MUST_HAVE_18_DECIMALS();\n\n        // Store the new token.\n        tokenOf[projectId] = token;\n\n        // Store the project for the token.\n        projectIdOf[token] = projectId;\n\n        emit SetToken(projectId, token, msg.sender);\n    }\n\n    /// @notice Mint (create) new tokens or credits.\n    /// @dev Only a project's current controller can mint its tokens.\n    /// @param holder The address receiving the new tokens.\n    /// @param projectId The ID of the project to which the tokens belong.\n    /// @param amount The amount of tokens to mint.\n    function mintFor(address holder, uint256 projectId, uint256 amount) external override onlyControllerOf(projectId) {\n        // Get a reference to the project's current token.\n        IJBToken token = tokenOf[projectId];\n\n        // Save a reference to whether there a token exists.\n        bool shouldClaimTokens = token != IJBToken(address(0));\n\n        if (shouldClaimTokens) {\n            // If tokens should be claimed, mint tokens into the holder's wallet.\n            token.mint(holder, amount);\n        } else {\n            // Otherwise, add the tokens to their credits and the credit supply.\n            creditBalanceOf[holder][projectId] = creditBalanceOf[holder][projectId] + amount;\n            totalCreditSupplyOf[projectId] = totalCreditSupplyOf[projectId] + amount;\n        }\n\n        // The total supply can't exceed the maximum value storable in a uint208.\n        if (totalSupplyOf(projectId) > type(uint208).max) revert OVERFLOW_ALERT();\n\n        emit Mint(holder, projectId, amount, shouldClaimTokens, msg.sender);\n    }\n\n    /// @notice Burns (destroys) credits or tokens.\n    /// @dev Credits are burned first, then tokens are burned.\n    /// @dev Only a project's current controller can burn its tokens.\n    /// @param holder The address that owns the tokens which are being burned.\n    /// @param projectId The ID of the project to the burned tokens belong to.\n    /// @param amount The amount of tokens to burn.\n    function burnFrom(\n        address holder,\n        uint256 projectId,\n        uint256 amount\n    )\n        external\n        override\n        onlyControllerOf(projectId)\n    {\n        // Get a reference to the project's current token.\n        IJBToken token = tokenOf[projectId];\n\n        // Get a reference to the amount of credits the holder has.\n        uint256 creditBalance = creditBalanceOf[holder][projectId];\n\n        // Get a reference to the amount of the project's current token the holder has in their wallet.\n        uint256 tokenBalance = token == IJBToken(address(0)) ? 0 : token.balanceOf(holder);\n\n        // There must be enough tokens to burn across the holder's combined token and credit balance.\n        if (amount > tokenBalance + creditBalance) revert INSUFFICIENT_FUNDS();\n\n        // The amount of tokens to burn.\n        uint256 tokensToBurn;\n\n        // Get a reference to how many tokens should be burned\n        if (tokenBalance != 0) {\n            // Burn credits before tokens.\n            unchecked {\n                tokensToBurn = creditBalance < amount ? amount - creditBalance : 0;\n            }\n        }\n\n        // The amount of credits to burn.\n        uint256 creditsToBurn;\n        unchecked {\n            creditsToBurn = amount - tokensToBurn;\n        }\n\n        // Subtract the burned credits from the credit balance and credit supply.\n        if (creditsToBurn > 0) {\n            creditBalanceOf[holder][projectId] = creditBalanceOf[holder][projectId] - creditsToBurn;\n            totalCreditSupplyOf[projectId] = totalCreditSupplyOf[projectId] - creditsToBurn;\n        }\n\n        // Burn the tokens.\n        if (tokensToBurn > 0) token.burn(holder, tokensToBurn);\n\n        emit Burn(holder, projectId, amount, creditBalance, tokenBalance, msg.sender);\n    }\n\n    /// @notice Redeem credits to claim tokens into a holder's wallet.\n    /// @dev Only a project's controller can claim that project's tokens.\n    /// @param holder The owner of the credits being redeemed.\n    /// @param projectId The ID of the project whose tokens are being claimed.\n    /// @param amount The amount of tokens to claim.\n    /// @param beneficiary The account into which the claimed tokens will go.\n    function claimTokensFor(\n        address holder,\n        uint256 projectId,\n        uint256 amount,\n        address beneficiary\n    )\n        external\n        override\n        onlyControllerOf(projectId)\n    {\n        // Get a reference to the project's current token.\n        IJBToken token = tokenOf[projectId];\n\n        // The project must have a token contract attached.\n        if (token == IJBToken(address(0))) revert TOKEN_NOT_FOUND();\n\n        // Get a reference to the amount of credits the holder has.\n        uint256 creditBalance = creditBalanceOf[holder][projectId];\n\n        // There must be enough credits to claim.\n        if (creditBalance < amount) revert INSUFFICIENT_CREDITS();\n\n        unchecked {\n            // Subtract the claim amount from the holder's credit balance.\n            creditBalanceOf[holder][projectId] = creditBalance - amount;\n\n            // Subtract the claim amount from the project's total credit supply.\n            totalCreditSupplyOf[projectId] = totalCreditSupplyOf[projectId] - amount;\n        }\n\n        // Mint the equivalent amount of the project's token for the holder.\n        token.mint(beneficiary, amount);\n\n        emit ClaimTokens(holder, projectId, creditBalance, amount, beneficiary, msg.sender);\n    }\n\n    /// @notice Allows a holder to transfer credits to another account.\n    /// @dev Only a project's controller can transfer credits for that project.\n    /// @param holder The address to transfer credits from.\n    /// @param projectId The ID of the project whose credits are being transferred.\n    /// @param recipient The recipient of the credits.\n    /// @param amount The amount of credits to transfer.\n    function transferCreditsFrom(\n        address holder,\n        uint256 projectId,\n        address recipient,\n        uint256 amount\n    )\n        external\n        override\n        onlyControllerOf(projectId)\n    {\n        // Can't transfer to the zero address.\n        if (recipient == address(0)) revert RECIPIENT_ZERO_ADDRESS();\n\n        // Get a reference to the holder's unclaimed project token balance.\n        uint256 creditBalance = creditBalanceOf[holder][projectId];\n\n        // The holder must have enough unclaimed tokens to transfer.\n        if (amount > creditBalance) revert INSUFFICIENT_CREDITS();\n\n        // Subtract from the holder's unclaimed token balance.\n        unchecked {\n            creditBalanceOf[holder][projectId] = creditBalance - amount;\n        }\n\n        // Add the unclaimed project tokens to the recipient's balance.\n        creditBalanceOf[recipient][projectId] = creditBalanceOf[recipient][projectId] + amount;\n\n        emit TransferCredits(holder, projectId, recipient, amount, msg.sender);\n    }\n}\n"
			},
			"src/interfaces/IJBTokens.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBToken} from \"./IJBToken.sol\";\n\ninterface IJBTokens {\n    event DeployERC20(\n        uint256 indexed projectId, IJBToken indexed token, string name, string symbol, bytes32 salt, address caller\n    );\n\n    event Mint(\n        address indexed holder, uint256 indexed projectId, uint256 amount, bool tokensWereClaimed, address caller\n    );\n\n    event Burn(\n        address indexed holder,\n        uint256 indexed projectId,\n        uint256 amount,\n        uint256 initialCreditBalance,\n        uint256 initialTokenBalance,\n        address caller\n    );\n\n    event ClaimTokens(\n        address indexed holder,\n        uint256 indexed projectId,\n        uint256 initialCreditBalance,\n        uint256 amount,\n        address beneficiary,\n        address caller\n    );\n\n    event SetToken(uint256 indexed projectId, IJBToken indexed newToken, address caller);\n\n    event TransferCredits(\n        address indexed holder, uint256 indexed projectId, address indexed recipient, uint256 amount, address caller\n    );\n\n    function tokenOf(uint256 projectId) external view returns (IJBToken);\n\n    function projectIdOf(IJBToken token) external view returns (uint256);\n\n    function creditBalanceOf(address holder, uint256 projectId) external view returns (uint256);\n\n    function totalCreditSupplyOf(uint256 projectId) external view returns (uint256);\n\n    function totalSupplyOf(uint256 projectId) external view returns (uint256);\n\n    function totalBalanceOf(address holder, uint256 projectId) external view returns (uint256 result);\n\n    function deployERC20For(\n        uint256 projectId,\n        string calldata name,\n        string calldata symbol,\n        bytes32 salt\n    )\n        external\n        returns (IJBToken token);\n\n    function setTokenFor(uint256 projectId, IJBToken token) external;\n\n    function burnFrom(address holder, uint256 projectId, uint256 amount) external;\n\n    function mintFor(address holder, uint256 projectId, uint256 amount) external;\n\n    function claimTokensFor(address holder, uint256 projectId, uint256 amount, address beneficiary) external;\n\n    function transferCreditsFrom(address holder, uint256 projectId, address recipient, uint256 amount) external;\n}\n"
			},
			"src/JBFundAccessLimits.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {JBControlled} from \"./abstract/JBControlled.sol\";\nimport {IJBDirectory} from \"./interfaces/IJBDirectory.sol\";\nimport {IJBFundAccessLimits} from \"./interfaces/IJBFundAccessLimits.sol\";\nimport {JBCurrencyAmount} from \"./structs/JBCurrencyAmount.sol\";\nimport {JBFundAccessLimitGroup} from \"./structs/JBFundAccessLimitGroup.sol\";\n\n/// @notice Stores and manages terminal fund access limits for each project.\n/// @dev See the `JBFundAccessLimitGroup` struct to learn about payout limits and surplus allowances.\ncontract JBFundAccessLimits is JBControlled, IJBFundAccessLimits {\n    //*********************************************************************//\n    // --------------------------- custom errors ------------------------- //\n    //*********************************************************************//\n\n    error INVALID_PAYOUT_LIMIT();\n    error INVALID_PAYOUT_LIMIT_CURRENCY();\n    error INVALID_PAYOUT_LIMIT_CURRENCY_ORDERING();\n    error INVALID_SURPLUS_ALLOWANCE();\n    error INVALID_SURPLUS_ALLOWANCE_CURRENCY();\n    error INVALID_SURPLUS_ALLOWANCE_CURRENCY_ORDERING();\n\n    //*********************************************************************//\n    // --------------------- internal stored properties ------------------ //\n    //*********************************************************************//\n\n    /// @notice An array of packed payout limits for a given project, ruleset, terminal, and token.\n    /// @dev bits 0-223: The maximum amount (in a specific currency) of the terminal's `token`s that the project can pay\n    /// out during the ruleset.\n    /// @dev bits 224-255: The currency that the payout limit is denominated in. If this currency is different from the\n    /// terminal's `token`, the payout limit will vary depending on their exchange rate.\n    /// @custom:param projectId The project's ID.\n    /// @custom:param rulesetId The ruleset's ID.\n    /// @custom:param terminal The terminal to get the payout limits of.\n    /// @custom:param token The token to get the payout limits of.\n    mapping(\n        uint256 projectId\n            => mapping(uint256 rulesetId => mapping(address terminal => mapping(address token => uint256[])))\n    ) internal _packedPayoutLimitsDataOf;\n\n    /// @notice An array of packed surplus allowances for a given project, ruleset, terminal, and token.\n    /// @dev bits 0-223: The maximum amount (in a specific currency) of the terminal's `token`s that the project can\n    /// access from its surplus during the ruleset.\n    /// @dev bits 224-255: The currency that the surplus allowance is denominated in. If this currency is different from\n    /// the terminal's `token`, the surplus allowance will vary depending on their exchange rate.\n    /// @custom:param projectId The project's ID.\n    /// @custom:param rulesetId The ruleset's ID.\n    /// @custom:param terminal The terminal to get the surplus allowances of.\n    /// @custom:param token The token to get the surplus allowances of.\n    mapping(\n        uint256 projectId\n            => mapping(uint256 rulesetId => mapping(address terminal => mapping(address token => uint256[])))\n    ) internal _packedSurplusAllowancesDataOf;\n\n    //*********************************************************************//\n    // ------------------------- external views -------------------------- //\n    //*********************************************************************//\n\n    /// @notice A project's payout limits for a given ruleset, terminal, and token.\n    /// @notice The total value of `token`s that a project can pay out from the terminal during the ruleset is dictated\n    /// by a list of payout limits. Each payout limit is a fixed-point amount in terms of a currency.\n    /// @dev The fixed point `amount`s returned will use the same number of decimals as the `terminal`.\n    /// @param projectId The project's ID.\n    /// @param rulesetId The ruleset's ID.\n    /// @param terminal The terminal the payout limits apply to.\n    /// @param token The token the payout limits apply to.\n    /// @return payoutLimits The payout limits.\n    function payoutLimitsOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token\n    )\n        external\n        view\n        override\n        returns (JBCurrencyAmount[] memory payoutLimits)\n    {\n        // Get a reference to the packed payout limits.\n        uint256[] memory packedPayoutLimitsData = _packedPayoutLimitsDataOf[projectId][rulesetId][terminal][token];\n\n        // Get a reference to the number of payout limits.\n        uint256 numberOfData = packedPayoutLimitsData.length;\n\n        // Initialize the return array.\n        payoutLimits = new JBCurrencyAmount[](numberOfData);\n\n        // Get a reference to the packed payout limit being iterated on.\n        uint256 packedPayoutLimitData;\n\n        // Iterate through the packed values and format the returned value.\n        for (uint256 i; i < numberOfData; i++) {\n            // Set the data being iterated on.\n            packedPayoutLimitData = packedPayoutLimitsData[i];\n\n            // The limit amount is in bits 0-231. The currency is in bits 224-255.\n            payoutLimits[i] = JBCurrencyAmount({\n                currency: packedPayoutLimitData >> 224,\n                amount: uint256(uint224(packedPayoutLimitData))\n            });\n        }\n    }\n\n    /// @notice A project's payout limit for a given ruleset, terminal, token, and currency.\n    /// @dev The fixed point return amount will use the same number of decimals as the `terminal`.\n    /// @param projectId The project's ID.\n    /// @param rulesetId The ruleset's ID.\n    /// @param terminal The terminal the payout limit applies to.\n    /// @param token The token the payout limit applies to.\n    /// @param currency The currency the payout limit is denominated in.\n    /// @return payoutLimit The payout limit, as a fixed point number with the same number of decimals as the provided\n    /// terminal.\n    function payoutLimitOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token,\n        uint256 currency\n    )\n        external\n        view\n        override\n        returns (uint256 payoutLimit)\n    {\n        // Get a reference to the packed payout limits.\n        uint256[] memory data = _packedPayoutLimitsDataOf[projectId][rulesetId][terminal][token];\n\n        // Get a reference to the number of payout limits.\n        uint256 numberOfData = data.length;\n\n        // Get a reference to the packed payout limit being iterated on.\n        uint256 packedPayoutLimitData;\n\n        // Iterate through the stored packed values and return the value of the matching currency.\n        for (uint256 i; i < numberOfData; i++) {\n            // Set the data being iterated on.\n            packedPayoutLimitData = data[i];\n\n            // If the currencies match, return the value.\n            if (currency == packedPayoutLimitData >> 224) {\n                return uint256(uint224(packedPayoutLimitData));\n            }\n        }\n    }\n\n    /// @notice A project's surplus allowances for a given ruleset, terminal, and token.\n    /// @notice The total value of `token`s that a project can pay out from its surplus in a terminal during the ruleset\n    /// is dictated by a list of surplus allowances. Each surplus allowance is a fixed-point amount in terms of a\n    /// currency.\n    /// @dev The fixed point `amount`s returned will use the same number of decimals as the `terminal`.\n    /// @param projectId The project's ID.\n    /// @param rulesetId The ruleset's ID.\n    /// @param terminal The terminal the surplus allowances apply to.\n    /// @param token The token the surplus allowances apply to.\n    /// @return surplusAllowances The surplus allowances.\n    function surplusAllowancesOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token\n    )\n        external\n        view\n        override\n        returns (JBCurrencyAmount[] memory surplusAllowances)\n    {\n        // Get a reference to the packed surplus allowances.\n        uint256[] memory packedSurplusAllowancesData =\n            _packedSurplusAllowancesDataOf[projectId][rulesetId][terminal][token];\n\n        // Get a reference to the number of surplus allowances.\n        uint256 numberOfData = packedSurplusAllowancesData.length;\n\n        // Initialize the return array.\n        surplusAllowances = new JBCurrencyAmount[](numberOfData);\n\n        // Get a reference to the packed surplus allowance being iterated on.\n        uint256 packedSurplusAllowanceData;\n\n        // Iterate through the stored packed values and format the returned value.\n        for (uint256 i; i < numberOfData; i++) {\n            // Set the data being iterated on.\n            packedSurplusAllowanceData = packedSurplusAllowancesData[i];\n\n            // The limit is in bits 0-223. The currency is in bits 224-255.\n            surplusAllowances[i] = JBCurrencyAmount({\n                currency: packedSurplusAllowanceData >> 224,\n                amount: uint256(uint224(packedSurplusAllowanceData))\n            });\n        }\n    }\n\n    /// @notice A project's surplus allowance for a given ruleset, terminal, token, and currency.\n    /// @dev The fixed point return amount will use the same number of decimals as the `terminal`.\n    /// @param projectId The project's ID.\n    /// @param rulesetId The ruleset's ID.\n    /// @param terminal The terminal the surplus allowance applies to.\n    /// @param token The token the surplus allowance applies to.\n    /// @param currency The currency that the surplus allowance is denominated in.\n    /// @return surplusAllowance The surplus allowance, as a fixed point number with the same number of decimals as the\n    /// provided terminal.\n    function surplusAllowanceOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token,\n        uint256 currency\n    )\n        external\n        view\n        override\n        returns (uint256 surplusAllowance)\n    {\n        // Get a reference to the packed surplus allowances.\n        uint256[] memory packedSurplusAllowancesData =\n            _packedSurplusAllowancesDataOf[projectId][rulesetId][terminal][token];\n\n        // Get a reference to the number of surplus allowances.\n        uint256 numberOfData = packedSurplusAllowancesData.length;\n\n        // Get a reference to the packed surplus allowance being iterated on.\n        uint256 packedSurplusAllowanceData;\n\n        // Iterate through the stored packed values and format the returned value.\n        for (uint256 i; i < numberOfData; i++) {\n            // Set the data being iterated on.\n            packedSurplusAllowanceData = packedSurplusAllowancesData[i];\n\n            // If the currencies match, return the value.\n            if (currency == packedSurplusAllowanceData >> 224) {\n                return uint256(uint224(packedSurplusAllowanceData));\n            }\n        }\n    }\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param directory A contract storing the terminals and the controller used by each project.\n    // solhint-disable-next-line no-empty-blocks\n    constructor(IJBDirectory directory) JBControlled(directory) {}\n\n    //*********************************************************************//\n    // --------------------- external transactions ----------------------- //\n    //*********************************************************************//\n\n    /// @notice Sets limits on the amount of funds a project can access from its terminals during a ruleset.\n    /// @dev Only a project's controller can set its fund access limits.\n    /// @dev Payout limits and surplus allowances must be specified in strictly increasing order (by currency) to\n    /// prevent duplicates.\n    /// @param projectId The ID of the project whose fund access limits are being set.\n    /// @param rulesetId The ID of the ruleset that the limits will apply within.\n    /// @param fundAccessLimitGroup An array containing payout limits and surplus allowances for each payment terminal.\n    /// Amounts are fixed point numbers using the same number of decimals as the associated terminal.\n    function setFundAccessLimitsFor(\n        uint256 projectId,\n        uint256 rulesetId,\n        JBFundAccessLimitGroup[] calldata fundAccessLimitGroup\n    )\n        external\n        override\n        onlyControllerOf(projectId)\n    {\n        // Save the number of fund access limit groups.\n        uint256 numberOfFundAccessLimitGroups = fundAccessLimitGroup.length;\n\n        // Keep a reference to the fund access limit group being iterated on.\n        JBFundAccessLimitGroup calldata limits;\n\n        // Set payout limits if there are any.\n        for (uint256 i; i < numberOfFundAccessLimitGroups; i++) {\n            // Set the limits being iterated on.\n            limits = fundAccessLimitGroup[i];\n\n            // Keep a reference to the number of payout limits.\n            uint256 numberOfPayoutLimits = limits.payoutLimits.length;\n\n            // Keep a reference to the payout limit being iterated on.\n            JBCurrencyAmount calldata payoutLimit;\n\n            // Iterate through each payout limit to validate and store them.\n            for (uint256 j; j < numberOfPayoutLimits; j++) {\n                // Set the payout limit being iterated on.\n                payoutLimit = limits.payoutLimits[j];\n\n                // If payout limit amount is larger than 224 bits, revert.\n                if (payoutLimit.amount > type(uint224).max) {\n                    revert INVALID_PAYOUT_LIMIT();\n                }\n\n                // If payout limit currency's index is larger than 32 bits, revert.\n                if (payoutLimit.currency > type(uint32).max) {\n                    revert INVALID_PAYOUT_LIMIT_CURRENCY();\n                }\n\n                // Make sure the payout limits are passed in strictly increasing order (sorted by currency) to prevent\n                // duplicates.\n                if (j != 0 && payoutLimit.currency <= limits.payoutLimits[j - 1].currency) {\n                    revert INVALID_PAYOUT_LIMIT_CURRENCY_ORDERING();\n                }\n\n                // Set the payout limit if there is one.\n                if (payoutLimit.amount > 0) {\n                    _packedPayoutLimitsDataOf[projectId][rulesetId][fundAccessLimitGroup[i].terminal][fundAccessLimitGroup[i]\n                        .token].push(payoutLimit.amount | (payoutLimit.currency << 224));\n                }\n            }\n\n            // Keep a reference to the number of surplus allowances.\n            uint256 numberOfSurplusAllowances = limits.surplusAllowances.length;\n\n            // Keep a reference to the surplus allowances being iterated on.\n            JBCurrencyAmount calldata surplusAllowance;\n\n            // Iterate through each surplus allowance to validate and store them.\n            for (uint256 j; j < numberOfSurplusAllowances; j++) {\n                // Set the payout limit being iterated on.\n                surplusAllowance = limits.surplusAllowances[j];\n\n                // If surplus allowance is larger than 224 bits, revert.\n                if (surplusAllowance.amount > type(uint224).max) {\n                    revert INVALID_SURPLUS_ALLOWANCE();\n                }\n\n                // If surplus allowance currency value is larger than 32 bits, revert.\n                if (surplusAllowance.currency > type(uint32).max) {\n                    revert INVALID_SURPLUS_ALLOWANCE_CURRENCY();\n                }\n\n                // Make sure the surplus allowances are passed in strictly increasing order (sorted by currency) to\n                // prevent duplicates.\n                if (j != 0 && surplusAllowance.currency <= limits.surplusAllowances[j - 1].currency) {\n                    revert INVALID_SURPLUS_ALLOWANCE_CURRENCY_ORDERING();\n                }\n\n                // Set the surplus allowance if there is one.\n                if (surplusAllowance.amount > 0) {\n                    _packedSurplusAllowancesDataOf[projectId][rulesetId][fundAccessLimitGroup[i].terminal][fundAccessLimitGroup[i]\n                        .token].push(surplusAllowance.amount | (surplusAllowance.currency << 224));\n                }\n            }\n\n            emit SetFundAccessLimits(rulesetId, projectId, limits, msg.sender);\n        }\n    }\n}\n"
			},
			"src/interfaces/IJBFundAccessLimits.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBCurrencyAmount} from \"./../structs/JBCurrencyAmount.sol\";\nimport {JBFundAccessLimitGroup} from \"./../structs/JBFundAccessLimitGroup.sol\";\n\ninterface IJBFundAccessLimits {\n    event SetFundAccessLimits(\n        uint256 indexed rulesetId, uint256 indexed projectId, JBFundAccessLimitGroup limits, address caller\n    );\n\n    function payoutLimitsOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token\n    )\n        external\n        view\n        returns (JBCurrencyAmount[] memory payoutLimits);\n\n    function payoutLimitOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256 payoutLimit);\n\n    function surplusAllowancesOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token\n    )\n        external\n        view\n        returns (JBCurrencyAmount[] memory surplusAllowances);\n\n    function surplusAllowanceOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        address terminal,\n        address token,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256 surplusAllowance);\n\n    function setFundAccessLimitsFor(\n        uint256 projectId,\n        uint256 rulesetId,\n        JBFundAccessLimitGroup[] memory fundAccessConstaints\n    )\n        external;\n}\n"
			},
			"src/structs/JBCurrencyAmount.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member amount The amount of the currency.\n/// @custom:member currency The currency's index in `JBCurrencyIds`.\nstruct JBCurrencyAmount {\n    uint256 amount;\n    uint256 currency;\n}\n"
			},
			"src/structs/JBFundAccessLimitGroup.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBCurrencyAmount} from \"./JBCurrencyAmount.sol\";\n\n/// @dev Payout limit example: if the `amount` is 5, the `currency` is 1 (USD), and the terminal's token is ETH, then\n/// the project can pay out 5 USD worth of ETH during a ruleset.\n/// @dev Surplus allowance example: if the `amount` is 5, the `currency` is 1 (USD), and the terminal's token is ETH,\n/// then the project can pay out 5 USD worth of ETH from its surplus during a ruleset. A project's surplus is its\n/// balance minus its current combined payout limit.\n/// @dev If a project has multiple payout limits or surplus allowances, they are all available. They can all be used\n/// during a single ruleset.\n/// @dev The payout limits' and surplus allowances' fixed point amounts have the same number of decimals as the\n/// terminal.\n/// @custom:member terminal The terminal that the payout limits and surplus allowances apply to.\n/// @custom:member token The token that the payout limits and surplus allowances apply to within the `terminal`.\n/// @custom:member payoutLimits An array of payout limits. The payout limits cumulatively dictate the maximum value of\n/// `token`s a project can pay out from its balance in a terminal during a ruleset. Each payout limit can have a unique\n/// currency and amount.\n/// @custom:member surplusAllowances An array of surplus allowances. The surplus allowances cumulatively dictates the\n/// maximum value of `token`s a project can pay out from its surplus (balance less payouts) in a terminal during a\n/// ruleset. Each surplus allowance can have a unique currency and amount.\nstruct JBFundAccessLimitGroup {\n    address terminal;\n    address token;\n    JBCurrencyAmount[] payoutLimits;\n    JBCurrencyAmount[] surplusAllowances;\n}\n"
			},
			"node_modules/@openzeppelin/contracts/metatx/ERC2771Context.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (metatx/ERC2771Context.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Context variant with ERC2771 support.\n *\n * WARNING: Avoid using this pattern in contracts that rely in a specific calldata length as they'll\n * be affected by any forwarder whose `msg.data` is suffixed with the `from` address according to the ERC2771\n * specification adding the address size in bytes (20) to the calldata size. An example of an unexpected\n * behavior could be an unintended fallback (or another function) invocation while trying to invoke the `receive`\n * function only accessible if `msg.data.length == 0`.\n *\n * WARNING: The usage of `delegatecall` in this contract is dangerous and may result in context corruption.\n * Any forwarded request to this contract triggering a `delegatecall` to itself will result in an invalid {_msgSender}\n * recovery.\n */\nabstract contract ERC2771Context is Context {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address private immutable _trustedForwarder;\n\n    /**\n     * @dev Initializes the contract with a trusted forwarder, which will be able to\n     * invoke functions on this contract on behalf of other accounts.\n     *\n     * NOTE: The trusted forwarder can be replaced by overriding {trustedForwarder}.\n     */\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address trustedForwarder_) {\n        _trustedForwarder = trustedForwarder_;\n    }\n\n    /**\n     * @dev Returns the address of the trusted forwarder.\n     */\n    function trustedForwarder() public view virtual returns (address) {\n        return _trustedForwarder;\n    }\n\n    /**\n     * @dev Indicates whether any particular address is the trusted forwarder.\n     */\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\n        return forwarder == trustedForwarder();\n    }\n\n    /**\n     * @dev Override for `msg.sender`. Defaults to the original `msg.sender` whenever\n     * a call is not performed by the trusted forwarder or the calldata length is less than\n     * 20 bytes (an address length).\n     */\n    function _msgSender() internal view virtual override returns (address) {\n        uint256 calldataLength = msg.data.length;\n        uint256 contextSuffixLength = _contextSuffixLength();\n        if (isTrustedForwarder(msg.sender) && calldataLength >= contextSuffixLength) {\n            return address(bytes20(msg.data[calldataLength - contextSuffixLength:]));\n        } else {\n            return super._msgSender();\n        }\n    }\n\n    /**\n     * @dev Override for `msg.data`. Defaults to the original `msg.data` whenever\n     * a call is not performed by the trusted forwarder or the calldata length is less than\n     * 20 bytes (an address length).\n     */\n    function _msgData() internal view virtual override returns (bytes calldata) {\n        uint256 calldataLength = msg.data.length;\n        uint256 contextSuffixLength = _contextSuffixLength();\n        if (isTrustedForwarder(msg.sender) && calldataLength >= contextSuffixLength) {\n            return msg.data[:calldataLength - contextSuffixLength];\n        } else {\n            return super._msgData();\n        }\n    }\n\n    /**\n     * @dev ERC-2771 specifies the context as being a single address (20 bytes).\n     */\n    function _contextSuffixLength() internal view virtual override returns (uint256) {\n        return 20;\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/Address.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
			},
			"src/JBController.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {JBPermissionIds} from \"@bananapus/permission-ids/src/JBPermissionIds.sol\";\nimport {ERC2771Context} from \"@openzeppelin/contracts/metatx/ERC2771Context.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {mulDiv} from \"@prb/math/src/Common.sol\";\n\nimport {JBPermissioned} from \"./abstract/JBPermissioned.sol\";\nimport {JBApprovalStatus} from \"./enums/JBApprovalStatus.sol\";\nimport {IJBController} from \"./interfaces/IJBController.sol\";\nimport {IJBDirectory} from \"./interfaces/IJBDirectory.sol\";\nimport {IJBDirectoryAccessControl} from \"./interfaces/IJBDirectoryAccessControl.sol\";\nimport {IJBFundAccessLimits} from \"./interfaces/IJBFundAccessLimits.sol\";\nimport {IJBMigratable} from \"./interfaces/IJBMigratable.sol\";\nimport {IJBPermissioned} from \"./interfaces/IJBPermissioned.sol\";\nimport {IJBPermissions} from \"./interfaces/IJBPermissions.sol\";\nimport {IJBProjects} from \"./interfaces/IJBProjects.sol\";\nimport {IJBProjectUriRegistry} from \"./interfaces/IJBProjectUriRegistry.sol\";\nimport {IJBRulesets} from \"./interfaces/IJBRulesets.sol\";\nimport {IJBRulesetDataHook} from \"./interfaces/IJBRulesetDataHook.sol\";\nimport {IJBSplitHook} from \"./interfaces/IJBSplitHook.sol\";\nimport {IJBSplits} from \"./interfaces/IJBSplits.sol\";\nimport {IJBTerminal} from \"./interfaces/IJBTerminal.sol\";\nimport {IJBToken} from \"./interfaces/IJBToken.sol\";\nimport {IJBTokens} from \"./interfaces/IJBTokens.sol\";\nimport {JBConstants} from \"./libraries/JBConstants.sol\";\nimport {JBRulesetMetadataResolver} from \"./libraries/JBRulesetMetadataResolver.sol\";\nimport {JBSplitGroupIds} from \"./libraries/JBSplitGroupIds.sol\";\nimport {JBRuleset} from \"./structs/JBRuleset.sol\";\nimport {JBRulesetConfig} from \"./structs/JBRulesetConfig.sol\";\nimport {JBRulesetMetadata} from \"./structs/JBRulesetMetadata.sol\";\nimport {JBRulesetWithMetadata} from \"./structs/JBRulesetWithMetadata.sol\";\nimport {JBSplit} from \"./structs/JBSplit.sol\";\nimport {JBSplitGroup} from \"./structs/JBSplitGroup.sol\";\nimport {JBSplitHookContext} from \"./structs/JBSplitHookContext.sol\";\nimport {JBTerminalConfig} from \"./structs/JBTerminalConfig.sol\";\n\n/// @notice `JBController` coordinates rulesets and project tokens, and is the entry point for most operations related\n/// to rulesets and project tokens.\ncontract JBController is JBPermissioned, ERC2771Context, IJBController, IJBMigratable {\n    // A library that parses packed ruleset metadata into a friendlier format.\n    using JBRulesetMetadataResolver for JBRuleset;\n\n    // A library that adds default safety checks to ERC20 functionality.\n    using SafeERC20 for IERC20;\n\n    //*********************************************************************//\n    // --------------------------- custom errors ------------------------- //\n    //*********************************************************************//\n\n    error CREDIT_TRANSFERS_PAUSED();\n    error RULESETS_ARRAY_EMPTY();\n    error INVALID_BASE_CURRENCY();\n    error INVALID_REDEMPTION_RATE();\n    error INVALID_RESERVED_RATE();\n    error CONTROLLER_MIGRATION_NOT_ALLOWED();\n    error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_OR_HOOK();\n    error NO_BURNABLE_TOKENS();\n    error NO_RESERVED_TOKENS();\n    error RULESETS_ALREADY_LAUNCHED();\n    error ZERO_TOKENS_TO_MINT();\n    error RULESET_SET_TOKEN_DISABLED();\n\n    //*********************************************************************//\n    // --------------- public immutable stored properties ---------------- //\n    //*********************************************************************//\n\n    /// @notice Mints ERC-721s that represent project ownership and transfers.\n    IJBProjects public immutable override PROJECTS;\n\n    /// @notice The directory of terminals and controllers for projects.\n    IJBDirectory public immutable override DIRECTORY;\n\n    /// @notice The contract storing and managing project rulesets.\n    IJBRulesets public immutable override RULESETS;\n\n    /// @notice The contract that manages token minting and burning.\n    IJBTokens public immutable override TOKENS;\n\n    /// @notice The contract that stores splits for each project.\n    IJBSplits public immutable override SPLITS;\n\n    /// @notice A contract that stores fund access limits for each project.\n    IJBFundAccessLimits public immutable override FUND_ACCESS_LIMITS;\n\n    //*********************************************************************//\n    // --------------------- public stored properties -------------------- //\n    //*********************************************************************//\n\n    /// @notice A project's unrealized reserved token balance (i.e. reserved tokens which haven't been sent out to the\n    /// reserved token split group yet).\n    /// @custom:param projectId The ID of the project to get the pending reserved token balance of.\n    mapping(uint256 projectId => uint256) public override pendingReservedTokenBalanceOf;\n\n    /// @notice The metadata URI for each project. This is typically an IPFS hash, optionally with an `ipfs://` prefix.\n    /// @custom:param projectId The ID of the project to get the metadata URI of.\n    mapping(uint256 projectId => string) public override uriOf;\n\n    //*********************************************************************//\n    // ------------------------- external views -------------------------- //\n    //*********************************************************************//\n\n    /// @notice Gets the a project token's total supply, including pending reserved tokens.\n    /// @param projectId The ID of the project to get the total token supply of.\n    /// @return The total supply of the project's token, including pending reserved tokens.\n    function totalTokenSupplyWithReservedTokensOf(uint256 projectId) external view override returns (uint256) {\n        // Add the reserved tokens to the total supply.\n        return TOKENS.totalSupplyOf(projectId) + pendingReservedTokenBalanceOf[projectId];\n    }\n\n    /// @notice Get the `JBRuleset` and `JBRulesetMetadata` corresponding to the specified `rulesetId`.\n    /// @param projectId The ID of the project the ruleset belongs to.\n    /// @return ruleset The ruleset's struct.\n    /// @return metadata The ruleset's metadata.\n    function getRulesetOf(\n        uint256 projectId,\n        uint256 rulesetId\n    )\n        external\n        view\n        override\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata)\n    {\n        ruleset = RULESETS.getRulesetOf(projectId, rulesetId);\n        metadata = ruleset.expandMetadata();\n    }\n\n    /// @notice Gets the latest ruleset queued for a project, its approval status, and its metadata.\n    /// @dev The 'latest queued ruleset' is the ruleset initialized furthest in the future (at the end of the ruleset\n    /// queue).\n    /// @param projectId The ID of the project to get the latest ruleset of.\n    /// @return ruleset The struct for the project's latest queued ruleset.\n    /// @return metadata The ruleset's metadata.\n    /// @return approvalStatus The ruleset's approval status.\n    function latestQueuedRulesetOf(uint256 projectId)\n        external\n        view\n        override\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata, JBApprovalStatus approvalStatus)\n    {\n        (ruleset, approvalStatus) = RULESETS.latestQueuedRulesetOf(projectId);\n        metadata = ruleset.expandMetadata();\n    }\n\n    /// @notice Get an array of a project's rulesets (with metadata) up to a maximum array size, sorted from latest to\n    /// earliest.\n    /// @param projectId The ID of the project to get the rulesets of.\n    /// @param startingId The ID of the ruleset to begin with. This will be the latest ruleset in the result. If the\n    /// `startingId` is 0, passed, the project's latest ruleset will be used.\n    /// @param size The maximum number of rulesets to return.\n    /// @return rulesets The array of rulesets with their metadata.\n    function rulesetsOf(\n        uint256 projectId,\n        uint256 startingId,\n        uint256 size\n    )\n        external\n        view\n        override\n        returns (JBRulesetWithMetadata[] memory rulesets)\n    {\n        // Get the rulesets (without metadata).\n        JBRuleset[] memory baseRulesets = RULESETS.rulesetsOf(projectId, startingId, size);\n\n        // Keep a reference to the number of rulesets.\n        uint256 numberOfRulesets = baseRulesets.length;\n\n        // Initialize the array being returned.\n        rulesets = new JBRulesetWithMetadata[](numberOfRulesets);\n\n        // Keep a reference to the ruleset being iterated on.\n        JBRuleset memory baseRuleset;\n\n        // Populate the array with rulesets AND their metadata.\n        for (uint256 i; i < numberOfRulesets; i++) {\n            // Set the ruleset being iterated on.\n            baseRuleset = baseRulesets[i];\n\n            // Set the returned value.\n            rulesets[i] = JBRulesetWithMetadata({ruleset: baseRuleset, metadata: baseRuleset.expandMetadata()});\n        }\n    }\n\n    /// @notice A project's currently active ruleset and its metadata.\n    /// @param projectId The ID of the project to get the current ruleset of.\n    /// @return ruleset The current ruleset's struct.\n    /// @return metadata The current ruleset's metadata.\n    function currentRulesetOf(uint256 projectId)\n        external\n        view\n        override\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata)\n    {\n        ruleset = RULESETS.currentOf(projectId);\n        metadata = ruleset.expandMetadata();\n    }\n\n    /// @notice A project's next ruleset along with its metadata.\n    /// @dev If an upcoming ruleset isn't found, returns an empty ruleset with all properties set to 0.\n    /// @param projectId The ID of the project to get the next ruleset of.\n    /// @return ruleset The upcoming ruleset's struct.\n    /// @return metadata The upcoming ruleset's metadata.\n    function upcomingRulesetOf(uint256 projectId)\n        external\n        view\n        override\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata)\n    {\n        ruleset = RULESETS.upcomingOf(projectId);\n        metadata = ruleset.expandMetadata();\n    }\n\n    /// @notice Check whether the project's terminals can currently be set.\n    /// @param projectId The ID of the project to check.\n    /// @return A `bool` which is true if the project allows terminals to be set.\n    function setTerminalsAllowed(uint256 projectId) external view returns (bool) {\n        return RULESETS.currentOf(projectId).expandMetadata().allowSetTerminals;\n    }\n\n    /// @notice Check whether the project's controller can currently be set.\n    /// @param projectId The ID of the project to check.\n    /// @return A `bool` which is true if the project allows controllers to be set.\n    function setControllerAllowed(uint256 projectId) external view returns (bool) {\n        return RULESETS.currentOf(projectId).expandMetadata().allowSetController;\n    }\n\n    //*********************************************************************//\n    // -------------------------- public views --------------------------- //\n    //*********************************************************************//\n\n    /// @notice Indicates whether this contract adheres to the specified interface.\n    /// @dev See {IERC165-supportsInterface}.\n    /// @param interfaceId The ID of the interface to check for adherence to.\n    /// @return A flag indicating if the provided interface ID is supported.\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IJBController).interfaceId || interfaceId == type(IJBProjectUriRegistry).interfaceId\n            || interfaceId == type(IJBDirectoryAccessControl).interfaceId || interfaceId == type(IJBMigratable).interfaceId\n            || interfaceId == type(IJBPermissioned).interfaceId || interfaceId == type(IERC165).interfaceId;\n    }\n\n    //*********************************************************************//\n    // ---------------------------- constructor -------------------------- //\n    //*********************************************************************//\n\n    /// @param permissions A contract storing permissions.\n    /// @param projects A contract which mints ERC-721s that represent project ownership and transfers.\n    /// @param directory A contract storing directories of terminals and controllers for each project.\n    /// @param rulesets A contract storing and managing project rulesets.\n    /// @param tokens A contract that manages token minting and burning.\n    /// @param splits A contract that stores splits for each project.\n    /// @param fundAccessLimits A contract that stores fund access limits for each project.\n    constructor(\n        IJBPermissions permissions,\n        IJBProjects projects,\n        IJBDirectory directory,\n        IJBRulesets rulesets,\n        IJBTokens tokens,\n        IJBSplits splits,\n        IJBFundAccessLimits fundAccessLimits,\n        address trustedForwarder\n    )\n        JBPermissioned(permissions)\n        ERC2771Context(trustedForwarder)\n    {\n        PROJECTS = projects;\n        DIRECTORY = directory;\n        RULESETS = rulesets;\n        TOKENS = tokens;\n        SPLITS = splits;\n        FUND_ACCESS_LIMITS = fundAccessLimits;\n    }\n\n    //*********************************************************************//\n    // --------------------- external transactions ----------------------- //\n    //*********************************************************************//\n\n    /// @notice Creates a project.\n    /// @dev This will mint the project's ERC-721 to the `owner`'s address, queue the specified rulesets, and set up the\n    /// specified splits and terminals. Each operation within this transaction can be done in sequence separately.\n    /// @dev Anyone can deploy a project to any `owner`'s address.\n    /// @param owner The project's owner. The project ERC-721 will be minted to this address.\n    /// @param projectUri The project's metadata URI. This is typically an IPFS hash, optionally with the `ipfs://`\n    /// prefix. This can be updated by the project's owner.\n    /// @param rulesetConfigurations The rulesets to queue.\n    /// @param terminalConfigurations The terminals to set up for the project.\n    /// @param memo A memo to pass along to the emitted event.\n    /// @return projectId The project's ID.\n    function launchProjectFor(\n        address owner,\n        string calldata projectUri,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        JBTerminalConfig[] calldata terminalConfigurations,\n        string memory memo\n    )\n        external\n        virtual\n        override\n        returns (uint256 projectId)\n    {\n        // Mint the project ERC-721 into the owner's wallet.\n        projectId = PROJECTS.createFor(owner);\n\n        // If provided, set the project's metadata URI.\n        if (bytes(projectUri).length > 0) {\n            uriOf[projectId] = projectUri;\n        }\n\n        // Set this contract as the project's controller in the directory.\n        DIRECTORY.setControllerOf(projectId, IERC165(this));\n\n        // Queue the rulesets.\n        uint256 rulesetId = _queueRulesets(projectId, rulesetConfigurations);\n\n        // Configure the terminals.\n        _configureTerminals(projectId, terminalConfigurations);\n\n        emit LaunchProject(rulesetId, projectId, projectUri, memo, _msgSender());\n    }\n\n    /// @notice Queue a project's initial rulesets and set up terminals for it. Projects which already have rulesets\n    /// should use `queueRulesetsOf(...)`.\n    /// @dev Each operation within this transaction can be done in sequence separately.\n    /// @dev Can only be called by the project's owner or an address with the owner's permission to `QUEUE_RULESETS`.\n    /// @param projectId The ID of the project to launch rulesets for.\n    /// @param rulesetConfigurations The rulesets to queue.\n    /// @param terminalConfigurations The terminals to set up.\n    /// @param memo A memo to pass along to the emitted event.\n    /// @return rulesetId The ID of the last successfully queued ruleset.\n    function launchRulesetsFor(\n        uint256 projectId,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        JBTerminalConfig[] calldata terminalConfigurations,\n        string memory memo\n    )\n        external\n        virtual\n        override\n        returns (uint256 rulesetId)\n    {\n        if (rulesetConfigurations.length == 0) revert RULESETS_ARRAY_EMPTY();\n\n        // Enforce permissions.\n        _requirePermissionFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.QUEUE_RULESETS\n        });\n\n        // Enforce permissions.\n        _requirePermissionFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.SET_TERMINALS\n        });\n\n        // If the project has already had rulesets, use `queueRulesetsOf(...)` instead.\n        if (RULESETS.latestRulesetIdOf(projectId) > 0) {\n            revert RULESETS_ALREADY_LAUNCHED();\n        }\n\n        // Set this contract as the project's controller in the directory.\n        DIRECTORY.setControllerOf(projectId, IERC165(this));\n\n        // Queue the first ruleset.\n        rulesetId = _queueRulesets(projectId, rulesetConfigurations);\n\n        // Configure the terminals.\n        _configureTerminals(projectId, terminalConfigurations);\n\n        emit LaunchRulesets(rulesetId, projectId, memo, _msgSender());\n    }\n\n    /// @notice Add one or more rulesets to the end of a project's ruleset queue. Rulesets take effect after the\n    /// previous ruleset in the queue ends, and only if they are approved by the previous ruleset's approval hook.\n    /// @dev Can only be called by the project's owner or an address with the owner's permission to `QUEUE_RULESETS`.\n    /// @param projectId The ID of the project to queue rulesets for.\n    /// @param rulesetConfigurations The rulesets to queue.\n    /// @param memo A memo to pass along to the emitted event.\n    /// @return rulesetId The ID of the last ruleset which was successfully queued.\n    function queueRulesetsOf(\n        uint256 projectId,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        string calldata memo\n    )\n        external\n        virtual\n        override\n        returns (uint256 rulesetId)\n    {\n        // Enforce permissions.\n        _requirePermissionFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.QUEUE_RULESETS\n        });\n\n        // Queue the rulesets.\n        rulesetId = _queueRulesets(projectId, rulesetConfigurations);\n\n        emit QueueRulesets(rulesetId, projectId, memo, _msgSender());\n    }\n\n    /// @notice Add new project tokens or credits to the specified beneficiary's balance. Optionally, reserve a portion\n    /// according to the ruleset's reserved rate.\n    /// @dev Can only be called by the project's owner, an address with the owner's permission to `MINT_TOKENS`, one of\n    /// the project's terminals, or the project's data hook.\n    /// @dev If the ruleset's metadata has `allowOwnerMinting` set to `false`, this function can only be called by the\n    /// project's terminals or data hook.\n    /// @param projectId The ID of the project whose tokens are being minted.\n    /// @param tokenCount The number of tokens to mint, including any reserved tokens.\n    /// @param beneficiary The address which will receive the (non-reserved) tokens.\n    /// @param memo A memo to pass along to the emitted event.\n    /// @param useReservedRate Whether to apply the ruleset's reserved rate.\n    /// @return beneficiaryTokenCount The number of tokens minted for the `beneficiary`.\n    function mintTokensOf(\n        uint256 projectId,\n        uint256 tokenCount,\n        address beneficiary,\n        string calldata memo,\n        bool useReservedRate\n    )\n        external\n        virtual\n        override\n        returns (uint256 beneficiaryTokenCount)\n    {\n        // There should be tokens to mint.\n        if (tokenCount == 0) revert ZERO_TOKENS_TO_MINT();\n\n        // Keep a reference to the reserved rate.\n        uint256 reservedRate;\n\n        // Get a reference to the project's ruleset.\n        JBRuleset memory ruleset = RULESETS.currentOf(projectId);\n\n        // Minting is restricted to: the project's owner, addresses with permission to `MINT_TOKENS`, the project's\n        // terminals, and the project's data hook.\n        _requirePermissionAllowingOverrideFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.MINT_TOKENS,\n            alsoGrantAccessIf: DIRECTORY.isTerminalOf(projectId, IJBTerminal(_msgSender()))\n                || _msgSender() == ruleset.dataHook()\n                || (\n                    ruleset.dataHook() != address(0)\n                        && IJBRulesetDataHook(ruleset.dataHook()).hasMintPermissionFor(projectId, _msgSender())\n                )\n        });\n\n        // If the message sender is not the project's terminal or data hook, the ruleset must have `allowOwnerMinting`\n        // set to `true`.\n        if (\n            ruleset.id != 0 && !ruleset.allowOwnerMinting()\n                && !DIRECTORY.isTerminalOf(projectId, IJBTerminal(_msgSender()))\n                && _msgSender() != address(ruleset.dataHook())\n                && (\n                    ruleset.dataHook() == address(0)\n                        || !IJBRulesetDataHook(ruleset.dataHook()).hasMintPermissionFor(projectId, _msgSender())\n                )\n        ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_OR_HOOK();\n\n        // Determine the reserved rate to use.\n        reservedRate = useReservedRate ? ruleset.reservedRate() : 0;\n\n        if (reservedRate != JBConstants.MAX_RESERVED_RATE) {\n            // Calculate the number of (non-reserved) tokens that will be minted to the beneficiary.\n            beneficiaryTokenCount =\n                mulDiv(tokenCount, JBConstants.MAX_RESERVED_RATE - reservedRate, JBConstants.MAX_RESERVED_RATE);\n\n            // Mint the tokens.\n            TOKENS.mintFor(beneficiary, projectId, beneficiaryTokenCount);\n        }\n\n        // Add any reserved tokens to the pending reserved token balance.\n        if (reservedRate > 0) {\n            pendingReservedTokenBalanceOf[projectId] += tokenCount - beneficiaryTokenCount;\n        }\n\n        emit MintTokens(beneficiary, projectId, tokenCount, beneficiaryTokenCount, memo, reservedRate, _msgSender());\n    }\n\n    /// @notice Burns a project's tokens or credits from the specific holder's balance.\n    /// @dev Can only be called by the holder, an address with the holder's permission to `BURN_TOKENS`, or a project's\n    /// terminal.\n    /// @param holder The address whose tokens are being burned.\n    /// @param projectId The ID of the project whose tokens are being burned.\n    /// @param tokenCount The number of tokens to burn.\n    /// @param memo A memo to pass along to the emitted event.\n    function burnTokensOf(\n        address holder,\n        uint256 projectId,\n        uint256 tokenCount,\n        string calldata memo\n    )\n        external\n        virtual\n        override\n    {\n        // Enforce permissions.\n        _requirePermissionAllowingOverrideFrom({\n            account: holder,\n            projectId: projectId,\n            permissionId: JBPermissionIds.BURN_TOKENS,\n            alsoGrantAccessIf: DIRECTORY.isTerminalOf(projectId, IJBTerminal(_msgSender()))\n        });\n\n        // There must be tokens to burn.\n        if (tokenCount == 0) revert NO_BURNABLE_TOKENS();\n\n        // Burn the tokens.\n        TOKENS.burnFrom(holder, projectId, tokenCount);\n\n        emit BurnTokens(holder, projectId, tokenCount, memo, _msgSender());\n    }\n\n    /// @notice Sends a project's pending reserved tokens to its reserved token splits.\n    /// @dev If the project has no reserved token splits, or if they don't add up to 100%, leftover tokens are sent to\n    /// the project's owner.\n    /// @param projectId The ID of the project to send reserved tokens for.\n    /// @return The amount of reserved tokens minted and sent.\n    function sendReservedTokensToSplitsOf(uint256 projectId) external virtual override returns (uint256) {\n        return _sendReservedTokensToSplitsOf(projectId);\n    }\n\n    /// @notice Prepares this controller to receive a project being migrated from another controller.\n    /// @dev This controller should not be the project's controller yet.\n    /// @param from The controller being migrated from.\n    /// @param projectId The ID of the project that will migrate to this controller.\n    function receiveMigrationFrom(IERC165 from, uint256 projectId) external virtual override {\n        // If the sending controller is an `IJBProjectUriRegistry`, copy the project's metadata URI.\n        if (\n            from.supportsInterface(type(IJBProjectUriRegistry).interfaceId) && DIRECTORY.controllerOf(projectId) == from\n        ) {\n            uriOf[projectId] = IJBProjectUriRegistry(address(from)).uriOf(projectId);\n        }\n    }\n\n    /// @notice Migrate a project from this controller to another one.\n    /// @dev Can only be called by the project's owner or an address with the owner's permission to\n    /// `SET_CONTROLLER`.\n    /// @param projectId The ID of the project to migrate.\n    /// @param to The controller to migrate the project to.\n    function migrateController(uint256 projectId, IJBMigratable to) external virtual override {\n        // Enforce permissions.\n        _requirePermissionFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.SET_CONTROLLER\n        });\n\n        // Get a reference to the project's ruleset.\n        JBRuleset memory ruleset = RULESETS.currentOf(projectId);\n\n        // Migration must be allowed.\n        if (!ruleset.allowControllerMigration()) {\n            revert CONTROLLER_MIGRATION_NOT_ALLOWED();\n        }\n\n        // Mint any pending reserved tokens before migrating.\n        if (pendingReservedTokenBalanceOf[projectId] != 0) {\n            _sendReservedTokensToSplitsOf(projectId);\n        }\n\n        // Prepare the new controller to receive the project.\n        to.receiveMigrationFrom(IERC165(this), projectId);\n\n        emit MigrateController(projectId, to, _msgSender());\n    }\n\n    /// @notice Set a project's metadata URI.\n    /// @dev This is typically an IPFS hash, optionally with an `ipfs://` prefix.\n    /// @dev Can only be called by the project's owner or an address with the owner's permission to\n    /// `SET_PROJECT_METADATA`.\n    /// @param projectId The ID of the project to set the metadata URI of.\n    /// @param metadata The metadata URI to set.\n    function setUriOf(uint256 projectId, string calldata metadata) external override {\n        // Enforce permissions.\n        _requirePermissionFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.SET_PROJECT_METADATA\n        });\n\n        // Set the project's metadata URI.\n        uriOf[projectId] = metadata;\n\n        emit SetMetadata(projectId, metadata, _msgSender());\n    }\n\n    /// @notice Sets a project's split groups. The new split groups must include any current splits which are locked.\n    /// @dev Can only be called by the project's owner or an address with the owner's permission to `SET_SPLIT_GROUPS`.\n    /// @param projectId The ID of the project to set the split groups of.\n    /// @param rulesetId The ID of the ruleset the split groups should be active in. Use a `rulesetId` of 0 to set the\n    /// default split groups, which are used when a ruleset has no splits set. If there are no default splits and no\n    /// splits are set, all splits are sent to the project's owner.\n    /// @param splitGroups An array of split groups to set.\n    function setSplitGroupsOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        JBSplitGroup[] calldata splitGroups\n    )\n        external\n        virtual\n        override\n    {\n        // Enforce permissions.\n        _requirePermissionFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.SET_SPLIT_GROUPS\n        });\n\n        // Set the split groups.\n        SPLITS.setSplitGroupsOf(projectId, rulesetId, splitGroups);\n    }\n\n    /// @notice Deploys an ERC-20 token for a project. It will be used when claiming tokens (with credits).\n    /// @dev Deploys the project's ERC-20 contract.\n    /// @dev Can only be called by the project's owner or an address with the owner's permission to `DEPLOY_ERC20`.\n    /// @param projectId The ID of the project to deploy the ERC-20 for.\n    /// @param name The ERC-20's name.\n    /// @param symbol The ERC-20's symbol.\n    /// @return token The address of the token that was deployed.\n    function deployERC20For(\n        uint256 projectId,\n        string calldata name,\n        string calldata symbol,\n        bytes32 salt\n    )\n        external\n        virtual\n        override\n        returns (IJBToken token)\n    {\n        // Enforce permissions.\n        _requirePermissionFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.DEPLOY_ERC20\n        });\n\n        if (salt != bytes32(0)) salt = keccak256(abi.encodePacked(_msgSender(), salt));\n\n        return TOKENS.deployERC20For(projectId, name, symbol, salt);\n    }\n\n    /// @notice Set a project's token. If the project's token is already set, this will revert.\n    /// @dev Can only be called by the project's owner or an address with the owner's permission to `SET_TOKEN`.\n    /// @param projectId The ID of the project to set the token of.\n    /// @param token The new token's address.\n    function setTokenFor(uint256 projectId, IJBToken token) external virtual override {\n        // Enforce permissions.\n        _requirePermissionFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.SET_TOKEN\n        });\n\n        // Get a reference to the current ruleset.\n        JBRuleset memory ruleset = RULESETS.currentOf(projectId);\n\n        // If there's no current ruleset, get a reference to the upcoming one.\n        if (ruleset.id == 0) ruleset = RULESETS.upcomingOf(projectId);\n\n        // If owner minting is disabled for the ruleset, the owner cannot change the token.\n        if (!ruleset.allowSetCustomToken()) revert RULESET_SET_TOKEN_DISABLED();\n\n        TOKENS.setTokenFor(projectId, token);\n    }\n\n    /// @notice Redeem credits to claim tokens into a `beneficiary`'s account.\n    /// @dev Can only be called by the credit holder or an address with the holder's permission to `CLAIM_TOKENS`.\n    /// @param holder The address to redeem credits from.\n    /// @param projectId The ID of the project whose tokens are being claimed.\n    /// @param amount The amount of tokens to claim.\n    /// @param beneficiary The account the claimed tokens will go to.\n    function claimTokensFor(\n        address holder,\n        uint256 projectId,\n        uint256 amount,\n        address beneficiary\n    )\n        external\n        virtual\n        override\n    {\n        // Enforce permissions.\n        _requirePermissionFrom({account: holder, projectId: projectId, permissionId: JBPermissionIds.CLAIM_TOKENS});\n\n        TOKENS.claimTokensFor(holder, projectId, amount, beneficiary);\n    }\n\n    /// @notice Allows a credit holder to transfer credits to another address.\n    /// @dev Can only be called by the credit holder or an address with the holder's permission to `TRANSFER_CREDITS`.\n    /// @param holder The address to transfer credits from.\n    /// @param projectId The ID of the project whose credits are being transferred.\n    /// @param recipient The address to transfer credits to.\n    /// @param amount The amount of credits to transfer.\n    function transferCreditsFrom(\n        address holder,\n        uint256 projectId,\n        address recipient,\n        uint256 amount\n    )\n        external\n        virtual\n        override\n    {\n        // Enforce permissions.\n        _requirePermissionFrom({account: holder, projectId: projectId, permissionId: JBPermissionIds.TRANSFER_CREDITS});\n\n        // Get a reference to the project's ruleset.\n        JBRuleset memory ruleset = RULESETS.currentOf(projectId);\n\n        // Credit transfers must not be paused.\n        if (ruleset.pauseCreditTransfers()) revert CREDIT_TRANSFERS_PAUSED();\n\n        TOKENS.transferCreditsFrom(holder, projectId, recipient, amount);\n    }\n\n    /// @notice When a project receives reserved tokens, if it has a terminal for the token, this is used to pay the\n    /// terminal.\n    /// @dev Can only be called by this controller.\n    /// @param terminal The terminal to pay.\n    /// @param projectId The ID of the project being paid.\n    /// @param token The token being paid with.\n    /// @param splitAmount The amount of tokens being paid.\n    /// @param beneficiary The payment's beneficiary.\n    /// @param metadata The pay metadata sent to the terminal.\n    function payReservedTokenToTerminal(\n        IJBTerminal terminal,\n        uint256 projectId,\n        IJBToken token,\n        uint256 splitAmount,\n        address beneficiary,\n        bytes calldata metadata\n    )\n        external\n    {\n        // Can only be called by this contract.\n        require(msg.sender == address(this));\n\n        // Approve the tokens being paid.\n        IERC20(address(token)).forceApprove(address(terminal), splitAmount);\n\n        // slither-disable-next-line unused-return\n        terminal.pay({\n            projectId: projectId,\n            token: address(token),\n            amount: splitAmount,\n            beneficiary: beneficiary,\n            minReturnedTokens: 0,\n            memo: \"\",\n            metadata: metadata\n        });\n\n        // Make sure that the terminal received the tokens.\n        assert(IERC20(address(token)).allowance(address(this), address(terminal)) == 0);\n    }\n\n    //*********************************************************************//\n    // ---------------------- internal transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice The message's sender. Preferred to use over `msg.sender`.\n    /// @return sender The address which sent this call.\n    function _msgSender() internal view override(ERC2771Context, Context) returns (address sender) {\n        return ERC2771Context._msgSender();\n    }\n\n    /// @notice The calldata. Preferred to use over `msg.data`.\n    /// @return calldata The `msg.data` of this call.\n    function _msgData() internal view override(ERC2771Context, Context) returns (bytes calldata) {\n        return ERC2771Context._msgData();\n    }\n\n    /// @dev `ERC-2771` specifies the context as being a single address (20 bytes).\n    function _contextSuffixLength() internal view virtual override(ERC2771Context, Context) returns (uint256) {\n        return super._contextSuffixLength();\n    }\n\n    //*********************************************************************//\n    // ---------------------- internal transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice Sends pending reserved tokens to the project's reserved token splits.\n    /// @dev If the project has no reserved token splits, or if they don't add up to 100%, leftover tokens are sent to\n    /// the project's owner.\n    /// @param projectId The ID of the project to send reserved tokens for.\n    /// @return tokenCount The amount of reserved tokens minted and sent.\n    function _sendReservedTokensToSplitsOf(uint256 projectId) internal returns (uint256 tokenCount) {\n        // Get a reference to the number of tokens that need to be minted.\n        tokenCount = pendingReservedTokenBalanceOf[projectId];\n\n        // Revert if there are no pending reserved tokens\n        if (tokenCount == 0) revert NO_RESERVED_TOKENS();\n\n        // Get the ruleset to read the reserved rate from.\n        JBRuleset memory ruleset = RULESETS.currentOf(projectId);\n\n        // Reset the pending reserved token balance.\n        pendingReservedTokenBalanceOf[projectId] = 0;\n\n        // Get a reference to the project's owner.\n        address owner = PROJECTS.ownerOf(projectId);\n\n        // Send reserved tokens to splits and get a reference to the amount left after the splits have all been paid.\n        uint256 leftoverTokenCount = tokenCount == 0\n            ? 0\n            : _sendTokensToSplitGroupOf(projectId, ruleset.id, JBSplitGroupIds.RESERVED_TOKENS, tokenCount);\n\n        // Mint any leftover tokens to the project owner.\n        if (leftoverTokenCount > 0) {\n            TOKENS.mintFor(owner, projectId, leftoverTokenCount);\n        }\n\n        emit SendReservedTokensToSplits(\n            ruleset.id, ruleset.cycleNumber, projectId, owner, tokenCount, leftoverTokenCount, _msgSender()\n        );\n    }\n\n    /// @notice Send project tokens to a split group.\n    /// @dev This is used to send reserved tokens to the reserved token split group.\n    /// @param projectId The ID of the project the splits belong to.\n    /// @param rulesetId The ID of the split group's ruleset.\n    /// @param groupId The ID of the split group.\n    /// @param amount The number of tokens to send.\n    /// @return leftoverAmount If the split percents don't add up to 100%, the leftover amount is returned.\n    function _sendTokensToSplitGroupOf(\n        uint256 projectId,\n        uint256 rulesetId,\n        uint256 groupId,\n        uint256 amount\n    )\n        internal\n        returns (uint256 leftoverAmount)\n    {\n        // Set the leftover amount to the initial amount.\n        leftoverAmount = amount;\n\n        // Get a reference to the split group.\n        JBSplit[] memory splits = SPLITS.splitsOf(projectId, rulesetId, groupId);\n\n        // Keep a reference to the number of splits being iterated on.\n        uint256 numberOfSplits = splits.length;\n\n        // Send the tokens to the splits.\n        for (uint256 i; i < numberOfSplits; i++) {\n            // Get a reference to the split being iterated on.\n            JBSplit memory split = splits[i];\n\n            // Calculate the amount to send to the split.\n            uint256 splitAmount = mulDiv(amount, split.percent, JBConstants.SPLITS_TOTAL_PERCENT);\n\n            // Mints tokens for the split if needed.\n            if (splitAmount > 0) {\n                // 1. If the split has a `hook`, call the hook's `processSplitWith` function.\n                // 2. Otherwise, if the split has a `projectId`, try to pay the project using the split's `beneficiary`,\n                // or the `_msgSender()` if the split has no beneficiary.\n                // 3. Otherwise, if the split has a beneficiary, send the tokens to the split's beneficiary.\n                // 4. Otherwise, send the tokens to the `_msgSender()`.\n\n                // If the split has a hook, call its `processSplitWith` function.\n                if (split.hook != IJBSplitHook(address(0))) {\n                    // Mint the tokens for the split hook.\n                    TOKENS.mintFor(address(split.hook), projectId, splitAmount);\n\n                    // Get a reference to the project token address. If the project doesn't have a token, this will\n                    // return the 0 address.\n                    IJBToken token = TOKENS.tokenOf(projectId);\n\n                    split.hook.processSplitWith(\n                        JBSplitHookContext({\n                            token: address(token),\n                            amount: splitAmount,\n                            decimals: 18, // Hard-coded in `JBTokens`.\n                            projectId: projectId,\n                            groupId: groupId,\n                            split: split\n                        })\n                    );\n                    // If the split has a project ID, try to pay the project. If that fails, pay the beneficiary.\n                } else {\n                    // Pay the project using the split's beneficiary if one was provided. Otherwise, use the message\n                    // sender.\n                    address beneficiary = split.beneficiary != address(0) ? split.beneficiary : _msgSender();\n\n                    if (split.projectId != 0) {\n                        // Get a reference to the project's token address. If the project doesn't have a token, this\n                        // will return the 0 address.\n                        IJBToken token = TOKENS.tokenOf(projectId);\n\n                        // Get a reference to the receiving project's primary payment terminal for the token.\n                        IJBTerminal terminal = token == IJBToken(address(0))\n                            ? IJBTerminal(address(0))\n                            : DIRECTORY.primaryTerminalOf(split.projectId, address(token));\n\n                        // If the project doesn't have a token, or if the receiving project doesn't have a terminal\n                        // which accepts the token, send the tokens to the beneficiary.\n                        if (address(token) == address(0) || address(terminal) == address(0)) {\n                            // Mint the tokens to the beneficiary.\n                            TOKENS.mintFor(beneficiary, projectId, splitAmount);\n                        } else {\n                            // Mint the tokens to this contract.\n                            TOKENS.mintFor(address(this), projectId, splitAmount);\n\n                            // Use the `projectId` in the pay metadata.\n                            bytes memory metadata = bytes(abi.encodePacked(projectId));\n\n                            // Try to fulfill the payment.\n                            try this.payReservedTokenToTerminal({\n                                projectId: split.projectId,\n                                terminal: terminal,\n                                token: token,\n                                splitAmount: splitAmount,\n                                beneficiary: beneficiary,\n                                metadata: metadata\n                            }) {} catch (bytes memory reason) {\n                                // If it fails, transfer the tokens from this contract to the beneficiary.\n                                IERC20(address(token)).safeTransfer(beneficiary, splitAmount);\n                                emit ReservedDistributionReverted(projectId, split, splitAmount, reason, _msgSender());\n                            }\n                        }\n                    } else {\n                        // If the split has no project ID, mint the tokens to the beneficiary.\n                        TOKENS.mintFor(beneficiary, projectId, splitAmount);\n                    }\n                }\n\n                // Subtract the amount sent from the leftover.\n                leftoverAmount = leftoverAmount - splitAmount;\n            }\n\n            emit SendReservedTokensToSplit(projectId, rulesetId, groupId, split, splitAmount, _msgSender());\n        }\n    }\n\n    /// @notice Queues one or more rulesets and stores information pertinent to the configuration.\n    /// @param projectId The ID of the project to queue rulesets for.\n    /// @param rulesetConfigurations The rulesets being queued.\n    /// @return rulesetId The ID of the last ruleset that was successfully queued.\n    function _queueRulesets(\n        uint256 projectId,\n        JBRulesetConfig[] calldata rulesetConfigurations\n    )\n        internal\n        returns (uint256 rulesetId)\n    {\n        // Keep a reference to the number of ruleset configurations being queued.\n        uint256 numberOfConfigurations = rulesetConfigurations.length;\n\n        // Keep a reference to the ruleset config being iterated on.\n        JBRulesetConfig memory rulesetConfig;\n\n        for (uint256 i; i < numberOfConfigurations; i++) {\n            // Get a reference to the ruleset config being iterated on.\n            rulesetConfig = rulesetConfigurations[i];\n\n            // Make sure its reserved rate is valid.\n            if (rulesetConfig.metadata.reservedRate > JBConstants.MAX_RESERVED_RATE) {\n                revert INVALID_RESERVED_RATE();\n            }\n\n            // Make sure its redemption rate is valid.\n            if (rulesetConfig.metadata.redemptionRate > JBConstants.MAX_REDEMPTION_RATE) {\n                revert INVALID_REDEMPTION_RATE();\n            }\n\n            // Make sure its base currency is valid.\n            if (rulesetConfig.metadata.baseCurrency > type(uint32).max) {\n                revert INVALID_BASE_CURRENCY();\n            }\n\n            // Queue its ruleset.\n            JBRuleset memory ruleset = RULESETS.queueFor({\n                projectId: projectId,\n                duration: rulesetConfig.duration,\n                weight: rulesetConfig.weight,\n                decayRate: rulesetConfig.decayRate,\n                approvalHook: rulesetConfig.approvalHook,\n                metadata: JBRulesetMetadataResolver.packRulesetMetadata(rulesetConfig.metadata),\n                mustStartAtOrAfter: rulesetConfig.mustStartAtOrAfter\n            });\n\n            // Set its split groups.\n            SPLITS.setSplitGroupsOf(projectId, ruleset.id, rulesetConfig.splitGroups);\n\n            // Set its fund access limits.\n            FUND_ACCESS_LIMITS.setFundAccessLimitsFor(projectId, ruleset.id, rulesetConfig.fundAccessLimitGroups);\n\n            // If this is the last configuration being queued, return the ruleset's ID.\n            if (i == numberOfConfigurations - 1) {\n                rulesetId = ruleset.id;\n            }\n        }\n    }\n\n    /// @notice Set up a project's terminals.\n    /// @param projectId The ID of the project to set up terminals for.\n    /// @param terminalConfigs The terminals to set up.\n    function _configureTerminals(uint256 projectId, JBTerminalConfig[] calldata terminalConfigs) internal {\n        // Keep a reference to the number of terminals being configured.\n        uint256 numberOfTerminalConfigs = terminalConfigs.length;\n\n        // Initialize an array of terminals to populate.\n        IJBTerminal[] memory terminals = new IJBTerminal[](numberOfTerminalConfigs);\n\n        // Keep a reference to the terminal configuration being iterated on.\n        JBTerminalConfig memory terminalConfig;\n\n        for (uint256 i; i < numberOfTerminalConfigs; i++) {\n            // Set the terminal configuration being iterated on.\n            terminalConfig = terminalConfigs[i];\n\n            // Add the accounting contexts for the specified tokens.\n            terminalConfig.terminal.addAccountingContextsFor(projectId, terminalConfig.tokensToAccept);\n\n            // Add the terminal.\n            terminals[i] = terminalConfig.terminal;\n        }\n\n        // Set the terminals in the directory.\n        if (numberOfTerminalConfigs > 0) {\n            DIRECTORY.setTerminalsOf(projectId, terminals);\n        }\n    }\n}\n"
			},
			"src/interfaces/IJBController.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBApprovalStatus} from \"./../enums/JBApprovalStatus.sol\";\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {JBRulesetConfig} from \"./../structs/JBRulesetConfig.sol\";\nimport {JBRulesetMetadata} from \"./../structs/JBRulesetMetadata.sol\";\nimport {JBRulesetWithMetadata} from \"./../structs/JBRulesetWithMetadata.sol\";\nimport {JBSplit} from \"./../structs/JBSplit.sol\";\nimport {JBSplitGroup} from \"./../structs/JBSplitGroup.sol\";\nimport {JBTerminalConfig} from \"./../structs/JBTerminalConfig.sol\";\nimport {IJBDirectory} from \"./IJBDirectory.sol\";\nimport {IJBDirectoryAccessControl} from \"./IJBDirectoryAccessControl.sol\";\nimport {IJBFundAccessLimits} from \"./IJBFundAccessLimits.sol\";\nimport {IJBMigratable} from \"./IJBMigratable.sol\";\nimport {IJBProjects} from \"./IJBProjects.sol\";\nimport {IJBProjectUriRegistry} from \"./IJBProjectUriRegistry.sol\";\nimport {IJBRulesets} from \"./IJBRulesets.sol\";\nimport {IJBSplits} from \"./IJBSplits.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\nimport {IJBToken} from \"./IJBToken.sol\";\nimport {IJBTokens} from \"./IJBTokens.sol\";\n\ninterface IJBController is IERC165, IJBProjectUriRegistry, IJBDirectoryAccessControl {\n    event LaunchProject(uint256 rulesetId, uint256 projectId, string metadata, string memo, address caller);\n\n    event LaunchRulesets(uint256 rulesetId, uint256 projectId, string memo, address caller);\n\n    event QueueRulesets(uint256 rulesetId, uint256 projectId, string memo, address caller);\n\n    event SendReservedTokensToSplits(\n        uint256 indexed rulesetId,\n        uint256 indexed rulesetCycleNumber,\n        uint256 indexed projectId,\n        address beneficiary,\n        uint256 tokenCount,\n        uint256 beneficiaryTokenCount,\n        address caller\n    );\n\n    event SendReservedTokensToSplit(\n        uint256 indexed projectId,\n        uint256 indexed rulesetId,\n        uint256 indexed group,\n        JBSplit split,\n        uint256 tokenCount,\n        address caller\n    );\n\n    event MintTokens(\n        address indexed beneficiary,\n        uint256 indexed projectId,\n        uint256 tokenCount,\n        uint256 beneficiaryTokenCount,\n        string memo,\n        uint256 reservedRate,\n        address caller\n    );\n\n    event BurnTokens(\n        address indexed holder, uint256 indexed projectId, uint256 tokenCount, string memo, address caller\n    );\n\n    event ReservedDistributionReverted(\n        uint256 indexed projectId, JBSplit split, uint256 amount, bytes reason, address caller\n    );\n\n    event MigrateController(uint256 indexed projectId, IJBMigratable to, address caller);\n\n    event PrepMigration(uint256 indexed projectId, address from, address caller);\n\n    event SetMetadata(uint256 indexed projectId, string metadata, address caller);\n\n    function PROJECTS() external view returns (IJBProjects);\n\n    function DIRECTORY() external view returns (IJBDirectory);\n\n    function RULESETS() external view returns (IJBRulesets);\n\n    function TOKENS() external view returns (IJBTokens);\n\n    function SPLITS() external view returns (IJBSplits);\n\n    function FUND_ACCESS_LIMITS() external view returns (IJBFundAccessLimits);\n\n    function pendingReservedTokenBalanceOf(uint256 projectId) external view returns (uint256);\n\n    function totalTokenSupplyWithReservedTokensOf(uint256 projectId) external view returns (uint256);\n\n    function getRulesetOf(\n        uint256 projectId,\n        uint256 rulesetId\n    )\n        external\n        view\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata);\n\n    function latestQueuedRulesetOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory, JBRulesetMetadata memory metadata, JBApprovalStatus);\n\n    function rulesetsOf(\n        uint256 projectId,\n        uint256 startingId,\n        uint256 size\n    )\n        external\n        view\n        returns (JBRulesetWithMetadata[] memory rulesets);\n\n    function currentRulesetOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata);\n\n    function upcomingRulesetOf(uint256 projectId)\n        external\n        view\n        returns (JBRuleset memory ruleset, JBRulesetMetadata memory metadata);\n\n    function launchProjectFor(\n        address owner,\n        string calldata projectUri,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        JBTerminalConfig[] memory terminalConfigurations,\n        string calldata memo\n    )\n        external\n        returns (uint256 projectId);\n\n    function launchRulesetsFor(\n        uint256 projectId,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        JBTerminalConfig[] memory terminalConfigurations,\n        string calldata memo\n    )\n        external\n        returns (uint256 rulesetId);\n\n    function queueRulesetsOf(\n        uint256 projectId,\n        JBRulesetConfig[] calldata rulesetConfigurations,\n        string calldata memo\n    )\n        external\n        returns (uint256 rulesetId);\n\n    function mintTokensOf(\n        uint256 projectId,\n        uint256 tokenCount,\n        address beneficiary,\n        string calldata memo,\n        bool useReservedRate\n    )\n        external\n        returns (uint256 beneficiaryTokenCount);\n\n    function payReservedTokenToTerminal(\n        IJBTerminal terminal,\n        uint256 projectId,\n        IJBToken token,\n        uint256 splitAmount,\n        address beneficiary,\n        bytes calldata metadata\n    )\n        external;\n\n    function burnTokensOf(address holder, uint256 projectId, uint256 tokenCount, string calldata memo) external;\n\n    function sendReservedTokensToSplitsOf(uint256 projectId) external returns (uint256);\n\n    function migrateController(uint256 projectId, IJBMigratable to) external;\n\n    function setSplitGroupsOf(uint256 projectId, uint256 rulesetId, JBSplitGroup[] calldata splitGroups) external;\n\n    function deployERC20For(\n        uint256 projectId,\n        string calldata name,\n        string calldata symbol,\n        bytes32 salt\n    )\n        external\n        returns (IJBToken token);\n\n    function setTokenFor(uint256 _projectId, IJBToken _token) external;\n\n    function claimTokensFor(address holder, uint256 projectId, uint256 amount, address beneficiary) external;\n\n    function transferCreditsFrom(address holder, uint256 projectId, address recipient, uint256 amount) external;\n}\n"
			},
			"src/interfaces/IJBMigratable.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ninterface IJBMigratable is IERC165 {\n    function receiveMigrationFrom(IERC165 from, uint256 projectId) external;\n}\n"
			},
			"src/interfaces/IJBProjectUriRegistry.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBProjectUriRegistry {\n    function uriOf(uint256 projectId) external view returns (string memory);\n    function setUriOf(uint256 projectId, string calldata metadata) external;\n}\n"
			},
			"src/interfaces/IJBRedeemHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBAfterRedeemRecordedContext} from \"./../structs/JBAfterRedeemRecordedContext.sol\";\n\n/// @notice Hook called after a terminal's `redeemTokensOf(...)` logic completes (if passed by the ruleset's data hook).\ninterface IJBRedeemHook is IERC165 {\n    /// @notice This function is called by the terminal's `redeemTokensOf(...)` function after the redemption has been\n    /// recorded in the terminal store.\n    /// @dev Critical business logic should be protected by appropriate access control.\n    /// @param context The context passed in by the terminal, as a `JBAfterRedeemRecordedContext` struct.\n    function afterRedeemRecordedWith(JBAfterRedeemRecordedContext calldata context) external payable;\n}\n"
			},
			"src/interfaces/IJBRulesetDataHook.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {JBBeforePayRecordedContext} from \"./../structs/JBBeforePayRecordedContext.sol\";\nimport {JBBeforeRedeemRecordedContext} from \"./../structs/JBBeforeRedeemRecordedContext.sol\";\nimport {JBPayHookSpecification} from \"./../structs/JBPayHookSpecification.sol\";\nimport {JBRedeemHookSpecification} from \"./../structs/JBRedeemHookSpecification.sol\";\n\n/// @notice Data hooks can extend a terminal's core pay/redeem functionality by overriding the weight or memo. They can\n/// also specify pay/redeem hooks for the terminal to fulfill, or allow addresses to mint a project's tokens on-demand.\n/// @dev If a project's ruleset has `useDataHookForPay` or `useDataHookForRedeem` enabled, its `dataHook` is called by\n/// the terminal upon payments/redemptions (respectively).\ninterface IJBRulesetDataHook is IERC165 {\n    /// @notice A flag indicating whether an address has permission to mint a project's tokens on-demand.\n    /// @dev A project's data hook can allow any address to mint its tokens.\n    /// @param projectId The ID of the project whose token can be minted.\n    /// @param addr The address to check the token minting permission of.\n    /// @return flag A flag indicating whether the address has permission to mint the project's tokens on-demand.\n    function hasMintPermissionFor(uint256 projectId, address addr) external view returns (bool flag);\n\n    /// @notice The data calculated before a payment is recorded in the terminal store. This data is provided to the\n    /// terminal's `pay(...)` transaction.\n    /// @param context The context passed to this data hook by the `pay(...)` function as a `JBBeforePayRecordedContext`\n    /// struct.\n    /// @return weight The new `weight` to use, overriding the ruleset's `weight`.\n    /// @return hookSpecifications The amount and data to send to pay hooks instead of adding to the terminal's balance.\n    function beforePayRecordedWith(JBBeforePayRecordedContext calldata context)\n        external\n        view\n        returns (uint256 weight, JBPayHookSpecification[] memory hookSpecifications);\n\n    /// @notice The data calculated before a redemption is recorded in the terminal store. This data is provided to the\n    /// terminal's `redeemTokensOf(...)` transaction.\n    /// @param context The context passed to this data hook by the `redeemTokensOf(...)` function as a\n    /// `JBBeforeRedeemRecordedContext` struct.\n    /// @return redemptionRate The rate determining the amount that should be reclaimable for a given surplus and token\n    /// supply.\n    /// @return redeemCount The amount of tokens that should be considered redeemed.\n    /// @return totalSupply The total amount of tokens that are considered to be existing.\n    /// @return hookSpecifications The amount and data to send to redeem hooks instead of returning to the beneficiary.\n    function beforeRedeemRecordedWith(JBBeforeRedeemRecordedContext calldata context)\n        external\n        view\n        returns (\n            uint256 redemptionRate,\n            uint256 redeemCount,\n            uint256 totalSupply,\n            JBRedeemHookSpecification[] memory hookSpecifications\n        );\n}\n"
			},
			"src/libraries/JBRulesetMetadataResolver.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {JBRulesetMetadata} from \"./../structs/JBRulesetMetadata.sol\";\n\nlibrary JBRulesetMetadataResolver {\n    function reservedRate(JBRuleset memory ruleset) internal pure returns (uint256) {\n        return uint256(uint16(ruleset.metadata >> 4));\n    }\n\n    function redemptionRate(JBRuleset memory ruleset) internal pure returns (uint256) {\n        // Redemption rate is a number 0-10000.\n        return uint256(uint16(ruleset.metadata >> 20));\n    }\n\n    function baseCurrency(JBRuleset memory ruleset) internal pure returns (uint256) {\n        // Currency is a number 0-4294967296.\n        return uint256(uint32(ruleset.metadata >> 36));\n    }\n\n    function pausePay(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 68) & 1) == 1;\n    }\n\n    function pauseCreditTransfers(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 69) & 1) == 1;\n    }\n\n    function allowOwnerMinting(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 70) & 1) == 1;\n    }\n\n    function allowSetCustomToken(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 71) & 1) == 1;\n    }\n\n    function allowTerminalMigration(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 72) & 1) == 1;\n    }\n\n    function allowSetTerminals(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 73) & 1) == 1;\n    }\n\n    function allowControllerMigration(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 74) & 1) == 1;\n    }\n\n    function allowSetController(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 75) & 1) == 1;\n    }\n\n    function holdFees(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 76) & 1) == 1;\n    }\n\n    function useTotalSurplusForRedemptions(JBRuleset memory ruleset) internal pure returns (bool) {\n        return ((ruleset.metadata >> 77) & 1) == 1;\n    }\n\n    function useDataHookForPay(JBRuleset memory ruleset) internal pure returns (bool) {\n        return (ruleset.metadata >> 78) & 1 == 1;\n    }\n\n    function useDataHookForRedeem(JBRuleset memory ruleset) internal pure returns (bool) {\n        return (ruleset.metadata >> 79) & 1 == 1;\n    }\n\n    function dataHook(JBRuleset memory ruleset) internal pure returns (address) {\n        return address(uint160(ruleset.metadata >> 80));\n    }\n\n    function metadata(JBRuleset memory ruleset) internal pure returns (uint256) {\n        return uint256(uint16(ruleset.metadata >> 240));\n    }\n\n    /// @notice Pack the funding cycle metadata.\n    /// @param rulesetMetadata The ruleset metadata to validate and pack.\n    /// @return packed The packed uint256 of all metadata params. The first 8 bits specify the version.\n    function packRulesetMetadata(JBRulesetMetadata memory rulesetMetadata) internal pure returns (uint256 packed) {\n        // version 1 in the bits 0-3 (4 bits).\n        packed = 1;\n        // reserved rate in bits 4-19 (16 bits).\n        packed |= rulesetMetadata.reservedRate << 4;\n        // redemption rate in bits 20-35 (16 bits).\n        // redemption rate is a number 0-10000.\n        packed |= rulesetMetadata.redemptionRate << 20;\n        // base currency in bits 36-67 (32 bits).\n        // base currency is a number 0-16777215.\n        packed |= rulesetMetadata.baseCurrency << 36;\n        // pause pay in bit 68.\n        if (rulesetMetadata.pausePay) packed |= 1 << 68;\n        // pause credit transfers in bit 69.\n        if (rulesetMetadata.pauseCreditTransfers) packed |= 1 << 69;\n        // allow discretionary minting in bit 70.\n        if (rulesetMetadata.allowOwnerMinting) packed |= 1 << 70;\n        // allow a custom token to be set in bit 71.\n        if (rulesetMetadata.allowSetCustomToken) packed |= 1 << 71;\n        // allow terminal migration in bit 72.\n        if (rulesetMetadata.allowTerminalMigration) packed |= 1 << 72;\n        // allow set terminals in bit 73.\n        if (rulesetMetadata.allowSetTerminals) packed |= 1 << 73;\n        // allow controller migration in bit 74.\n        if (rulesetMetadata.allowControllerMigration) packed |= 1 << 74;\n        // allow set controller in bit 75.\n        if (rulesetMetadata.allowSetController) packed |= 1 << 75;\n        // hold fees in bit 76.\n        if (rulesetMetadata.holdFees) packed |= 1 << 76;\n        // useTotalSurplusForRedemptions in bit 77.\n        if (rulesetMetadata.useTotalSurplusForRedemptions) packed |= 1 << 77;\n        // use pay data source in bit 78.\n        if (rulesetMetadata.useDataHookForPay) packed |= 1 << 78;\n        // use redeem data source in bit 79.\n        if (rulesetMetadata.useDataHookForRedeem) packed |= 1 << 79;\n        // data source address in bits 80-239.\n        packed |= uint256(uint160(address(rulesetMetadata.dataHook))) << 80;\n        // metadata in bits 240-255 (16 bits).\n        packed |= rulesetMetadata.metadata << 240;\n    }\n\n    /// @notice Expand the funding cycle metadata.\n    /// @param ruleset The funding cycle having its metadata expanded.\n    /// @return rulesetMetadata The ruleset's metadata object.\n    function expandMetadata(JBRuleset memory ruleset) internal pure returns (JBRulesetMetadata memory) {\n        return JBRulesetMetadata(\n            reservedRate(ruleset),\n            redemptionRate(ruleset),\n            baseCurrency(ruleset),\n            pausePay(ruleset),\n            pauseCreditTransfers(ruleset),\n            allowOwnerMinting(ruleset),\n            allowSetCustomToken(ruleset),\n            allowTerminalMigration(ruleset),\n            allowSetTerminals(ruleset),\n            allowControllerMigration(ruleset),\n            allowSetController(ruleset),\n            holdFees(ruleset),\n            useTotalSurplusForRedemptions(ruleset),\n            useDataHookForPay(ruleset),\n            useDataHookForRedeem(ruleset),\n            dataHook(ruleset),\n            metadata(ruleset)\n        );\n    }\n}\n"
			},
			"src/libraries/JBSplitGroupIds.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary JBSplitGroupIds {\n    uint256 public constant RESERVED_TOKENS = 1;\n}\n"
			},
			"src/structs/JBAfterRedeemRecordedContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTokenAmount} from \"./JBTokenAmount.sol\";\n\n/// @custom:member holder The holder of the tokens being redeemed.\n/// @custom:member projectId The ID of the project being redeemed from.\n/// @custom:member rulesetId The ID of the ruleset the redemption is being made during.\n/// @custom:member redeemCount The number of project tokens being redeemed.\n/// @custom:member redemptionRate The current ruleset's redemption rate.\n/// @custom:member reclaimedAmount The token amount being reclaimed from the project's terminal balance. Includes the\n/// token being\n/// reclaimed, the value, the number of decimals included, and the currency of the amount.\n/// @custom:member forwardedAmount The token amount being forwarded to the redeem hook. Includes the token\n/// being forwarded, the value, the number of decimals included, and the currency of the amount.\n/// @custom:member beneficiary The address the reclaimed amount will be sent to.\n/// @custom:member hookMetadata Extra data specified by the data hook, which is sent to the redeem hook.\n/// @custom:member redeemerMetadata Extra data specified by the redeemer, which is sent to the redeem hook.\nstruct JBAfterRedeemRecordedContext {\n    address holder;\n    uint256 projectId;\n    uint256 rulesetId;\n    uint256 redeemCount;\n    JBTokenAmount reclaimedAmount;\n    JBTokenAmount forwardedAmount;\n    uint256 redemptionRate;\n    address payable beneficiary;\n    bytes hookMetadata;\n    bytes redeemerMetadata;\n}\n"
			},
			"src/structs/JBBeforePayRecordedContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTokenAmount} from \"./JBTokenAmount.sol\";\n\n/// @notice Context sent from the terminal to the ruleset's data hook upon payment.\n/// @custom:member terminal The terminal that is facilitating the payment.\n/// @custom:member payer The address that the payment originated from.\n/// @custom:member amount The payment's token amount, including the token being paid, the value, the number of decimals\n/// included, and the currency of the amount.\n/// @custom:member projectId The ID of the project being paid.\n/// @custom:member rulesetId The ID of the ruleset the payment is being made during.\n/// @custom:member beneficiary The specified address that should be the beneficiary of anything that this payment\n/// yields.\n/// @custom:member weight The weight of the ruleset during which the payment is being made.\n/// @custom:member reservedRate The reserved rate of the ruleset the payment is being made during.\n/// @custom:member metadata Extra data specified by the payer.\nstruct JBBeforePayRecordedContext {\n    address terminal;\n    address payer;\n    JBTokenAmount amount;\n    uint256 projectId;\n    uint256 rulesetId;\n    address beneficiary;\n    uint256 weight;\n    uint256 reservedRate;\n    bytes metadata;\n}\n"
			},
			"src/structs/JBBeforeRedeemRecordedContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBTokenAmount} from \"./JBTokenAmount.sol\";\n\n/// @notice Context sent from the terminal to the ruleset's data hook upon redemption.\n/// @custom:member terminal The terminal that is facilitating the redemption.\n/// @custom:member holder The holder of the tokens being redeemed.\n/// @custom:member projectId The ID of the project whose tokens are being redeemed.\n/// @custom:member rulesetId The ID of the ruleset the redemption is being made during.\n/// @custom:member redeemCount The number of tokens being redeemed, as a fixed point number with 18 decimals.\n/// @custom:member totalSupply The total token supply being used for the calculation, as a fixed point number with 18\n/// decimals.\n/// @custom:member surplus The surplus amount used for the calculation, as a fixed point number with 18 decimals.\n/// Includes the token of the surplus, the surplus value, the number of decimals\n/// included, and the currency of the surplus.\n/// @custom:member useTotalSurplus If surplus across all of a project's terminals is being used when making redemptions.\n/// @custom:member redemptionRate The redemption rate of the ruleset the redemption is being made during.\n/// @custom:member metadata Extra data provided by the redeemer.\nstruct JBBeforeRedeemRecordedContext {\n    address terminal;\n    address holder;\n    uint256 projectId;\n    uint256 rulesetId;\n    uint256 redeemCount;\n    uint256 totalSupply;\n    JBTokenAmount surplus;\n    bool useTotalSurplus;\n    uint256 redemptionRate;\n    bytes metadata;\n}\n"
			},
			"src/structs/JBPayHookSpecification.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPayHook} from \"../interfaces/IJBPayHook.sol\";\n\n/// @notice A pay hook specification sent from the ruleset's data hook back to the terminal. This specification is\n/// fulfilled by the terminal.\n/// @custom:member hook The pay hook to use when fulfilling this specification.\n/// @custom:member amount The amount to send to the hook.\n/// @custom:member metadata Metadata to pass the hook.\nstruct JBPayHookSpecification {\n    IJBPayHook hook;\n    uint256 amount;\n    bytes metadata;\n}\n"
			},
			"src/structs/JBRedeemHookSpecification.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBRedeemHook} from \"../interfaces/IJBRedeemHook.sol\";\n\n/// @notice A redeem hook specification sent from the ruleset's data hook back to the terminal. This specification is\n/// fulfilled by the terminal.\n/// @custom:member hook The redeem hook to use when fulfilling this specification.\n/// @custom:member amount The amount to send to the hook.\n/// @custom:member metadata Metadata to pass to the hook.\nstruct JBRedeemHookSpecification {\n    IJBRedeemHook hook;\n    uint256 amount;\n    bytes metadata;\n}\n"
			},
			"src/structs/JBRulesetConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBRulesetApprovalHook} from \"../interfaces/IJBRulesetApprovalHook.sol\";\nimport {JBFundAccessLimitGroup} from \"./JBFundAccessLimitGroup.sol\";\nimport {JBRulesetMetadata} from \"./JBRulesetMetadata.sol\";\nimport {JBSplitGroup} from \"./JBSplitGroup.sol\";\n\n/// @custom:member mustStartAtOrAfter The earliest time the ruleset can start.\n/// @custom:member duration The number of seconds the ruleset lasts for, after which a new ruleset will start. A\n/// duration of 0 means that the ruleset will stay active until the project owner explicitly issues a reconfiguration,\n/// at which point a new ruleset will immediately start with the updated properties. If the duration is greater than 0,\n/// a project owner cannot make changes to a ruleset's parameters while it is active – any proposed changes will apply\n/// to the subsequent ruleset. If no changes are proposed, a ruleset rolls over to another one with the same properties\n/// but new `start` timestamp and a decayed `weight`.\n/// @custom:member weight A fixed point number with 18 decimals that contracts can use to base arbitrary calculations\n/// on. For example, payment terminals can use this to determine how many tokens should be minted when a payment is\n/// received.\n/// @custom:member decayRate A percent by how much the `weight` of the subsequent ruleset should be reduced, if the\n/// project owner hasn't queued the subsequent ruleset with an explicit `weight`. If it's 0, each ruleset will have\n/// equal weight. If the number is 90%, the next ruleset will have a 10% smaller weight. This weight is out of\n/// `JBConstants.MAX_DECAY_RATE`.\n/// @custom:member approvalHook An address of a contract that says whether a proposed ruleset should be accepted or\n/// rejected. It\n/// can be used to create rules around how a project owner can change ruleset parameters over time.\n/// @custom:member metadata Metadata specifying the controller-specific parameters that a ruleset can have. These\n/// properties cannot change until the next ruleset starts.\n/// @custom:member splitGroups An array of splits to use for any number of groups while the ruleset is active.\n/// @custom:member fundAccessLimitGroups An array of structs which dictate the amount of funds a project can access from\n/// its balance in each payment terminal while the ruleset is active. Amounts are fixed point numbers using the same\n/// number of decimals as the corresponding terminal. The `_payoutLimit` and `_surplusAllowance` parameters must fit in\n/// a `uint232`.\nstruct JBRulesetConfig {\n    uint256 mustStartAtOrAfter;\n    uint256 duration;\n    uint256 weight;\n    uint256 decayRate;\n    IJBRulesetApprovalHook approvalHook;\n    JBRulesetMetadata metadata;\n    JBSplitGroup[] splitGroups;\n    JBFundAccessLimitGroup[] fundAccessLimitGroups;\n}\n"
			},
			"src/structs/JBRulesetMetadata.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member reservedRate The reserved rate of the ruleset. This number is a percentage calculated out of\n/// `JBConstants.MAX_RESERVED_RATE`.\n/// @custom:member redemptionRate The redemption rate of the ruleset. This number is a percentage calculated out of\n/// `JBConstants.MAX_REDEMPTION_RATE`.\n/// @custom:member baseCurrency The currency on which to base the ruleset's weight.\n/// @custom:member pausePay A flag indicating if the pay functionality should be paused during the ruleset.\n/// @custom:member pauseCreditTransfers A flag indicating if the project token transfer functionality should be paused\n/// during the funding cycle.\n/// @custom:member allowOwnerMinting A flag indicating if the project owner or an operator with the `MINT_TOKENS`\n/// permission from the owner should be allowed to mint project tokens on demand during this ruleset.\n/// @custom:member allowTerminalMigration A flag indicating if migrating terminals should be allowed during this\n/// ruleset.\n/// @custom:member allowSetTerminals A flag indicating if a project's terminals can be added or removed.\n/// @custom:member allowControllerMigration A flag indicating if migrating controllers should be allowed during this\n/// ruleset.\n/// @custom:member allowSetController A flag indicating if a project's controller can be changed.\n/// @custom:member holdFees A flag indicating if fees should be held during this ruleset.\n/// @custom:member useTotalSurplusForRedemptions A flag indicating if redemptions should use the project's balance held\n/// in all terminals instead of the project's local terminal balance from which the redemption is being fulfilled.\n/// @custom:member useDataHookForPay A flag indicating if the data hook should be used for pay transactions during this\n/// ruleset.\n/// @custom:member useDataHookForRedeem A flag indicating if the data hook should be used for redeem transactions during\n/// this ruleset.\n/// @custom:member dataHook The data hook to use during this ruleset.\n/// @custom:member metadata Metadata of the metadata, up to uint8 in size.\nstruct JBRulesetMetadata {\n    uint256 reservedRate;\n    uint256 redemptionRate;\n    uint256 baseCurrency;\n    bool pausePay;\n    bool pauseCreditTransfers;\n    bool allowOwnerMinting;\n    bool allowSetCustomToken;\n    bool allowTerminalMigration;\n    bool allowSetTerminals;\n    bool allowControllerMigration;\n    bool allowSetController;\n    bool holdFees;\n    bool useTotalSurplusForRedemptions;\n    bool useDataHookForPay;\n    bool useDataHookForRedeem;\n    address dataHook;\n    uint256 metadata;\n}\n"
			},
			"src/structs/JBRulesetWithMetadata.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBRuleset} from \"./JBRuleset.sol\";\nimport {JBRulesetMetadata} from \"./JBRulesetMetadata.sol\";\n\n/// @custom:member ruleset The ruleset.\n/// @custom:member metadata The ruleset's metadata.\nstruct JBRulesetWithMetadata {\n    JBRuleset ruleset;\n    JBRulesetMetadata metadata;\n}\n"
			},
			"src/structs/JBTerminalConfig.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBTerminal} from \"./../interfaces/IJBTerminal.sol\";\n\n/// @custom:member terminal The terminal to configure.\n/// @custom:member acceptedTokens The tokens to accept from the terminal.\nstruct JBTerminalConfig {\n    IJBTerminal terminal;\n    address[] tokensToAccept;\n}\n"
			},
			"src/JBFeelessAddresses.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IJBFeelessAddresses} from \"./interfaces/IJBFeelessAddresses.sol\";\n\n/// @notice Stores a list of addresses that shouldn't incur fees when sending or receiving payments.\ncontract JBFeelessAddresses is Ownable, IJBFeelessAddresses, IERC165 {\n    //*********************************************************************//\n    // --------------------- public stored properties -------------------- //\n    //*********************************************************************//\n\n    /// @notice Check if the specified address is feeless.\n    /// @dev Feeless addresses can receive payouts without incurring a fee.\n    /// @dev Feeless addresses can use the surplus allowance without incurring a fee.\n    /// @dev Feeless addresses can be the beneficary of redemptions without incurring a fee.\n    /// @custom:param addr The address to check.\n    mapping(address addr => bool) public override isFeeless;\n\n    //*********************************************************************//\n    // -------------------------- public views --------------------------- //\n    //*********************************************************************//\n\n    /// @notice Indicates whether this contract adheres to the specified interface.\n    /// @dev See {IERC165-supportsInterface}.\n    /// @param interfaceId The ID of the interface to check for adherence to.\n    /// @return A flag indicating if the provided interface ID is supported.\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IJBFeelessAddresses).interfaceId || interfaceId == type(IERC165).interfaceId;\n    }\n\n    /// @param owner This contract's owner.\n    constructor(address owner) Ownable(owner) {}\n\n    //*********************************************************************//\n    // ---------------------- external transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice Sets whether an address is feeless.\n    /// @dev Can only be called by this contract's owner.\n    /// @param addr The address to set as feeless or not feeless.\n    /// @param flag Whether the address should be feeless (`true`) or not feeless (`false`).\n    function setFeelessAddress(address addr, bool flag) external virtual override onlyOwner {\n        isFeeless[addr] = flag;\n\n        emit SetFeelessAddress(addr, flag, _msgSender());\n    }\n}\n"
			},
			"src/interfaces/IJBFeelessAddresses.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBFeelessAddresses {\n    event SetFeelessAddress(address indexed account, bool indexed isFeeless, address caller);\n\n    function isFeeless(address account) external view returns (bool);\n\n    function setFeelessAddress(address account, bool flag) external;\n}\n"
			},
			"src/JBPrices.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {JBPermissionIds} from \"@bananapus/permission-ids/src/JBPermissionIds.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {mulDiv} from \"@prb/math/src/Common.sol\";\n\nimport {JBPermissioned} from \"./abstract/JBPermissioned.sol\";\nimport {IJBPermissions} from \"./interfaces/IJBPermissions.sol\";\nimport {IJBPriceFeed} from \"./interfaces/IJBPriceFeed.sol\";\nimport {IJBPrices} from \"./interfaces/IJBPrices.sol\";\nimport {IJBProjects} from \"./interfaces/IJBProjects.sol\";\n\n/// @notice Manages and normalizes price feeds. Price feeds are contracts which return the \"pricing currency\" cost of 1\n/// \"unit currency\".\ncontract JBPrices is JBPermissioned, Ownable, IJBPrices {\n    //*********************************************************************//\n    // --------------------------- custom errors ------------------------- //\n    //*********************************************************************//\n    error INVALID_CURRENCY();\n    error PRICE_FEED_ALREADY_EXISTS();\n    error PRICE_FEED_NOT_FOUND();\n\n    //*********************************************************************//\n    // ------------------------- public constants ------------------------ //\n    //*********************************************************************//\n\n    /// @notice The ID to store default values in.\n    uint256 public constant override DEFAULT_PROJECT_ID = 0;\n\n    //*********************************************************************//\n    // ---------------- public immutable stored properties --------------- //\n    //*********************************************************************//\n\n    /// @notice Mints ERC-721s that represent project ownership and transfers.\n    IJBProjects public immutable override PROJECTS;\n\n    //*********************************************************************//\n    // --------------------- public stored properties -------------------- //\n    //*********************************************************************//\n\n    /// @notice The available price feeds.\n    /// @dev The feed returns the `pricingCurrency` cost for one unit of the `unitCurrency`.\n    /// @custom:param projectId The ID of the project the feed applies to. Feeds stored in ID 0 are used by default for\n    /// all projects.\n    /// @custom:param pricingCurrency The currency the feed's resulting price is in terms of.\n    /// @custom:param unitCurrency The currency being priced by the feed.\n    mapping(uint256 projectId => mapping(uint256 pricingCurrency => mapping(uint256 unitCurrency => IJBPriceFeed)))\n        public\n        override priceFeedFor;\n\n    //*********************************************************************//\n    // -------------------------- public views --------------------------- //\n    //*********************************************************************//\n\n    /// @notice Gets the `pricingCurrency` cost for one unit of the `unitCurrency`.\n    /// @param projectId The ID of the project to check the feed for. Feeds stored in ID 0 are used by default for all\n    /// projects.\n    /// @param pricingCurrency The currency the feed's resulting price is in terms of.\n    /// @param unitCurrency The currency being priced by the feed.\n    /// @param decimals The number of decimals the returned fixed point price should include.\n    /// @return The `pricingCurrency` price of 1 `unitCurrency`, as a fixed point number with the specified number of\n    /// decimals.\n    function pricePerUnitOf(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency,\n        uint256 decimals\n    )\n        public\n        view\n        override\n        returns (uint256)\n    {\n        // If the `pricingCurrency` is the `unitCurrency`, return 1 since they have the same price. Include the\n        // desired number of decimals.\n        if (pricingCurrency == unitCurrency) return 10 ** decimals;\n\n        // Get a reference to the price feed.\n        IJBPriceFeed feed = priceFeedFor[projectId][pricingCurrency][unitCurrency];\n\n        // If the feed exists, return its price.\n        if (feed != IJBPriceFeed(address(0))) return feed.currentUnitPrice(decimals);\n\n        // Try getting the inverse feed.\n        feed = priceFeedFor[projectId][unitCurrency][pricingCurrency];\n\n        // If it exists, return the inverse of its price.\n        if (feed != IJBPriceFeed(address(0))) {\n            return mulDiv(10 ** decimals, 10 ** decimals, feed.currentUnitPrice(decimals));\n        }\n\n        // Check for a default feed (project ID 0) if not found.\n        if (projectId != DEFAULT_PROJECT_ID) {\n            return pricePerUnitOf({\n                projectId: DEFAULT_PROJECT_ID,\n                pricingCurrency: pricingCurrency,\n                unitCurrency: unitCurrency,\n                decimals: decimals\n            });\n        }\n\n        // No price feed available, revert.\n        revert PRICE_FEED_NOT_FOUND();\n    }\n\n    //*********************************************************************//\n    // ---------------------------- constructor -------------------------- //\n    //*********************************************************************//\n\n    /// @param permissions A contract storing permissions.\n    /// @param projects A contract which mints ERC-721s that represent project ownership and transfers.\n    /// @param owner The address that will own the contract.\n    constructor(\n        IJBPermissions permissions,\n        IJBProjects projects,\n        address owner\n    )\n        JBPermissioned(permissions)\n        Ownable(owner)\n    {\n        PROJECTS = projects;\n    }\n\n    //*********************************************************************//\n    // ---------------------- external transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice Add a price feed for the `unitCurrency`, priced in terms of the `pricingCurrency`.\n    /// @dev Existing feeds can't be modified. Neither can feeds that have already been set as defaults (project ID 0).\n    /// @param pricingCurrency The currency the feed's resulting price is in terms of.\n    /// @param unitCurrency The currency being priced by the feed.\n    /// @param feed The price feed being added.\n    function addPriceFeedFor(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency,\n        IJBPriceFeed feed\n    )\n        external\n        override\n    {\n        // If the message sender is this contract's owner and the `projectId` being set for is the default (0), no\n        // permissions necessary.\n        // Otherwise, only a project's owner or an operator with the `ADD_PRICE_FEED` permission from that owner can add\n        // a feed for a project.\n        if (projectId != DEFAULT_PROJECT_ID || msg.sender != owner()) {\n            _requirePermissionFrom({\n                account: PROJECTS.ownerOf(projectId),\n                projectId: projectId,\n                permissionId: JBPermissionIds.ADD_PRICE_FEED\n            });\n        }\n\n        // Make sure the currencies aren't 0.\n        if (pricingCurrency == 0 || unitCurrency == 0) revert INVALID_CURRENCY();\n\n        // Make sure there aren't default feeds for the pair or its inverse.\n        if (\n            priceFeedFor[DEFAULT_PROJECT_ID][pricingCurrency][unitCurrency] != IJBPriceFeed(address(0))\n                || priceFeedFor[DEFAULT_PROJECT_ID][unitCurrency][pricingCurrency] != IJBPriceFeed(address(0))\n        ) {\n            revert PRICE_FEED_ALREADY_EXISTS();\n        }\n\n        // Make sure this project doesn't already have feeds for the pair or its inverse.\n        if (\n            priceFeedFor[projectId][pricingCurrency][unitCurrency] != IJBPriceFeed(address(0))\n                || priceFeedFor[projectId][unitCurrency][pricingCurrency] != IJBPriceFeed(address(0))\n        ) revert PRICE_FEED_ALREADY_EXISTS();\n\n        // Store the feed.\n        priceFeedFor[projectId][pricingCurrency][unitCurrency] = feed;\n\n        emit AddPriceFeed(projectId, pricingCurrency, unitCurrency, feed);\n    }\n}\n"
			},
			"src/interfaces/IJBPriceFeed.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IJBPriceFeed {\n    function currentUnitPrice(uint256 targetDecimals) external view returns (uint256);\n}\n"
			},
			"src/interfaces/IJBPrices.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBPriceFeed} from \"./IJBPriceFeed.sol\";\nimport {IJBProjects} from \"./IJBProjects.sol\";\n\ninterface IJBPrices {\n    event AddPriceFeed(\n        uint256 indexed projectId, uint256 indexed pricingCurrency, uint256 indexed unitCurrency, IJBPriceFeed feed\n    );\n\n    function DEFAULT_PROJECT_ID() external view returns (uint256);\n\n    function PROJECTS() external view returns (IJBProjects);\n\n    function priceFeedFor(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency\n    )\n        external\n        view\n        returns (IJBPriceFeed);\n\n    function pricePerUnitOf(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency,\n        uint256 decimals\n    )\n        external\n        view\n        returns (uint256);\n\n    function addPriceFeedFor(\n        uint256 projectId,\n        uint256 pricingCurrency,\n        uint256 unitCurrency,\n        IJBPriceFeed priceFeed\n    )\n        external;\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
			},
			"src/JBTerminalStore.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {mulDiv} from \"@prb/math/src/Common.sol\";\n\nimport {IJBController} from \"./interfaces/IJBController.sol\";\nimport {IJBDirectory} from \"./interfaces/IJBDirectory.sol\";\nimport {IJBPrices} from \"./interfaces/IJBPrices.sol\";\nimport {IJBRulesetDataHook} from \"./interfaces/IJBRulesetDataHook.sol\";\nimport {IJBRulesets} from \"./interfaces/IJBRulesets.sol\";\nimport {IJBTerminal} from \"./interfaces/IJBTerminal.sol\";\nimport {IJBTerminalStore} from \"./interfaces/IJBTerminalStore.sol\";\nimport {JBConstants} from \"./libraries/JBConstants.sol\";\nimport {JBFixedPointNumber} from \"./libraries/JBFixedPointNumber.sol\";\nimport {JBRulesetMetadataResolver} from \"./libraries/JBRulesetMetadataResolver.sol\";\nimport {JBAccountingContext} from \"./structs/JBAccountingContext.sol\";\nimport {JBBeforePayRecordedContext} from \"./structs/JBBeforePayRecordedContext.sol\";\nimport {JBBeforeRedeemRecordedContext} from \"./structs/JBBeforeRedeemRecordedContext.sol\";\nimport {JBCurrencyAmount} from \"./structs/JBCurrencyAmount.sol\";\nimport {JBPayHookSpecification} from \"./structs/JBPayHookSpecification.sol\";\nimport {JBRedeemHookSpecification} from \"./structs/JBRedeemHookSpecification.sol\";\nimport {JBRuleset} from \"./structs/JBRuleset.sol\";\nimport {JBTokenAmount} from \"./structs/JBTokenAmount.sol\";\n\n/// @notice Manages all bookkeeping for inflows and outflows of funds from any terminal address.\n/// @dev This contract expects a project's controller to be an `IJBController`.\ncontract JBTerminalStore is ReentrancyGuard, IJBTerminalStore {\n    // A library that parses the packed ruleset metadata into a friendlier format.\n    using JBRulesetMetadataResolver for JBRuleset;\n\n    //*********************************************************************//\n    // --------------------------- custom errors ------------------------- //\n    //*********************************************************************//\n    error INVALID_AMOUNT_TO_SEND_HOOK();\n    error PAYOUT_LIMIT_EXCEEDED();\n    error RULESET_PAYMENT_PAUSED();\n    error INADEQUATE_CONTROLLER_ALLOWANCE();\n    error INADEQUATE_TERMINAL_STORE_BALANCE();\n    error INSUFFICIENT_TOKENS();\n    error INVALID_RULESET();\n    error TERMINAL_MIGRATION_NOT_ALLOWED();\n\n    //*********************************************************************//\n    // -------------------------- internal constants --------------------- //\n    //*********************************************************************//\n\n    /// @notice Constrains `mulDiv` operations on fixed point numbers to a maximum number of decimal points of persisted\n    /// fidelity.\n    uint256 internal constant _MAX_FIXED_POINT_FIDELITY = 18;\n\n    //*********************************************************************//\n    // ---------------- public immutable stored properties --------------- //\n    //*********************************************************************//\n\n    /// @notice The directory of terminals and controllers for projects.\n    IJBDirectory public immutable override DIRECTORY;\n\n    /// @notice The contract storing and managing project rulesets.\n    IJBRulesets public immutable override RULESETS;\n\n    /// @notice The contract that exposes price feeds.\n    IJBPrices public immutable override PRICES;\n\n    //*********************************************************************//\n    // --------------------- public stored properties -------------------- //\n    //*********************************************************************//\n\n    /// @notice A project's balance of a specific token within a terminal.\n    /// @dev The balance is represented as a fixed point number with the same amount of decimals as its relative\n    /// terminal.\n    /// @custom:param terminal The terminal to get the project's balance within.\n    /// @custom:param projectId The ID of the project to get the balance of.\n    /// @custom:param token The token to get the balance for.\n    mapping(address terminal => mapping(uint256 projectId => mapping(address token => uint256))) public override\n        balanceOf;\n\n    /// @notice The currency-denominated amount of funds that a project has already paid out from its payout limit\n    /// during the current ruleset for each terminal, in terms of the payout limit's currency.\n    /// @dev Increases as projects pay out funds.\n    /// @dev The used payout limit is represented as a fixed point number with the same amount of decimals as the\n    /// terminal it applies to.\n    /// @custom:param terminal The terminal the payout limit applies to.\n    /// @custom:param projectId The ID of the project to get the used payout limit of.\n    /// @custom:param token The token the payout limit applies to in the terminal.\n    /// @custom:param rulesetCycleNumber The cycle number of the ruleset the payout limit was used during.\n    /// @custom:param currency The currency the payout limit is in terms of.\n    mapping(\n        address terminal\n            => mapping(\n                uint256 projectId\n                    => mapping(\n                        address token => mapping(uint256 rulesetCycleNumber => mapping(uint256 currency => uint256))\n                    )\n            )\n    ) public override usedPayoutLimitOf;\n\n    /// @notice The currency-denominated amounts of funds that a project has used from its surplus allowance during the\n    /// current ruleset for each terminal, in terms of the surplus allowance's currency.\n    /// @dev Increases as projects use their allowance.\n    /// @dev The used surplus allowance is represented as a fixed point number with the same amount of decimals as the\n    /// terminal it applies to.\n    /// @custom:param terminal The terminal the surplus allowance applies to.\n    /// @custom:param projectId The ID of the project to get the used surplus allowance of.\n    /// @custom:param token The token the surplus allowance applies to in the terminal.\n    /// @custom:param rulesetId The ID of the ruleset the surplus allowance was used during.\n    /// @custom:param currency The currency the surplus allowance is in terms of.\n    mapping(\n        address terminal\n            => mapping(\n                uint256 projectId\n                    => mapping(address token => mapping(uint256 rulesetId => mapping(uint256 currency => uint256)))\n            )\n    ) public override usedSurplusAllowanceOf;\n\n    //*********************************************************************//\n    // ------------------------- external views -------------------------- //\n    //*********************************************************************//\n\n    /// @notice Gets the current surplus amount in a terminal for a specified project.\n    /// @dev The surplus is the amount of funds a project has in a terminal in excess of its payout limit.\n    /// @dev The surplus is represented as a fixed point number with the same amount of decimals as the specified\n    /// terminal.\n    /// @param terminal The terminal the surplus is being calculated for.\n    /// @param projectId The ID of the project to get surplus for.\n    /// @param accountingContexts The accounting contexts of tokens whose balances should contribute to the surplus\n    /// being calculated.\n    /// @param currency The currency the resulting amount should be in terms of.\n    /// @param decimals The number of decimals to expect in the resulting fixed point number.\n    /// @return The current surplus amount the project has in the specified terminal.\n    function currentSurplusOf(\n        address terminal,\n        uint256 projectId,\n        JBAccountingContext[] calldata accountingContexts,\n        uint256 decimals,\n        uint256 currency\n    )\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // Return the surplus during the project's current ruleset.\n        return _surplusFrom({\n            terminal: terminal,\n            projectId: projectId,\n            accountingContexts: accountingContexts,\n            ruleset: RULESETS.currentOf(projectId),\n            targetDecimals: decimals,\n            targetCurrency: currency\n        });\n    }\n\n    /// @notice Gets the current surplus amount for a specified project across all terminals.\n    /// @param projectId The ID of the project to get the total surplus for.\n    /// @param decimals The number of decimals that the fixed point surplus should include.\n    /// @param currency The currency that the total surplus should be in terms of.\n    /// @return The current total surplus amount that the project has across all terminals.\n    function currentTotalSurplusOf(\n        uint256 projectId,\n        uint256 decimals,\n        uint256 currency\n    )\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _currentTotalSurplusOf(projectId, decimals, currency);\n    }\n\n    /// @notice The surplus amount that can currently be reclaimed from a terminal by redeeming the specified number of\n    /// tokens, based on the total token supply and current surplus.\n    /// @dev The returned amount in terms of the specified terminal's currency.\n    /// @dev The returned amount is represented as a fixed point number with the same amount of decimals as the\n    /// specified terminal.\n    /// @param terminal The terminal the redeemable amount would come from.\n    /// @param projectId The ID of the project to get the redeemable surplus amount for.\n    /// @param accountingContexts The accounting contexts of tokens whose balances should contribute to the surplus\n    /// being reclaimed from.\n    /// @param decimals The number of decimals to include in the resulting fixed point number.\n    /// @param currency The currency that the resulting number will be in terms of.\n    /// @param tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    /// @param useTotalSurplus A flag indicating whether the surplus used in the calculation should be summed from all\n    /// of the project's terminals. If false, surplus should be limited to the amount in the specified `terminal`.\n    /// @return The amount of surplus tokens that can be reclaimed by redeeming `tokenCount` tokens as a fixed point\n    /// number with the specified number of decimals.\n    function currentReclaimableSurplusOf(\n        address terminal,\n        uint256 projectId,\n        JBAccountingContext[] calldata accountingContexts,\n        uint256 decimals,\n        uint256 currency,\n        uint256 tokenCount,\n        bool useTotalSurplus\n    )\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // Get a reference to the project's current ruleset.\n        JBRuleset memory ruleset = RULESETS.currentOf(projectId);\n\n        // Get the current surplus amount.\n        // Use the project's total surplus across all of its terminals if the flag species specifies so. Otherwise, use\n        // the surplus local to the specified terminal.\n        uint256 currentSurplus = useTotalSurplus\n            ? _currentTotalSurplusOf(projectId, decimals, currency)\n            : _surplusFrom(terminal, projectId, accountingContexts, ruleset, decimals, currency);\n\n        // If there's no surplus, there's no reclaimable surplus.\n        if (currentSurplus == 0) return 0;\n\n        // Get the number of outstanding tokens the project has.\n        uint256 totalSupply =\n            IJBController(address(DIRECTORY.controllerOf(projectId))).totalTokenSupplyWithReservedTokensOf(projectId);\n\n        // Can't redeem more tokens that is in the supply.\n        if (tokenCount > totalSupply) return 0;\n\n        // Return the reclaimable surplus amount.\n        return _reclaimableSurplusFrom({\n            surplus: currentSurplus,\n            tokenCount: tokenCount,\n            totalSupply: totalSupply,\n            redemptionRate: ruleset.redemptionRate()\n        });\n    }\n\n    /// @notice The current amount of surplus tokens from a terminal that can be reclaimed by redeeming the specified\n    /// number of tokens, based on the specified total token supply and surplus amounts.\n    /// @param projectId The ID of the project to get the reclaimable surplus amount for.\n    /// @param tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    /// @param totalSupply The total number of tokens to make the calculation with, as a fixed point number with 18\n    /// decimals.\n    /// @param surplus The surplus amount to make the calculation with, as a fixed point number.\n    /// @return The surplus token amount that can be reclaimed, as a fixed point number with the same number of decimals\n    /// as the provided `surplus`.\n    function currentReclaimableSurplusOf(\n        uint256 projectId,\n        uint256 tokenCount,\n        uint256 totalSupply,\n        uint256 surplus\n    )\n        external\n        view\n        override\n        returns (uint256)\n    {\n        // If there's no surplus, there's no reclaimable surplus.\n        if (surplus == 0) return 0;\n\n        // Can't redeem more tokens than is in the supply.\n        if (tokenCount > totalSupply) return 0;\n\n        // Get a reference to the project's current ruleset.\n        JBRuleset memory ruleset = RULESETS.currentOf(projectId);\n\n        // Return the reclaimable surplus amount.\n        return _reclaimableSurplusFrom({\n            surplus: surplus,\n            tokenCount: tokenCount,\n            totalSupply: totalSupply,\n            redemptionRate: ruleset.redemptionRate()\n        });\n    }\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param directory A contract storing directories of terminals and controllers for each project.\n    /// @param rulesets A contract storing and managing project rulesets.\n    /// @param prices A contract that exposes price feeds.\n    constructor(IJBDirectory directory, IJBRulesets rulesets, IJBPrices prices) {\n        DIRECTORY = directory;\n        RULESETS = rulesets;\n        PRICES = prices;\n    }\n\n    //*********************************************************************//\n    // ---------------------- external transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice Records a payment to a project.\n    /// @dev Mints the project's tokens according to values provided by the ruleset's data hook. If the ruleset has no\n    /// data hook, mints tokens in proportion with the amount paid.\n    /// @param payer The address that made the payment to the terminal.\n    /// @param amount The amount of tokens being paid. Includes the token being paid, their value, the number of\n    /// decimals included, and the currency of the amount.\n    /// @param projectId The ID of the project being paid.\n    /// @param beneficiary The address that should be the beneficiary of anything the payment yields (including project\n    /// tokens minted by the payment).\n    /// @param metadata Bytes to send to the data hook, if the project's current ruleset specifies one.\n    /// @return ruleset The ruleset the payment was made during, as a `JBRuleset` struct.\n    /// @return tokenCount The number of project tokens that were minted, as a fixed point number with 18 decimals.\n    /// @return hookSpecifications A list of pay hooks, including data and amounts to send to them. The terminal should\n    /// fulfill these specifications.\n    function recordPaymentFrom(\n        address payer,\n        JBTokenAmount calldata amount,\n        uint256 projectId,\n        address beneficiary,\n        bytes calldata metadata\n    )\n        external\n        override\n        nonReentrant\n        returns (JBRuleset memory ruleset, uint256 tokenCount, JBPayHookSpecification[] memory hookSpecifications)\n    {\n        // Get a reference to the project's current ruleset.\n        ruleset = RULESETS.currentOf(projectId);\n\n        // The project must have a ruleset.\n        if (ruleset.cycleNumber == 0) revert INVALID_RULESET();\n\n        // The ruleset must not have payments paused.\n        if (ruleset.pausePay()) revert RULESET_PAYMENT_PAUSED();\n\n        // The weight according to which new tokens are to be minted, as a fixed point number with 18 decimals.\n        uint256 weight;\n\n        // If the ruleset has a data hook enabled for payments, use it to derive a weight and memo.\n        if (ruleset.useDataHookForPay() && ruleset.dataHook() != address(0)) {\n            // Create the pay context that'll be sent to the data hook.\n            JBBeforePayRecordedContext memory context = JBBeforePayRecordedContext({\n                terminal: msg.sender,\n                payer: payer,\n                amount: amount,\n                projectId: projectId,\n                rulesetId: ruleset.id,\n                beneficiary: beneficiary,\n                weight: ruleset.weight,\n                reservedRate: ruleset.reservedRate(),\n                metadata: metadata\n            });\n\n            (weight, hookSpecifications) = IJBRulesetDataHook(ruleset.dataHook()).beforePayRecordedWith(context);\n        }\n        // Otherwise use the ruleset's weight\n        else {\n            weight = ruleset.weight;\n        }\n\n        // Keep a reference to the amount that should be added to the project's balance.\n        uint256 balanceDiff = amount.value;\n\n        // Scoped section preventing stack too deep.\n        {\n            // Keep a reference to the number of hook specifications.\n            uint256 numberOfSpecifications = hookSpecifications.length;\n\n            // Ensure that the specifications have valid amounts.\n            if (numberOfSpecifications != 0) {\n                for (uint256 i; i < numberOfSpecifications; i++) {\n                    // Get a reference to the specification's amount.\n                    uint256 specifiedAmount = hookSpecifications[i].amount;\n\n                    // Ensure the amount is non-zero.\n                    if (specifiedAmount != 0) {\n                        // Can't send more to hook than was paid.\n                        if (specifiedAmount > balanceDiff) {\n                            revert INVALID_AMOUNT_TO_SEND_HOOK();\n                        }\n\n                        // Decrement the total amount being added to the local balance.\n                        balanceDiff = balanceDiff - specifiedAmount;\n                    }\n                }\n            }\n        }\n\n        // If there's no amount being recorded, there's nothing left to do.\n        if (amount.value == 0) return (ruleset, 0, hookSpecifications);\n\n        // Add the correct balance difference to the token balance of the project.\n        if (balanceDiff != 0) {\n            balanceOf[msg.sender][projectId][amount.token] =\n                balanceOf[msg.sender][projectId][amount.token] + balanceDiff;\n        }\n\n        // If there's no weight, the token count must be 0, so there's nothing left to do.\n        if (weight == 0) return (ruleset, 0, hookSpecifications);\n\n        // If the terminal should base its weight on a currency other than the terminal's currency, determine the\n        // factor. The weight is always a fixed point mumber with 18 decimals. To ensure this, the ratio should use the\n        // same\n        // number of decimals as the `amount`.\n        uint256 weightRatio = amount.currency == ruleset.baseCurrency()\n            ? 10 ** amount.decimals\n            : PRICES.pricePerUnitOf({\n                projectId: projectId,\n                pricingCurrency: amount.currency,\n                unitCurrency: ruleset.baseCurrency(),\n                decimals: amount.decimals\n            });\n\n        // Find the number of tokens to mint, as a fixed point number with as many decimals as `weight` has.\n        tokenCount = mulDiv(amount.value, weight, weightRatio);\n    }\n\n    /// @notice Records a redemption from a project.\n    /// @dev Redeems the project's tokens according to values provided by the ruleset's data hook. If the ruleset has no\n    /// data hook, redeems tokens along a redemption bonding curve that is a function of the number of tokens being\n    /// burned.\n    /// @param holder The account that is redeeming tokens.\n    /// @param projectId The ID of the project being redeemed from.\n    /// @param redeemCount The number of project tokens to redeem, as a fixed point number with 18 decimals.\n    /// @param accountingContext The accounting context of the token being reclaimed by the redemption.\n    /// @param balanceAccountingContexts The accounting contexts of the tokens whose balances should contribute to the\n    /// surplus being reclaimed from.\n    /// @param metadata Bytes to send to the data hook, if the project's current ruleset specifies one.\n    /// @return ruleset The ruleset during the redemption was made during, as a `JBRuleset` struct. This ruleset will\n    /// have a redemption rate provided by the redemption hook if applicable.\n    /// @return reclaimAmount The amount of tokens reclaimed from the terminal, as a fixed point number with 18\n    /// decimals.\n    /// @return redemptionRate The redemption rate influencing the reclaim amount.\n    /// @return hookSpecifications A list of redeem hooks, including data and amounts to send to them. The terminal\n    /// should fulfill these specifications.\n    function recordRedemptionFor(\n        address holder,\n        uint256 projectId,\n        uint256 redeemCount,\n        JBAccountingContext calldata accountingContext,\n        JBAccountingContext[] calldata balanceAccountingContexts,\n        bytes memory metadata\n    )\n        external\n        override\n        nonReentrant\n        returns (\n            JBRuleset memory ruleset,\n            uint256 reclaimAmount,\n            uint256 redemptionRate,\n            JBRedeemHookSpecification[] memory hookSpecifications\n        )\n    {\n        // Get a reference to the project's current ruleset.\n        ruleset = RULESETS.currentOf(projectId);\n\n        // Get the current surplus amount.\n        // Use the local surplus if the ruleset specifies that it should be used. Otherwise, use the project's total\n        // surplus across all of its terminals.\n        uint256 currentSurplus = ruleset.useTotalSurplusForRedemptions()\n            ? _currentTotalSurplusOf({\n                projectId: projectId,\n                decimals: accountingContext.decimals,\n                currency: accountingContext.currency\n            })\n            : _surplusFrom({\n                terminal: msg.sender,\n                projectId: projectId,\n                accountingContexts: balanceAccountingContexts,\n                ruleset: ruleset,\n                targetDecimals: accountingContext.decimals,\n                targetCurrency: accountingContext.currency\n            });\n\n        // Get the total number of outstanding project tokens.\n        uint256 totalSupply =\n            IJBController(address(DIRECTORY.controllerOf(projectId))).totalTokenSupplyWithReservedTokensOf(projectId);\n\n        // Can't redeem more tokens that are in the supply.\n        if (redeemCount > totalSupply) revert INSUFFICIENT_TOKENS();\n\n        // If the ruleset has a data hook which is enabled for redemptions, use it to derive a claim amount and memo.\n        if (ruleset.useDataHookForRedeem() && ruleset.dataHook() != address(0)) {\n            // Create the redeem context that'll be sent to the data hook.\n            JBBeforeRedeemRecordedContext memory context = JBBeforeRedeemRecordedContext({\n                terminal: msg.sender,\n                holder: holder,\n                projectId: projectId,\n                rulesetId: ruleset.id,\n                redeemCount: redeemCount,\n                totalSupply: totalSupply,\n                surplus: JBTokenAmount({\n                    token: accountingContext.token,\n                    value: currentSurplus,\n                    decimals: accountingContext.decimals,\n                    currency: accountingContext.currency\n                }),\n                useTotalSurplus: ruleset.useTotalSurplusForRedemptions(),\n                redemptionRate: ruleset.redemptionRate(),\n                metadata: metadata\n            });\n\n            (redemptionRate, redeemCount, totalSupply, hookSpecifications) =\n                IJBRulesetDataHook(ruleset.dataHook()).beforeRedeemRecordedWith(context);\n        } else {\n            redemptionRate = ruleset.redemptionRate();\n        }\n\n        if (currentSurplus != 0) {\n            // Calculate reclaim amount using the current surplus amount.\n            reclaimAmount = _reclaimableSurplusFrom({\n                surplus: currentSurplus,\n                tokenCount: redeemCount,\n                totalSupply: totalSupply,\n                redemptionRate: redemptionRate\n            });\n        }\n\n        // Keep a reference to the amount that should be subtracted from the project's balance.\n        uint256 balanceDiff = reclaimAmount;\n\n        // Ensure that the specifications have valid amounts.\n        if (hookSpecifications.length != 0) {\n            // Keep a reference to the number of redeem hooks specified.\n            uint256 numberOfSpecifications = hookSpecifications.length;\n\n            // Loop through each specification.\n            for (uint256 i; i < numberOfSpecifications; i++) {\n                // Get a reference to the specification's amount.\n                uint256 specificationAmount = hookSpecifications[i].amount;\n\n                // Ensure the amount is non-zero.\n                if (specificationAmount != 0) {\n                    // Increment the total amount being subtracted from the balance.\n                    balanceDiff = balanceDiff + specificationAmount;\n                }\n            }\n        }\n\n        // The amount being reclaimed must be within the project's balance.\n        if (balanceDiff > balanceOf[msg.sender][projectId][accountingContext.token]) {\n            revert INADEQUATE_TERMINAL_STORE_BALANCE();\n        }\n\n        // Remove the reclaimed funds from the project's balance.\n        if (balanceDiff != 0) {\n            unchecked {\n                balanceOf[msg.sender][projectId][accountingContext.token] =\n                    balanceOf[msg.sender][projectId][accountingContext.token] - balanceDiff;\n            }\n        }\n    }\n\n    /// @notice Records a payout from a project.\n    /// @param projectId The ID of the project that is paying out funds.\n    /// @param accountingContext The context of the token being paid out.\n    /// @param amount The amount to pay out (use from the payout limit), as a fixed point number.\n    /// @param currency The currency of the `amount`. This must match the project's current ruleset's currency.\n    /// @return ruleset The ruleset the payout was made during, as a `JBRuleset` struct.\n    /// @return amountPaidOut The amount of terminal tokens paid out, as a fixed point number with the same amount of\n    /// decimals as its relative terminal.\n    function recordPayoutFor(\n        uint256 projectId,\n        JBAccountingContext calldata accountingContext,\n        uint256 amount,\n        uint256 currency\n    )\n        external\n        override\n        nonReentrant\n        returns (JBRuleset memory ruleset, uint256 amountPaidOut)\n    {\n        // Get a reference to the project's current ruleset.\n        ruleset = RULESETS.currentOf(projectId);\n\n        // The new total amount which has been paid out during this ruleset.\n        uint256 newUsedPayoutLimitOf =\n            usedPayoutLimitOf[msg.sender][projectId][accountingContext.token][ruleset.cycleNumber][currency] + amount;\n\n        // Amount must be within what is still available to pay out.\n        uint256 payoutLimit = IJBController(address(DIRECTORY.controllerOf(projectId))).FUND_ACCESS_LIMITS()\n            .payoutLimitOf({\n            projectId: projectId,\n            rulesetId: ruleset.id,\n            terminal: msg.sender,\n            token: accountingContext.token,\n            currency: currency\n        });\n\n        // Make sure the new used amount is within the payout limit.\n        if (newUsedPayoutLimitOf > payoutLimit || payoutLimit == 0) {\n            revert PAYOUT_LIMIT_EXCEEDED();\n        }\n\n        // Convert the amount to the balance's currency.\n        amountPaidOut = (currency == accountingContext.currency)\n            ? amount\n            : mulDiv(\n                amount,\n                10 ** _MAX_FIXED_POINT_FIDELITY, // Use `_MAX_FIXED_POINT_FIDELITY` to keep as much of the `_amount`'s\n                    // fidelity as possible when converting.\n                PRICES.pricePerUnitOf({\n                    projectId: projectId,\n                    pricingCurrency: currency,\n                    unitCurrency: accountingContext.currency,\n                    decimals: _MAX_FIXED_POINT_FIDELITY\n                })\n            );\n\n        // The amount being paid out must be available.\n        if (amountPaidOut > balanceOf[msg.sender][projectId][accountingContext.token]) {\n            revert INADEQUATE_TERMINAL_STORE_BALANCE();\n        }\n\n        // Store the new amount.\n        usedPayoutLimitOf[msg.sender][projectId][accountingContext.token][ruleset.cycleNumber][currency] =\n            newUsedPayoutLimitOf;\n\n        // Removed the paid out funds from the project's token balance.\n        unchecked {\n            balanceOf[msg.sender][projectId][accountingContext.token] =\n                balanceOf[msg.sender][projectId][accountingContext.token] - amountPaidOut;\n        }\n    }\n\n    /// @notice Records a use of a project's surplus allowance.\n    /// @dev When surplus allowance is \"used\", it is taken out of the project's surplus within a terminal.\n    /// @param projectId The ID of the project to use the surplus allowance of.\n    /// @param accountingContext The accounting context of the token whose balances should contribute to the surplus\n    /// allowance being reclaimed from.\n    /// @param amount The amount to use from the surplus allowance, as a fixed point number.\n    /// @param currency The currency of the `amount`. Must match the currency of the surplus allowance.\n    /// @return ruleset The ruleset during the surplus allowance is being used during, as a `JBRuleset` struct.\n    /// @return usedAmount The amount of terminal tokens used, as a fixed point number with the same amount of decimals\n    /// as its relative terminal.\n    function recordUsedAllowanceOf(\n        uint256 projectId,\n        JBAccountingContext calldata accountingContext,\n        uint256 amount,\n        uint256 currency\n    )\n        external\n        override\n        nonReentrant\n        returns (JBRuleset memory ruleset, uint256 usedAmount)\n    {\n        // Get a reference to the project's current ruleset.\n        ruleset = RULESETS.currentOf(projectId);\n\n        // Get a reference to the new used surplus allowance for this ruleset ID.\n        uint256 newUsedSurplusAllowanceOf =\n            usedSurplusAllowanceOf[msg.sender][projectId][accountingContext.token][ruleset.id][currency] + amount;\n\n        // There must be sufficient surplus allowance available.\n        uint256 surplusAllowance = IJBController(address(DIRECTORY.controllerOf(projectId))).FUND_ACCESS_LIMITS()\n            .surplusAllowanceOf({\n            projectId: projectId,\n            rulesetId: ruleset.id,\n            terminal: msg.sender,\n            token: accountingContext.token,\n            currency: currency\n        });\n\n        // Make sure the new used amount is within the allowance.\n        if (newUsedSurplusAllowanceOf > surplusAllowance || surplusAllowance == 0) {\n            revert INADEQUATE_CONTROLLER_ALLOWANCE();\n        }\n\n        // Convert the amount to this store's terminal's token.\n        usedAmount = currency == accountingContext.currency\n            ? amount\n            : mulDiv(\n                amount,\n                10 ** _MAX_FIXED_POINT_FIDELITY, // Use `_MAX_FIXED_POINT_FIDELITY` to keep as much of the `amount`'s\n                    // fidelity as possible when converting.\n                PRICES.pricePerUnitOf({\n                    projectId: projectId,\n                    pricingCurrency: currency,\n                    unitCurrency: accountingContext.currency,\n                    decimals: _MAX_FIXED_POINT_FIDELITY\n                })\n            );\n\n        // Set the token being used as the only one to look for surplus within.\n        JBAccountingContext[] memory accountingContexts = new JBAccountingContext[](1);\n        accountingContexts[0] = accountingContext;\n\n        // The amount being used must be available in the surplus.\n        if (\n            usedAmount\n                > _surplusFrom({\n                    terminal: msg.sender,\n                    projectId: projectId,\n                    accountingContexts: accountingContexts,\n                    ruleset: ruleset,\n                    targetDecimals: accountingContext.decimals,\n                    targetCurrency: accountingContext.currency\n                })\n        ) revert INADEQUATE_TERMINAL_STORE_BALANCE();\n\n        // Store the incremented value.\n        usedSurplusAllowanceOf[msg.sender][projectId][accountingContext.token][ruleset.id][currency] =\n            newUsedSurplusAllowanceOf;\n\n        // Update the project's balance.\n        balanceOf[msg.sender][projectId][accountingContext.token] =\n            balanceOf[msg.sender][projectId][accountingContext.token] - usedAmount;\n    }\n\n    /// @notice Records funds being added to a project's balance.\n    /// @param projectId The ID of the project which funds are being added to the balance of.\n    /// @param token The token being added to the balance.\n    /// @param amount The amount of terminal tokens added, as a fixed point number with the same amount of decimals as\n    /// its relative terminal.\n    function recordAddedBalanceFor(uint256 projectId, address token, uint256 amount) external override {\n        // Increment the balance.\n        balanceOf[msg.sender][projectId][token] = balanceOf[msg.sender][projectId][token] + amount;\n    }\n\n    /// @notice Records the migration of funds from this store.\n    /// @param projectId The ID of the project being migrated.\n    /// @param token The token being migrated.\n    /// @return balance The project's current balance (which is being migrated), as a fixed point number with the same\n    /// amount of decimals as its relative terminal.\n    function recordTerminalMigration(\n        uint256 projectId,\n        address token\n    )\n        external\n        override\n        nonReentrant\n        returns (uint256 balance)\n    {\n        // Get a reference to the project's current ruleset.\n        JBRuleset memory ruleset = RULESETS.currentOf(projectId);\n\n        // Terminal migration must be allowed.\n        if (!ruleset.allowTerminalMigration()) {\n            revert TERMINAL_MIGRATION_NOT_ALLOWED();\n        }\n\n        // Return the current balance, which is the amount being migrated.\n        balance = balanceOf[msg.sender][projectId][token];\n\n        // Set the balance to 0.\n        balanceOf[msg.sender][projectId][token] = 0;\n    }\n\n    //*********************************************************************//\n    // --------------------- internal helper functions ------------------- //\n    //*********************************************************************//\n\n    /// @notice The amount of surplus which is available for reclaiming via redemption given the number of tokens being\n    /// redeemed, the total supply, the current surplus, and the current ruleset.\n    /// @param surplus The surplus amount to make the calculation with.\n    /// @param tokenCount The number of tokens to make the calculation with, as a fixed point number with 18 decimals.\n    /// @param totalSupply The total supply of tokens to make the calculation with, as a fixed point number with 18\n    /// decimals.\n    /// @param redemptionRate The redemption rate with which the reclaimable surplus is being calculated.\n    /// @return The amount of surplus tokens that can be reclaimed.\n    function _reclaimableSurplusFrom(\n        uint256 surplus,\n        uint256 tokenCount,\n        uint256 totalSupply,\n        uint256 redemptionRate\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        // If the redemption rate is 0, nothing is claimable.\n        if (redemptionRate == 0) return 0;\n\n        // If the amount being redeemed is the total supply, return the rest of the surplus.\n        if (tokenCount == totalSupply) return surplus;\n\n        // Get a reference to the linear proportion.\n        uint256 base = mulDiv(surplus, tokenCount, totalSupply);\n\n        // These conditions are all part of the same curve. Edge conditions are separated because fewer operation are\n        // necessary.\n        if (redemptionRate == JBConstants.MAX_REDEMPTION_RATE) {\n            return base;\n        }\n\n        return mulDiv(\n            base,\n            redemptionRate + mulDiv(tokenCount, JBConstants.MAX_REDEMPTION_RATE - redemptionRate, totalSupply),\n            JBConstants.MAX_REDEMPTION_RATE\n        );\n    }\n\n    /// @notice Gets a project's surplus amount in a terminal as measured by a given ruleset, across multiple accounting\n    /// contexts.\n    /// @dev This amount changes as the value of the balance changes in relation to the currency being used to measure\n    /// various payout limits.\n    /// @param terminal The terminal the surplus is being calculated for.\n    /// @param projectId The ID of the project to get the surplus for.\n    /// @param accountingContexts The accounting contexts of tokens whose balances should contribute to the surplus\n    /// being calculated.\n    /// @param ruleset The ID of the ruleset to base the surplus on.\n    /// @param targetDecimals The number of decimals to include in the resulting fixed point number.\n    /// @param targetCurrency The currency that the reported surplus is expected to be in terms of.\n    /// @return surplus The surplus of funds in terms of `targetCurrency`, as a fixed point number with\n    /// `targetDecimals` decimals.\n    function _surplusFrom(\n        address terminal,\n        uint256 projectId,\n        JBAccountingContext[] memory accountingContexts,\n        JBRuleset memory ruleset,\n        uint256 targetDecimals,\n        uint256 targetCurrency\n    )\n        internal\n        view\n        returns (uint256 surplus)\n    {\n        // Keep a reference to the number of tokens being iterated on.\n        uint256 numberOfTokenAccountingContexts = accountingContexts.length;\n\n        // Add payout limits from each token.\n        for (uint256 i; i < numberOfTokenAccountingContexts; i++) {\n            uint256 tokenSurplus = _tokenSurplusFrom({\n                terminal: terminal,\n                projectId: projectId,\n                accountingContext: accountingContexts[i],\n                ruleset: ruleset,\n                targetDecimals: targetDecimals,\n                targetCurrency: targetCurrency\n            });\n            // Increment the surplus with any remaining balance.\n            if (tokenSurplus > 0) surplus += tokenSurplus;\n        }\n    }\n\n    /// @notice Get a project's surplus amount of a specific token in a given terminal as measured by a given ruleset\n    /// (one specific accounting context).\n    /// @dev This amount changes as the value of the balance changes in relation to the currency being used to measure\n    /// the payout limits.\n    /// @param terminal The terminal the surplus is being calculated for.\n    /// @param projectId The ID of the project to get the surplus of.\n    /// @param accountingContext The accounting context of the token whose balance should contribute to the surplus\n    /// being measured.\n    /// @param ruleset The ID of the ruleset to base the surplus calculation on.\n    /// @param targetDecimals The number of decimals to include in the resulting fixed point number.\n    /// @param targetCurrency The currency that the reported surplus is expected to be in terms of.\n    /// @return surplus The surplus of funds in terms of `targetCurrency`, as a fixed point number with\n    /// `targetDecimals` decimals.\n    function _tokenSurplusFrom(\n        address terminal,\n        uint256 projectId,\n        JBAccountingContext memory accountingContext,\n        JBRuleset memory ruleset,\n        uint256 targetDecimals,\n        uint256 targetCurrency\n    )\n        internal\n        view\n        returns (uint256 surplus)\n    {\n        // Keep a reference to the balance.\n        surplus = balanceOf[terminal][projectId][accountingContext.token];\n\n        // If needed, adjust the decimals of the fixed point number to have the correct decimals.\n        surplus = accountingContext.decimals == targetDecimals\n            ? surplus\n            : JBFixedPointNumber.adjustDecimals({\n                value: surplus,\n                decimals: accountingContext.decimals,\n                targetDecimals: targetDecimals\n            });\n\n        // Add up all the balances.\n        surplus = (surplus == 0 || accountingContext.currency == targetCurrency)\n            ? surplus\n            : mulDiv(\n                surplus,\n                10 ** _MAX_FIXED_POINT_FIDELITY, // Use `_MAX_FIXED_POINT_FIDELITY` to keep as much of the\n                    // `_payoutLimitRemaining`'s fidelity as possible when converting.\n                PRICES.pricePerUnitOf({\n                    projectId: projectId,\n                    pricingCurrency: accountingContext.currency,\n                    unitCurrency: targetCurrency,\n                    decimals: _MAX_FIXED_POINT_FIDELITY\n                })\n            );\n\n        // Get a reference to the payout limit during the ruleset for the token.\n        JBCurrencyAmount[] memory payoutLimits = IJBController(address(DIRECTORY.controllerOf(projectId)))\n            .FUND_ACCESS_LIMITS().payoutLimitsOf({\n            projectId: projectId,\n            rulesetId: ruleset.id,\n            terminal: address(terminal),\n            token: accountingContext.token\n        });\n\n        // Keep a reference to the payout limit being iterated on.\n        JBCurrencyAmount memory payoutLimit;\n\n        // Keep a reference to the number of payout limits being iterated on.\n        uint256 numberOfPayoutLimits = payoutLimits.length;\n\n        // Loop through each payout limit to determine the cumulative normalized payout limit remaining.\n        for (uint256 i; i < numberOfPayoutLimits; i++) {\n            payoutLimit = payoutLimits[i];\n\n            // Set the payout limit value to the amount still available to pay out during the ruleset.\n            payoutLimit.amount = payoutLimit.amount\n                - usedPayoutLimitOf[terminal][projectId][accountingContext.token][ruleset.cycleNumber][payoutLimit.currency];\n\n            // Adjust the decimals of the fixed point number if needed to have the correct decimals.\n            payoutLimit.amount = accountingContext.decimals == targetDecimals\n                ? payoutLimit.amount\n                : JBFixedPointNumber.adjustDecimals({\n                    value: payoutLimit.amount,\n                    decimals: accountingContext.decimals,\n                    targetDecimals: targetDecimals\n                });\n\n            // Convert the `payoutLimit`'s amount to be in terms of the provided currency.\n            payoutLimit.amount = payoutLimit.amount == 0 || payoutLimit.currency == targetCurrency\n                ? payoutLimit.amount\n                : mulDiv(\n                    payoutLimit.amount,\n                    10 ** _MAX_FIXED_POINT_FIDELITY, // Use `_MAX_FIXED_POINT_FIDELITY` to keep as much of the\n                        // `payoutLimitRemaining`'s fidelity as possible when converting.\n                    PRICES.pricePerUnitOf(projectId, payoutLimit.currency, targetCurrency, _MAX_FIXED_POINT_FIDELITY)\n                );\n\n            // Decrement from the balance until it reaches zero.\n            if (surplus > payoutLimit.amount) {\n                surplus -= payoutLimit.amount;\n            } else {\n                return 0;\n            }\n        }\n    }\n\n    /// @notice Gets the total current surplus amount across all of a project's terminals.\n    /// @dev This amount changes as the value of the balances changes in relation to the currency being used to measure\n    /// the project's payout limits.\n    /// @param projectId The ID of the project to get the total surplus for.\n    /// @param decimals The number of decimals that the fixed point surplus result should include.\n    /// @param currency The currency that the surplus result should be in terms of.\n    /// @return surplus The total surplus of a project's funds in terms of `currency`, as a fixed point number with the\n    /// specified number of decimals.\n    function _currentTotalSurplusOf(\n        uint256 projectId,\n        uint256 decimals,\n        uint256 currency\n    )\n        internal\n        view\n        returns (uint256 surplus)\n    {\n        // Get a reference to the project's terminals.\n        IJBTerminal[] memory terminals = DIRECTORY.terminalsOf(projectId);\n\n        // Keep a reference to the number of termainls.\n        uint256 numberOfTerminals = terminals.length;\n\n        // Add the current surplus for each terminal.\n        for (uint256 i; i < numberOfTerminals; i++) {\n            surplus += terminals[i].currentSurplusOf(projectId, decimals, currency);\n        }\n    }\n}\n"
			},
			"src/interfaces/IJBTerminalStore.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBAccountingContext} from \"./../structs/JBAccountingContext.sol\";\nimport {JBPayHookSpecification} from \"./../structs/JBPayHookSpecification.sol\";\nimport {JBRedeemHookSpecification} from \"./../structs/JBRedeemHookSpecification.sol\";\nimport {JBRuleset} from \"./../structs/JBRuleset.sol\";\nimport {JBTokenAmount} from \"./../structs/JBTokenAmount.sol\";\nimport {IJBDirectory} from \"./IJBDirectory.sol\";\nimport {IJBPrices} from \"./IJBPrices.sol\";\nimport {IJBRulesets} from \"./IJBRulesets.sol\";\n\ninterface IJBTerminalStore {\n    function RULESETS() external view returns (IJBRulesets);\n\n    function DIRECTORY() external view returns (IJBDirectory);\n\n    function PRICES() external view returns (IJBPrices);\n\n    function balanceOf(address terminal, uint256 projectId, address token) external view returns (uint256);\n\n    function usedPayoutLimitOf(\n        address terminal,\n        uint256 projectId,\n        address token,\n        uint256 rulesetCycleNumber,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256);\n\n    function usedSurplusAllowanceOf(\n        address terminal,\n        uint256 projectId,\n        address token,\n        uint256 rulesetId,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256);\n\n    function currentSurplusOf(\n        address terminal,\n        uint256 projectId,\n        JBAccountingContext[] calldata accountingContexts,\n        uint256 decimals,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256);\n\n    function currentTotalSurplusOf(\n        uint256 projectId,\n        uint256 decimals,\n        uint256 currency\n    )\n        external\n        view\n        returns (uint256);\n\n    function currentReclaimableSurplusOf(\n        address terminal,\n        uint256 projectId,\n        JBAccountingContext[] calldata accountingContexts,\n        uint256 _decimals,\n        uint256 _currency,\n        uint256 tokenCount,\n        bool useTotalSurplus\n    )\n        external\n        view\n        returns (uint256);\n\n    function currentReclaimableSurplusOf(\n        uint256 projectId,\n        uint256 tokenCount,\n        uint256 totalSupply,\n        uint256 surplus\n    )\n        external\n        view\n        returns (uint256);\n\n    function recordPaymentFrom(\n        address payer,\n        JBTokenAmount memory amount,\n        uint256 projectId,\n        address beneficiary,\n        bytes calldata metadata\n    )\n        external\n        returns (JBRuleset memory ruleset, uint256 tokenCount, JBPayHookSpecification[] memory hookSpecifications);\n\n    function recordRedemptionFor(\n        address holder,\n        uint256 projectId,\n        uint256 redeemCount,\n        JBAccountingContext calldata accountingContext,\n        JBAccountingContext[] calldata balanceAccountingContexts,\n        bytes calldata metadata\n    )\n        external\n        returns (\n            JBRuleset memory ruleset,\n            uint256 reclaimAmount,\n            uint256 redemptionRate,\n            JBRedeemHookSpecification[] memory hookSpecifications\n        );\n\n    function recordPayoutFor(\n        uint256 projectId,\n        JBAccountingContext calldata accountingContext,\n        uint256 amount,\n        uint256 currency\n    )\n        external\n        returns (JBRuleset memory ruleset, uint256 amountPaidOut);\n\n    function recordUsedAllowanceOf(\n        uint256 projectId,\n        JBAccountingContext calldata accountingContext,\n        uint256 amount,\n        uint256 currency\n    )\n        external\n        returns (JBRuleset memory ruleset, uint256 withdrawnAmount);\n\n    function recordAddedBalanceFor(uint256 projectId, address token, uint256 amount) external;\n\n    function recordTerminalMigration(uint256 projectId, address token) external returns (uint256 balance);\n}\n"
			},
			"src/libraries/JBFixedPointNumber.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nlibrary JBFixedPointNumber {\n    function adjustDecimals(uint256 value, uint256 decimals, uint256 targetDecimals) internal pure returns (uint256) {\n        // If decimals need adjusting, multiply or divide the price by the decimal adjuster to get the normalized\n        // result.\n        if (targetDecimals == decimals) return value;\n        else if (targetDecimals > decimals) return value * 10 ** (targetDecimals - decimals);\n        else return value / 10 ** (decimals - targetDecimals);\n    }\n}\n"
			},
			"node_modules/@openzeppelin/contracts/utils/introspection/ERC165Checker.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface.\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\n            !supportsERC165InterfaceUnchecked(account, INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function getSupportedInterfaces(\n        address account,\n        bytes4[] memory interfaceIds\n    ) internal view returns (bool[] memory) {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     *\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\n     * should be exercised when using this function.\n     *\n     * Interface identification is specified in ERC-165.\n     */\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeCall(IERC165.supportsInterface, (interfaceId));\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}\n"
			},
			"node_modules/@uniswap/permit2/src/interfaces/IAllowanceTransfer.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IEIP712} from \"./IEIP712.sol\";\n\n/// @title AllowanceTransfer\n/// @notice Handles ERC20 token permissions through signature based allowance setting and ERC20 token transfers by checking allowed amounts\n/// @dev Requires user's token approval on the Permit2 contract\ninterface IAllowanceTransfer is IEIP712 {\n    /// @notice Thrown when an allowance on a token has expired.\n    /// @param deadline The timestamp at which the allowed amount is no longer valid\n    error AllowanceExpired(uint256 deadline);\n\n    /// @notice Thrown when an allowance on a token has been depleted.\n    /// @param amount The maximum amount allowed\n    error InsufficientAllowance(uint256 amount);\n\n    /// @notice Thrown when too many nonces are invalidated.\n    error ExcessiveInvalidation();\n\n    /// @notice Emits an event when the owner successfully invalidates an ordered nonce.\n    event NonceInvalidation(\n        address indexed owner, address indexed token, address indexed spender, uint48 newNonce, uint48 oldNonce\n    );\n\n    /// @notice Emits an event when the owner successfully sets permissions on a token for the spender.\n    event Approval(\n        address indexed owner, address indexed token, address indexed spender, uint160 amount, uint48 expiration\n    );\n\n    /// @notice Emits an event when the owner successfully sets permissions using a permit signature on a token for the spender.\n    event Permit(\n        address indexed owner,\n        address indexed token,\n        address indexed spender,\n        uint160 amount,\n        uint48 expiration,\n        uint48 nonce\n    );\n\n    /// @notice Emits an event when the owner sets the allowance back to 0 with the lockdown function.\n    event Lockdown(address indexed owner, address token, address spender);\n\n    /// @notice The permit data for a token\n    struct PermitDetails {\n        // ERC20 token address\n        address token;\n        // the maximum amount allowed to spend\n        uint160 amount;\n        // timestamp at which a spender's token allowances become invalid\n        uint48 expiration;\n        // an incrementing value indexed per owner,token,and spender for each signature\n        uint48 nonce;\n    }\n\n    /// @notice The permit message signed for a single token allowance\n    struct PermitSingle {\n        // the permit data for a single token alownce\n        PermitDetails details;\n        // address permissioned on the allowed tokens\n        address spender;\n        // deadline on the permit signature\n        uint256 sigDeadline;\n    }\n\n    /// @notice The permit message signed for multiple token allowances\n    struct PermitBatch {\n        // the permit data for multiple token allowances\n        PermitDetails[] details;\n        // address permissioned on the allowed tokens\n        address spender;\n        // deadline on the permit signature\n        uint256 sigDeadline;\n    }\n\n    /// @notice The saved permissions\n    /// @dev This info is saved per owner, per token, per spender and all signed over in the permit message\n    /// @dev Setting amount to type(uint160).max sets an unlimited approval\n    struct PackedAllowance {\n        // amount allowed\n        uint160 amount;\n        // permission expiry\n        uint48 expiration;\n        // an incrementing value indexed per owner,token,and spender for each signature\n        uint48 nonce;\n    }\n\n    /// @notice A token spender pair.\n    struct TokenSpenderPair {\n        // the token the spender is approved\n        address token;\n        // the spender address\n        address spender;\n    }\n\n    /// @notice Details for a token transfer.\n    struct AllowanceTransferDetails {\n        // the owner of the token\n        address from;\n        // the recipient of the token\n        address to;\n        // the amount of the token\n        uint160 amount;\n        // the token to be transferred\n        address token;\n    }\n\n    /// @notice A mapping from owner address to token address to spender address to PackedAllowance struct, which contains details and conditions of the approval.\n    /// @notice The mapping is indexed in the above order see: allowance[ownerAddress][tokenAddress][spenderAddress]\n    /// @dev The packed slot holds the allowed amount, expiration at which the allowed amount is no longer valid, and current nonce thats updated on any signature based approvals.\n    function allowance(address user, address token, address spender)\n        external\n        view\n        returns (uint160 amount, uint48 expiration, uint48 nonce);\n\n    /// @notice Approves the spender to use up to amount of the specified token up until the expiration\n    /// @param token The token to approve\n    /// @param spender The spender address to approve\n    /// @param amount The approved amount of the token\n    /// @param expiration The timestamp at which the approval is no longer valid\n    /// @dev The packed allowance also holds a nonce, which will stay unchanged in approve\n    /// @dev Setting amount to type(uint160).max sets an unlimited approval\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\n\n    /// @notice Permit a spender to a given amount of the owners token via the owner's EIP-712 signature\n    /// @dev May fail if the owner's nonce was invalidated in-flight by invalidateNonce\n    /// @param owner The owner of the tokens being approved\n    /// @param permitSingle Data signed over by the owner specifying the terms of approval\n    /// @param signature The owner's signature over the permit data\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n\n    /// @notice Permit a spender to the signed amounts of the owners tokens via the owner's EIP-712 signature\n    /// @dev May fail if the owner's nonce was invalidated in-flight by invalidateNonce\n    /// @param owner The owner of the tokens being approved\n    /// @param permitBatch Data signed over by the owner specifying the terms of approval\n    /// @param signature The owner's signature over the permit data\n    function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;\n\n    /// @notice Transfer approved tokens from one address to another\n    /// @param from The address to transfer from\n    /// @param to The address of the recipient\n    /// @param amount The amount of the token to transfer\n    /// @param token The token address to transfer\n    /// @dev Requires the from address to have approved at least the desired amount\n    /// of tokens to msg.sender.\n    function transferFrom(address from, address to, uint160 amount, address token) external;\n\n    /// @notice Transfer approved tokens in a batch\n    /// @param transferDetails Array of owners, recipients, amounts, and tokens for the transfers\n    /// @dev Requires the from addresses to have approved at least the desired amount\n    /// of tokens to msg.sender.\n    function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;\n\n    /// @notice Enables performing a \"lockdown\" of the sender's Permit2 identity\n    /// by batch revoking approvals\n    /// @param approvals Array of approvals to revoke.\n    function lockdown(TokenSpenderPair[] calldata approvals) external;\n\n    /// @notice Invalidate nonces for a given (token, spender) pair\n    /// @param token The token to invalidate nonces for\n    /// @param spender The spender to invalidate nonces for\n    /// @param newNonce The new nonce to set. Invalidates all nonces less than it.\n    /// @dev Can't invalidate more than 2**16 nonces per transaction.\n    function invalidateNonces(address token, address spender, uint48 newNonce) external;\n}\n"
			},
			"node_modules/@uniswap/permit2/src/interfaces/IEIP712.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IEIP712 {\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
			},
			"node_modules/@uniswap/permit2/src/interfaces/IPermit2.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ISignatureTransfer} from \"./ISignatureTransfer.sol\";\nimport {IAllowanceTransfer} from \"./IAllowanceTransfer.sol\";\n\n/// @notice Permit2 handles signature-based transfers in SignatureTransfer and allowance-based transfers in AllowanceTransfer.\n/// @dev Users must approve Permit2 before calling any of the transfer functions.\ninterface IPermit2 is ISignatureTransfer, IAllowanceTransfer {\n// IPermit2 unifies the two interfaces so users have maximal flexibility with their approval.\n}\n"
			},
			"node_modules/@uniswap/permit2/src/interfaces/ISignatureTransfer.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IEIP712} from \"./IEIP712.sol\";\n\n/// @title SignatureTransfer\n/// @notice Handles ERC20 token transfers through signature based actions\n/// @dev Requires user's token approval on the Permit2 contract\ninterface ISignatureTransfer is IEIP712 {\n    /// @notice Thrown when the requested amount for a transfer is larger than the permissioned amount\n    /// @param maxAmount The maximum amount a spender can request to transfer\n    error InvalidAmount(uint256 maxAmount);\n\n    /// @notice Thrown when the number of tokens permissioned to a spender does not match the number of tokens being transferred\n    /// @dev If the spender does not need to transfer the number of tokens permitted, the spender can request amount 0 to be transferred\n    error LengthMismatch();\n\n    /// @notice Emits an event when the owner successfully invalidates an unordered nonce.\n    event UnorderedNonceInvalidation(address indexed owner, uint256 word, uint256 mask);\n\n    /// @notice The token and amount details for a transfer signed in the permit transfer signature\n    struct TokenPermissions {\n        // ERC20 token address\n        address token;\n        // the maximum amount that can be spent\n        uint256 amount;\n    }\n\n    /// @notice The signed permit message for a single token transfer\n    struct PermitTransferFrom {\n        TokenPermissions permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /// @notice Specifies the recipient address and amount for batched transfers.\n    /// @dev Recipients and amounts correspond to the index of the signed token permissions array.\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount.\n    struct SignatureTransferDetails {\n        // recipient address\n        address to;\n        // spender requested amount\n        uint256 requestedAmount;\n    }\n\n    /// @notice Used to reconstruct the signed permit message for multiple token transfers\n    /// @dev Do not need to pass in spender address as it is required that it is msg.sender\n    /// @dev Note that a user still signs over a spender address\n    struct PermitBatchTransferFrom {\n        // the tokens and corresponding amounts permitted for a transfer\n        TokenPermissions[] permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /// @notice A map from token owner address and a caller specified word index to a bitmap. Used to set bits in the bitmap to prevent against signature replay protection\n    /// @dev Uses unordered nonces so that permit messages do not need to be spent in a certain order\n    /// @dev The mapping is indexed first by the token owner, then by an index specified in the nonce\n    /// @dev It returns a uint256 bitmap\n    /// @dev The index, or wordPosition is capped at type(uint248).max\n    function nonceBitmap(address, uint256) external view returns (uint256);\n\n    /// @notice Transfers a token using a signed permit message\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails The spender's requested transfer details for the permitted token\n    /// @param signature The signature to verify\n    function permitTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers a token using a signed permit message\n    /// @notice Includes extra data provided by the caller to verify signature over\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails The spender's requested transfer details for the permitted token\n    /// @param witness Extra data to include when checking the user signature\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\n    /// @param signature The signature to verify\n    function permitWitnessTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers multiple tokens using a signed permit message\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\n    /// @param signature The signature to verify\n    function permitTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers multiple tokens using a signed permit message\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\n    /// @notice Includes extra data provided by the caller to verify signature over\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\n    /// @param witness Extra data to include when checking the user signature\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\n    /// @param signature The signature to verify\n    function permitWitnessTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Invalidates the bits specified in mask for the bitmap at the word position\n    /// @dev The wordPos is maxed at type(uint248).max\n    /// @param wordPos A number to index the nonceBitmap at\n    /// @param mask A bitmap masked against msg.sender's current bitmap at the word position\n    function invalidateUnorderedNonces(uint256 wordPos, uint256 mask) external;\n}\n"
			},
			"src/JBMultiTerminal.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.23;\n\nimport {JBPermissionIds} from \"@bananapus/permission-ids/src/JBPermissionIds.sol\";\nimport {ERC2771Context} from \"@openzeppelin/contracts/metatx/ERC2771Context.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {ERC165Checker} from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {mulDiv} from \"@prb/math/src/Common.sol\";\nimport {IAllowanceTransfer} from \"@uniswap/permit2/src/interfaces/IAllowanceTransfer.sol\";\nimport {IPermit2} from \"@uniswap/permit2/src/interfaces/IPermit2.sol\";\n\nimport {JBPermissioned} from \"./abstract/JBPermissioned.sol\";\nimport {IJBController} from \"./interfaces/IJBController.sol\";\nimport {IJBDirectory} from \"./interfaces/IJBDirectory.sol\";\nimport {IJBFeelessAddresses} from \"./interfaces/IJBFeelessAddresses.sol\";\nimport {IJBFeeTerminal} from \"./interfaces/IJBFeeTerminal.sol\";\nimport {IJBMultiTerminal} from \"./interfaces/IJBMultiTerminal.sol\";\nimport {IJBPayoutTerminal} from \"./interfaces/IJBPayoutTerminal.sol\";\nimport {IJBPermissioned} from \"./interfaces/IJBPermissioned.sol\";\nimport {IJBPermitTerminal} from \"./interfaces/IJBPermitTerminal.sol\";\nimport {IJBPermissions} from \"./interfaces/IJBPermissions.sol\";\nimport {IJBProjects} from \"./interfaces/IJBProjects.sol\";\nimport {IJBRedeemTerminal} from \"./interfaces/IJBRedeemTerminal.sol\";\nimport {IJBSplitHook} from \"./interfaces/IJBSplitHook.sol\";\nimport {IJBSplits} from \"./interfaces/IJBSplits.sol\";\nimport {IJBTerminal} from \"./interfaces/IJBTerminal.sol\";\nimport {IJBTerminalStore} from \"./interfaces/IJBTerminalStore.sol\";\nimport {JBConstants} from \"./libraries/JBConstants.sol\";\nimport {JBFees} from \"./libraries/JBFees.sol\";\nimport {JBMetadataResolver} from \"./libraries/JBMetadataResolver.sol\";\nimport {JBRulesetMetadataResolver} from \"./libraries/JBRulesetMetadataResolver.sol\";\nimport {JBAccountingContext} from \"./structs/JBAccountingContext.sol\";\nimport {JBAfterPayRecordedContext} from \"./structs/JBAfterPayRecordedContext.sol\";\nimport {JBAfterRedeemRecordedContext} from \"./structs/JBAfterRedeemRecordedContext.sol\";\nimport {JBFee} from \"./structs/JBFee.sol\";\nimport {JBPayHookSpecification} from \"./structs/JBPayHookSpecification.sol\";\nimport {JBRedeemHookSpecification} from \"./structs/JBRedeemHookSpecification.sol\";\nimport {JBRuleset} from \"./structs/JBRuleset.sol\";\nimport {JBSingleAllowanceContext} from \"./structs/JBSingleAllowanceContext.sol\";\nimport {JBSplit} from \"./structs/JBSplit.sol\";\nimport {JBSplitHookContext} from \"./structs/JBSplitHookContext.sol\";\nimport {JBTokenAmount} from \"./structs/JBTokenAmount.sol\";\n\n/// @notice `JBMultiTerminal` manages native/ERC-20 payments, redemptions, and surplus allowance usage for any number of\n/// projects. Terminals are the entry point for operations involving inflows and outflows of funds.\ncontract JBMultiTerminal is JBPermissioned, ERC2771Context, IJBMultiTerminal {\n    // A library that parses the packed ruleset metadata into a friendlier format.\n    using JBRulesetMetadataResolver for JBRuleset;\n\n    // A library that adds default safety checks to ERC20 functionality.\n    using SafeERC20 for IERC20;\n\n    //*********************************************************************//\n    // --------------------------- custom errors ------------------------- //\n    //*********************************************************************//\n\n    error ACCOUNTING_CONTEXT_ALREADY_SET();\n    error INADEQUATE_PAYOUT_AMOUNT();\n    error INADEQUATE_RECLAIM_AMOUNT();\n    error UNDER_MIN_RETURNED_TOKENS();\n    error NO_MSG_VALUE_ALLOWED();\n    error OVERFLOW_ALERT();\n    error PERMIT_ALLOWANCE_NOT_ENOUGH();\n    error TERMINAL_TOKENS_INCOMPATIBLE();\n    error TOKEN_NOT_ACCEPTED();\n\n    //*********************************************************************//\n    // ------------------------- public constants ------------------------ //\n    //*********************************************************************//\n\n    /// @notice This terminal's fee (as a fraction out of `JBConstants.MAX_FEE`).\n    /// @dev Fees are charged on payouts to addresses, surplus allowance usage, and redemptions if the redemption rate\n    /// is less than 100%.\n    uint256 public constant override FEE = 25; // 2.5%\n\n    //*********************************************************************//\n    // ------------------------ internal constants ----------------------- //\n    //*********************************************************************//\n\n    /// @notice Project ID #1 receives fees. It should be the first project launched during the deployment process.\n    uint256 internal constant _FEE_BENEFICIARY_PROJECT_ID = 1;\n\n    /// @notice The number of seconds fees can be held for.\n    uint256 internal constant _FEE_HOLDING_SECONDS = 2_419_200; // 28 days\n\n    //*********************************************************************//\n    // ---------------- public immutable stored properties --------------- //\n    //*********************************************************************//\n\n    /// @notice Mints ERC-721s that represent project ownership and transfers.\n    IJBProjects public immutable override PROJECTS;\n\n    /// @notice The directory of terminals and controllers for PROJECTS.\n    IJBDirectory public immutable override DIRECTORY;\n\n    /// @notice The contract that stores splits for each project.\n    IJBSplits public immutable override SPLITS;\n\n    /// @notice The contract that stores and manages the terminal's data.\n    IJBTerminalStore public immutable override STORE;\n\n    /// @notice The contract that stores addresses that shouldn't incur fees when being paid towards or from.\n    IJBFeelessAddresses public immutable override FEELESS_ADDRESSES;\n\n    /// @notice The permit2 utility.\n    IPermit2 public immutable override PERMIT2;\n\n    //*********************************************************************//\n    // --------------------- internal stored properties ------------------ //\n    //*********************************************************************//\n\n    /// @notice Context describing how a token is accounted for by a project.\n    /// @custom:param projectId The ID of the project that the token accounting context applies to.\n    /// @custom:param token The address of the token being accounted for.\n    mapping(uint256 projectId => mapping(address token => JBAccountingContext)) internal _accountingContextForTokenOf;\n\n    /// @notice A list of tokens accepted by each project.\n    /// @custom:param projectId The ID of the project to get a list of accepted tokens for.\n    mapping(uint256 projectId => JBAccountingContext[]) internal _accountingContextsOf;\n\n    /// @notice Fees that are being held for each project.\n    /// @dev Projects can temporarily hold fees and unlock them later by adding funds to the project's balance.\n    /// @dev Held fees can be processed at any time by this terminal's owner.\n    /// @custom:param projectId The ID of the project that is holding fees.\n    /// @custom:param token The token that the fees are held in.\n    mapping(uint256 projectId => mapping(address token => JBFee[])) internal _heldFeesOf;\n\n    //*********************************************************************//\n    // ------------------------- external views -------------------------- //\n    //*********************************************************************//\n\n    /// @notice A project's accounting context for a token.\n    /// @dev See the `JBAccountingContext` struct for more information.\n    /// @param projectId The ID of the project to get token accounting context of.\n    /// @param token The token to check the accounting context of.\n    /// @return The token's accounting context for the token.\n    function accountingContextForTokenOf(\n        uint256 projectId,\n        address token\n    )\n        external\n        view\n        override\n        returns (JBAccountingContext memory)\n    {\n        return _accountingContextForTokenOf[projectId][token];\n    }\n\n    /// @notice The tokens accepted by a project.\n    /// @param projectId The ID of the project to get the accepted tokens of.\n    /// @return tokenContexts The accounting contexts of the accepted tokens.\n    function accountingContextsOf(uint256 projectId) external view override returns (JBAccountingContext[] memory) {\n        return _accountingContextsOf[projectId];\n    }\n\n    /// @notice Gets the total current surplus amount in this terminal for a project, in terms of a given currency.\n    /// @dev This total surplus only includes tokens that the project accepts (as returned by\n    /// `accountingContextsOf(...)`).\n    /// @param projectId The ID of the project to get the current total surplus of.\n    /// @param decimals The number of decimals to include in the fixed point returned value.\n    /// @param currency The currency to express the returned value in terms of.\n    /// @return The current surplus amount the project has in this terminal, in terms of `currency` and with the\n    /// specified number of decimals.\n    function currentSurplusOf(\n        uint256 projectId,\n        uint256 decimals,\n        uint256 currency\n    )\n        external\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return STORE.currentSurplusOf(address(this), projectId, _accountingContextsOf[projectId], decimals, currency);\n    }\n\n    /// @notice Fees that are being held for a project.\n    /// @dev Projects can temporarily hold fees and unlock them later by adding funds to the project's balance.\n    /// @dev Held fees can be processed at any time by this terminal's owner.\n    /// @param projectId The ID of the project that is holding fees.\n    /// @param token The token that the fees are held in.\n    function heldFeesOf(uint256 projectId, address token) external view override returns (JBFee[] memory) {\n        return _heldFeesOf[projectId][token];\n    }\n\n    //*********************************************************************//\n    // -------------------------- public views --------------------------- //\n    //*********************************************************************//\n\n    /// @notice Indicates whether this contract adheres to the specified interface.\n    /// @dev See {IERC165-supportsInterface}.\n    /// @param interfaceId The ID of the interface to check for adherence to.\n    /// @return A flag indicating if the provided interface ID is supported.\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IJBMultiTerminal).interfaceId || interfaceId == type(IJBPermissioned).interfaceId\n            || interfaceId == type(IJBTerminal).interfaceId || interfaceId == type(IJBRedeemTerminal).interfaceId\n            || interfaceId == type(IJBPayoutTerminal).interfaceId || interfaceId == type(IJBPermitTerminal).interfaceId\n            || interfaceId == type(IJBMultiTerminal).interfaceId || interfaceId == type(IJBFeeTerminal).interfaceId\n            || interfaceId == type(IERC165).interfaceId;\n    }\n\n    //*********************************************************************//\n    // -------------------------- internal views ------------------------- //\n    //*********************************************************************//\n\n    /// @notice Checks this terminal's balance of a specific token.\n    /// @param token The address of the token to get this terminal's balance of.\n    /// @return This terminal's balance.\n    function _balance(address token) internal view returns (uint256) {\n        // If the `token` is native, get the native token balance.\n        return token == JBConstants.NATIVE_TOKEN ? address(this).balance : IERC20(token).balanceOf(address(this));\n    }\n\n    //*********************************************************************//\n    // -------------------------- constructor ---------------------------- //\n    //*********************************************************************//\n\n    /// @param permissions A contract storing permissions.\n    /// @param projects A contract which mints ERC-721s that represent project ownership and transfers.\n    /// @param directory A contract storing directories of terminals and controllers for each project.\n    /// @param splits A contract that stores splits for each project.\n    /// @param store A contract that stores the terminal's data.\n    /// @param feelessAddresses A contract that stores addresses that shouldn't incur fees when being paid towards or\n    /// from.\n    /// @param permit2 A permit2 utility.\n    /// @param trustedForwarder A trusted forwarder of transactions to this contract.\n    constructor(\n        IJBPermissions permissions,\n        IJBProjects projects,\n        IJBDirectory directory,\n        IJBSplits splits,\n        IJBTerminalStore store,\n        IJBFeelessAddresses feelessAddresses,\n        IPermit2 permit2,\n        address trustedForwarder\n    )\n        JBPermissioned(permissions)\n        ERC2771Context(trustedForwarder)\n    {\n        PROJECTS = projects;\n        DIRECTORY = directory;\n        SPLITS = splits;\n        STORE = store;\n        FEELESS_ADDRESSES = feelessAddresses;\n        PERMIT2 = permit2;\n    }\n\n    //*********************************************************************//\n    // ---------------------- external transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice Pay a project with tokens.\n    /// @param projectId The ID of the project being paid.\n    /// @param amount The amount of terminal tokens being received, as a fixed point number with the same number of\n    /// decimals as this terminal. If this terminal's token is native, this is ignored and `msg.value` is used in its\n    /// place.\n    /// @param token The token being paid.\n    /// @param beneficiary The address to mint tokens to, and pass along to the ruleset's data hook and pay hook if\n    /// applicable.\n    /// @param minReturnedTokens The minimum number of project tokens expected in return for this payment, as a fixed\n    /// point number with the same number of decimals as this terminal. If the amount of tokens minted for the\n    /// beneficiary would be less than this amount, the payment is reverted.\n    /// @param memo A memo to pass along to the emitted event.\n    /// @param metadata Bytes to pass along to the emitted event, as well as the data hook and pay hook if applicable.\n    /// @return beneficiaryTokenCount The number of tokens minted to the beneficiary, as a fixed point number with 18\n    /// decimals.\n    function pay(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        address beneficiary,\n        uint256 minReturnedTokens,\n        string calldata memo,\n        bytes calldata metadata\n    )\n        external\n        payable\n        virtual\n        override\n        returns (uint256 beneficiaryTokenCount)\n    {\n        // Pay the project.\n        beneficiaryTokenCount = _pay({\n            projectId: projectId,\n            token: token,\n            amount: _acceptFundsFor(projectId, token, amount, metadata),\n            payer: _msgSender(),\n            beneficiary: beneficiary,\n            memo: memo,\n            metadata: metadata\n        });\n\n        // The token count for the beneficiary must be greater than or equal to the specified minimum.\n        if (beneficiaryTokenCount < minReturnedTokens) {\n            revert UNDER_MIN_RETURNED_TOKENS();\n        }\n    }\n\n    /// @notice Adds funds to a project's balance without minting tokens.\n    /// @dev Adding to balance can unlock held fees if `shouldUnlockHeldFees` is true.\n    /// @param projectId The ID of the project to add funds to the balance of.\n    /// @param amount The amount of tokens to add to the balance, as a fixed point number with the same number of\n    /// decimals as this terminal. If this is a native token terminal, this is ignored and `msg.value` is used instead.\n    /// @param token The token being added to the balance.\n    /// @param shouldReturnHeldFees A flag indicating if held fees should be returned based on the amount being added.\n    /// @param memo A memo to pass along to the emitted event.\n    /// @param metadata Extra data to pass along to the emitted event.\n    function addToBalanceOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        bool shouldReturnHeldFees,\n        string calldata memo,\n        bytes calldata metadata\n    )\n        external\n        payable\n        virtual\n        override\n    {\n        // Add to balance.\n        _addToBalanceOf({\n            projectId: projectId,\n            token: token,\n            amount: _acceptFundsFor(projectId, token, amount, metadata),\n            shouldReturnHeldFees: shouldReturnHeldFees,\n            memo: memo,\n            metadata: metadata\n        });\n    }\n\n    /// @notice Holders can redeem a project's tokens to reclaim some of that project's surplus tokens, or to trigger\n    /// rules determined by the current ruleset's data hook and redeem hook.\n    /// @dev Only a token's holder or an operator with the `REDEEM_TOKENS` permission from that holder can redeem those\n    /// tokens.\n    /// @param holder The account whose tokens are being redeemed.\n    /// @param projectId The ID of the project the project tokens belong to.\n    /// @param tokenToReclaim The token being reclaimed.\n    /// @param redeemCount The number of project tokens to redeem, as a fixed point number with 18 decimals.\n    /// @param minTokensReclaimed The minimum number of terminal tokens expected in return, as a fixed point number with\n    /// the same number of decimals as this terminal. If the amount of tokens minted for the beneficiary would be less\n    /// than this amount, the redemption is reverted.\n    /// @param beneficiary The address to send the reclaimed terminal tokens to, and to pass along to the ruleset's\n    /// data hook and redeem hook if applicable.\n    /// @param metadata Bytes to send along to the emitted event, as well as the data hook and redeem hook if\n    /// applicable.\n    /// @return reclaimAmount The amount of terminal tokens that the project tokens were redeemed for, as a fixed point\n    /// number with 18 decimals.\n    function redeemTokensOf(\n        address holder,\n        uint256 projectId,\n        address tokenToReclaim,\n        uint256 redeemCount,\n        uint256 minTokensReclaimed,\n        address payable beneficiary,\n        bytes calldata metadata\n    )\n        external\n        virtual\n        override\n        returns (uint256 reclaimAmount)\n    {\n        // Enforce permissions.\n        _requirePermissionFrom({account: holder, projectId: projectId, permissionId: JBPermissionIds.REDEEM_TOKENS});\n\n        reclaimAmount = _redeemTokensOf(holder, projectId, tokenToReclaim, redeemCount, beneficiary, metadata);\n\n        // The amount being reclaimed must be at least as much as was expected.\n        if (reclaimAmount < minTokensReclaimed) revert INADEQUATE_RECLAIM_AMOUNT();\n    }\n\n    /// @notice Sends payouts to a project's current payout split group, according to its ruleset, up to its current\n    /// payout limit.\n    /// @dev If the percentages of the splits in the project's payout split group do not add up to 100%, the remainder\n    /// is sent to the project's owner.\n    /// @dev Anyone can send payouts on a project's behalf. Projects can include a wildcard split (a split with no\n    /// `hook`, `projectId`, or `beneficiary`) to send funds to the `_msgSender()` which calls this function. This can\n    /// be used to incentivize calling this function.\n    /// @dev payouts sent to addresses which aren't feeless incur the protocol fee.\n    /// @dev Payouts a projects don't incur fees if its terminal is feeless.\n    /// @param projectId The ID of the project having its payouts sent.\n    /// @param token The token being sent.\n    /// @param amount The total number of terminal tokens to send, as a fixed point number with same number of decimals\n    /// as this terminal.\n    /// @param currency The expected currency of the payouts being sent. Must match the currency of one of the\n    /// project's current ruleset's payout limits.\n    /// @param minTokensPaidOut The minimum number of terminal tokens that the `amount` should be worth (if expressed\n    /// in terms of this terminal's currency), as a fixed point number with the same number of decimals as this\n    /// terminal. If the amount of tokens paid out would be less than this amount, the send is reverted.\n    /// @return amountPaidOut The total amount paid out.\n    function sendPayoutsOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        uint256 currency,\n        uint256 minTokensPaidOut\n    )\n        external\n        virtual\n        override\n        returns (uint256 amountPaidOut)\n    {\n        amountPaidOut = _sendPayoutsOf(projectId, token, amount, currency);\n\n        // The amount being paid out must be at least as much as was expected.\n        if (amountPaidOut < minTokensPaidOut) revert INADEQUATE_PAYOUT_AMOUNT();\n    }\n\n    /// @notice Allows a project to pay out funds from its surplus up to the current surplus allowance.\n    /// @dev Only a project's owner or an operator with the `USE_ALLOWANCE` permission from that owner can use the\n    /// surplus allowance.\n    /// @dev Incurs the protocol fee unless the caller is a feeless address.\n    /// @param projectId The ID of the project to use the surplus allowance of.\n    /// @param token The token being paid out from the surplus.\n    /// @param amount The amount of terminal tokens to use from the project's current surplus allowance, as a fixed\n    /// point number with the same amount of decimals as this terminal.\n    /// @param currency The expected currency of the amount being paid out. Must match the currency of one of the\n    /// project's current ruleset's surplus allowances.\n    /// @param minTokensPaidOut The minimum number of terminal tokens that should be used from the surplus allowance\n    /// (including fees), as a fixed point number with 18 decimals. If the amount of surplus used would be less than\n    /// this amount, the transaction is reverted.\n    /// @param beneficiary The address to send the surplus funds to.\n    /// @param memo A memo to pass along to the emitted event.\n    /// @return amountPaidOut The number of tokens that were sent to the beneficiary, as a fixed point number with\n    /// the same amount of decimals as the terminal.\n    function useAllowanceOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        uint256 currency,\n        uint256 minTokensPaidOut,\n        address payable beneficiary,\n        string calldata memo\n    )\n        external\n        virtual\n        override\n        returns (uint256 amountPaidOut)\n    {\n        // Enforce permissions.\n        _requirePermissionFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.USE_ALLOWANCE\n        });\n\n        amountPaidOut = _useAllowanceOf(projectId, token, amount, currency, beneficiary, memo);\n\n        // The amount being withdrawn must be at least as much as was expected.\n        if (amountPaidOut < minTokensPaidOut) revert INADEQUATE_PAYOUT_AMOUNT();\n    }\n\n    /// @notice Migrate a project's funds and operations to a new terminal that accepts the same token type.\n    /// @dev Only a project's owner or an operator with the `MIGRATE_TERMINAL` permission from that owner can migrate\n    /// the project's terminal.\n    /// @param projectId The ID of the project being migrated.\n    /// @param token The address of the token being migrated.\n    /// @param to The terminal contract being migrated to, which will receive the project's funds and operations.\n    /// @return balance The amount of funds that were migrated, as a fixed point number with the same amount of decimals\n    /// as this terminal.\n    function migrateBalanceOf(\n        uint256 projectId,\n        address token,\n        IJBTerminal to\n    )\n        external\n        virtual\n        override\n        returns (uint256 balance)\n    {\n        // Enforce permissions.\n        _requirePermissionFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.MIGRATE_TERMINAL\n        });\n\n        // The terminal being migrated to must accept the same token as this terminal.\n        if (to.accountingContextForTokenOf(projectId, token).decimals == 0) {\n            revert TERMINAL_TOKENS_INCOMPATIBLE();\n        }\n\n        // Process any held fees.\n        _processHeldFeesOf({projectId: projectId, token: token, forced: true});\n\n        // Record the migration in the store.\n        balance = STORE.recordTerminalMigration(projectId, token);\n\n        // Transfer the balance if needed.\n        if (balance != 0) {\n            // Trigger any inherited pre-transfer logic.\n            _beforeTransferTo({to: address(to), token: token, amount: balance});\n\n            // If this terminal's token is the native token, send it in `msg.value`.\n            uint256 payValue = token == JBConstants.NATIVE_TOKEN ? balance : 0;\n\n            // Withdraw the balance to transfer to the new terminal;\n            to.addToBalanceOf{value: payValue}({\n                projectId: projectId,\n                token: token,\n                amount: balance,\n                shouldReturnHeldFees: false,\n                memo: \"\",\n                metadata: bytes(\"\")\n            });\n        }\n\n        emit MigrateTerminal(projectId, token, to, balance, _msgSender());\n    }\n\n    /// @notice Process any fees that are being held for the project.\n    /// @param projectId The ID of the project to process held fees for.\n    /// @param token The token to process held fees for.\n    function processHeldFeesOf(uint256 projectId, address token) external virtual override {\n        _processHeldFeesOf({projectId: projectId, token: token, forced: false});\n    }\n\n    /// @notice Adds accounting contexts for a project to this terminal so the project can begin accepting the tokens in\n    /// those contexts.\n    /// @dev Only a project's owner, an operator with the `ADD_ACCOUNTING_CONTEXTS` permission from that owner, or a\n    /// project's controller can add accounting contexts for the project.\n    /// @param projectId The ID of the project having to add accounting contexts for.\n    /// @param tokens The tokens to add accounting contexts for.\n    function addAccountingContextsFor(uint256 projectId, address[] calldata tokens) external override {\n        // Enforce permissions.\n        _requirePermissionAllowingOverrideFrom({\n            account: PROJECTS.ownerOf(projectId),\n            projectId: projectId,\n            permissionId: JBPermissionIds.ADD_ACCOUNTING_CONTEXTS,\n            alsoGrantAccessIf: _msgSender() == address(DIRECTORY.controllerOf(projectId))\n        });\n\n        // Keep a reference to the number of accounting contexts to add.\n        uint256 numberOfAccountingContexts = tokens.length;\n\n        // Keep a reference to the token being iterated on.\n        address token;\n\n        // Start accepting each token.\n        for (uint256 i; i < numberOfAccountingContexts; i++) {\n            // Set the accounting context being iterated on.\n            token = tokens[i];\n\n            // Get a storage reference to the currency accounting context for the token.\n            JBAccountingContext storage accountingContext = _accountingContextForTokenOf[projectId][token];\n\n            // Make sure the token accounting context isn't already set.\n            if (accountingContext.token != address(0)) revert ACCOUNTING_CONTEXT_ALREADY_SET();\n\n            // Define the context from the config.\n            accountingContext.token = token;\n            accountingContext.decimals = token == JBConstants.NATIVE_TOKEN ? 18 : IERC20Metadata(token).decimals();\n            accountingContext.currency = uint32(uint160(token)); // Use the last 4 bytes of the address as the currency.\n\n            // Add the token to the list of accepted tokens of the project.\n            _accountingContextsOf[projectId].push(accountingContext);\n\n            emit SetAccountingContext(projectId, token, accountingContext, _msgSender());\n        }\n    }\n\n    /// @notice Process a specified amount of fees for a project.\n    /// @dev Only accepts calls from this terminal itself.\n    /// @param projectId The ID of the project paying the fee.\n    /// @param token The token the fee is being paid in.\n    /// @param amount The fee amount, as a fixed point number with 18 decimals.\n    /// @param beneficiary The address to mint tokens to (from the project which receives fees), and pass along to the\n    /// ruleset's data hook and pay hook if applicable.\n    /// @param feeTerminal The terminal that'll receive the fees.\n    function executeProcessFee(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        address beneficiary,\n        IJBTerminal feeTerminal\n    )\n        external\n    {\n        // NOTICE: May only be called by this terminal itself.\n        require(msg.sender == address(this));\n\n        if (address(feeTerminal) == address(0)) {\n            revert(\"404_1\");\n        }\n\n        // Trigger any inherited pre-transfer logic if funds will be transferred.\n        if (address(feeTerminal) != address(this)) {\n            _beforeTransferTo({to: address(feeTerminal), token: token, amount: amount});\n        }\n\n        // Send the projectId in the metadata.\n        bytes memory metadata = bytes(abi.encodePacked(projectId));\n\n        // Call the internal method of the same terminal is being used.\n        if (feeTerminal == IJBTerminal(address(this))) {\n            _pay({\n                projectId: _FEE_BENEFICIARY_PROJECT_ID,\n                token: token,\n                amount: amount,\n                payer: address(this),\n                beneficiary: beneficiary,\n                memo: \"\",\n                metadata: metadata\n            });\n        } else {\n            // Keep a reference to the amount that'll be paid in.\n            uint256 payValue = token == JBConstants.NATIVE_TOKEN ? amount : 0;\n            // Send the fee.\n            // If this terminal's token is ETH, send it in msg.value.\n            // slither-disable-next-line unused-return\n            feeTerminal.pay{value: payValue}({\n                projectId: _FEE_BENEFICIARY_PROJECT_ID,\n                token: token,\n                amount: amount,\n                beneficiary: beneficiary,\n                minReturnedTokens: 0,\n                memo: \"\",\n                metadata: metadata\n            });\n        }\n    }\n\n    /// @notice Executes a payout to a split.\n    /// @dev Only accepts calls from this terminal itself.\n    /// @param split The split to pay.\n    /// @param projectId The ID of the project the split belongs to.\n    /// @param token The address of the token being paid to the split.\n    /// @param amount The total amount being paid to the split, as a fixed point number with the same number of\n    /// decimals as this terminal.\n    /// @return netPayoutAmount The amount sent to the split after subtracting fees.\n    function executePayout(\n        JBSplit calldata split,\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        address originalMessageSender\n    )\n        external\n        returns (uint256 netPayoutAmount)\n    {\n        // NOTICE: May only be called by this terminal itself.\n        require(msg.sender == address(this));\n\n        // By default, the net payout amount is the full amount. This will be adjusted if fees are taken.\n        netPayoutAmount = amount;\n\n        // If there's a split hook set, transfer to its `process` function.\n        if (split.hook != IJBSplitHook(address(0))) {\n            // This payout is eligible for a fee since the funds are leaving this contract and the split hook isn't a\n            // feeless address.\n            if (!FEELESS_ADDRESSES.isFeeless(address(split.hook))) {\n                netPayoutAmount -= JBFees.feeAmountIn(amount, FEE);\n            }\n\n            // Create the context to send to the split hook.\n            JBSplitHookContext memory context = JBSplitHookContext({\n                token: token,\n                amount: netPayoutAmount,\n                decimals: _accountingContextForTokenOf[projectId][token].decimals,\n                projectId: projectId,\n                groupId: uint256(uint160(token)),\n                split: split\n            });\n\n            // Make sure that the address supports the split hook interface.\n            if (!split.hook.supportsInterface(type(IJBSplitHook).interfaceId)) {\n                revert(\"400_1\");\n            }\n\n            // Trigger any inherited pre-transfer logic.\n            _beforeTransferTo({to: address(split.hook), token: token, amount: netPayoutAmount});\n\n            // Get a reference to the amount being paid in `msg.value`.\n            uint256 payValue = token == JBConstants.NATIVE_TOKEN ? netPayoutAmount : 0;\n\n            // If this terminal's token is the native token, send it in `msg.value`.\n            split.hook.processSplitWith{value: payValue}(context);\n\n            // Otherwise, if a project is specified, make a payment to it.\n        } else if (split.projectId != 0) {\n            // Get a reference to the terminal being used.\n            IJBTerminal terminal = DIRECTORY.primaryTerminalOf(split.projectId, token);\n\n            // The project must have a terminal to send funds to.\n            if (terminal == IJBTerminal(address(0))) revert(\"404_2\");\n\n            // This payout is eligible for a fee if the funds are leaving this contract and the receiving terminal isn't\n            // a feelss address.\n            if (terminal != this && !FEELESS_ADDRESSES.isFeeless(address(terminal))) {\n                netPayoutAmount -= JBFees.feeAmountIn(amount, FEE);\n            }\n\n            // Trigger any inherited pre-transfer logic.\n            if (terminal != this) _beforeTransferTo({to: address(terminal), token: token, amount: netPayoutAmount});\n\n            // Send the `projectId` in the metadata as a referral.\n            bytes memory metadata = bytes(abi.encodePacked(projectId));\n\n            // Add to balance if preferred.\n            if (split.preferAddToBalance) {\n                // Call the internal method if this terminal is being used.\n                if (terminal == IJBTerminal(address(this))) {\n                    _addToBalanceOf({\n                        projectId: split.projectId,\n                        token: token,\n                        amount: netPayoutAmount,\n                        shouldReturnHeldFees: false,\n                        memo: \"\",\n                        metadata: metadata\n                    });\n                } else {\n                    // Get a reference to the amount being added to balance through `msg.value`.\n                    uint256 payValue = token == JBConstants.NATIVE_TOKEN ? netPayoutAmount : 0;\n\n                    // Add to balance.\n                    // If this terminal's token is the native token, send it in `msg.value`.\n                    terminal.addToBalanceOf{value: payValue}({\n                        projectId: split.projectId,\n                        token: token,\n                        amount: netPayoutAmount,\n                        shouldReturnHeldFees: false,\n                        memo: \"\",\n                        metadata: metadata\n                    });\n                }\n            } else {\n                // Keep a reference to the beneficiary of the payment.\n                address beneficiary = split.beneficiary != address(0) ? split.beneficiary : originalMessageSender;\n\n                // Call the internal pay method if this terminal is being used.\n                if (terminal == IJBTerminal(address(this))) {\n                    _pay({\n                        projectId: split.projectId,\n                        token: token,\n                        amount: netPayoutAmount,\n                        payer: address(this),\n                        beneficiary: beneficiary,\n                        memo: \"\",\n                        metadata: metadata\n                    });\n                } else {\n                    // Keep a reference to the amount being paid through `msg.value`.\n                    uint256 payValue = token == JBConstants.NATIVE_TOKEN ? netPayoutAmount : 0;\n\n                    // Make the payment.\n                    // If this terminal's token is the native token, send it in `msg.value`.\n                    // slither-disable-next-line unused-return\n                    terminal.pay{value: payValue}({\n                        projectId: split.projectId,\n                        token: token,\n                        amount: netPayoutAmount,\n                        beneficiary: beneficiary,\n                        minReturnedTokens: 0,\n                        memo: \"\",\n                        metadata: metadata\n                    });\n                }\n            }\n        } else {\n            // If there's a beneficiary, send the funds directly to the beneficiary.\n            // If there isn't a beneficiary, send the funds to the  `_msgSender()`.\n            address payable recipient =\n                split.beneficiary != address(0) ? split.beneficiary : payable(originalMessageSender);\n\n            // This payout is eligible for a fee since the funds are leaving this contract and the recipient isn't a\n            // feeless address.\n            if (!FEELESS_ADDRESSES.isFeeless(recipient)) {\n                netPayoutAmount -= JBFees.feeAmountIn(amount, FEE);\n            }\n\n            // If there's a beneficiary, send the funds directly to the beneficiary. Otherwise send to the\n            // `_msgSender()`.\n            _transferFrom({from: address(this), to: recipient, token: token, amount: netPayoutAmount});\n        }\n    }\n\n    //*********************************************************************//\n    // ---------------------- internal transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice The message's sender. Preferred to use over `msg.sender`.\n    /// @return sender The address which sent this call.\n    function _msgSender() internal view override(ERC2771Context, Context) returns (address sender) {\n        return ERC2771Context._msgSender();\n    }\n\n    /// @notice The calldata. Preferred to use over `msg.data`.\n    /// @return calldata The `msg.data` of this call.\n    function _msgData() internal view override(ERC2771Context, Context) returns (bytes calldata) {\n        return ERC2771Context._msgData();\n    }\n\n    /// @dev `ERC-2771` specifies the context as being a single address (20 bytes).\n    function _contextSuffixLength() internal view virtual override(ERC2771Context, Context) returns (uint256) {\n        return super._contextSuffixLength();\n    }\n\n    //*********************************************************************//\n    // ---------------------- internal transactions ---------------------- //\n    //*********************************************************************//\n\n    /// @notice Accepts an incoming token.\n    /// @param projectId The ID of the project that the transfer is being accepted for.\n    /// @param token The token being accepted.\n    /// @param amount The number of tokens being accepted.\n    /// @param metadata The metadata in which permit2 context is provided.\n    /// @return amount The number of tokens which have been accepted.\n    function _acceptFundsFor(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        bytes calldata metadata\n    )\n        internal\n        returns (uint256)\n    {\n        // Make sure the project has an accounting context for the token being paid.\n        if (_accountingContextForTokenOf[projectId][token].token == address(0)) {\n            revert TOKEN_NOT_ACCEPTED();\n        }\n\n        // If the terminal's token is the native token, override `amount` with `msg.value`.\n        if (token == JBConstants.NATIVE_TOKEN) return msg.value;\n\n        // If the terminal's token is not native, revert if there is a non-zero `msg.value`.\n        if (msg.value != 0) revert NO_MSG_VALUE_ALLOWED();\n\n        // If the terminal is rerouting the tokens within its own functions, there's nothing to transfer.\n        if (_msgSender() == address(this)) return amount;\n\n        // The metadata ID is the first 4 bytes of this contract's address.\n        bytes4 metadataId = JBMetadataResolver.getId(\"permit2\");\n\n        // Unpack the allowance to use, if any, given by the frontend.\n        (bool exists, bytes memory parsedMetadata) = JBMetadataResolver.getDataFor(metadataId, metadata);\n\n        // Check if the metadata contains permit data.\n        if (exists) {\n            // Keep a reference to the allowance context parsed from the metadata.\n            (JBSingleAllowanceContext memory allowance) = abi.decode(parsedMetadata, (JBSingleAllowanceContext));\n\n            // Make sure the permit allowance is enough for this payment. If not we revert early.\n            if (allowance.amount < amount) {\n                revert PERMIT_ALLOWANCE_NOT_ENOUGH();\n            }\n\n            // Set the allowance to `spend` tokens for the user.\n            try PERMIT2.permit({\n                owner: _msgSender(),\n                permitSingle: IAllowanceTransfer.PermitSingle({\n                    details: IAllowanceTransfer.PermitDetails({\n                        token: token,\n                        amount: allowance.amount,\n                        expiration: allowance.expiration,\n                        nonce: allowance.nonce\n                    }),\n                    spender: address(this),\n                    sigDeadline: allowance.sigDeadline\n                }),\n                signature: allowance.signature\n            }) {} catch (bytes memory) {}\n        }\n\n        // Get a reference to the balance before receiving tokens.\n        uint256 balanceBefore = _balance(token);\n\n        // Transfer tokens to this terminal from the msg sender.\n        _transferFrom({from: _msgSender(), to: payable(address(this)), token: token, amount: amount});\n\n        // The amount should reflect the change in balance.\n        return _balance(token) - balanceBefore;\n    }\n\n    /// @notice Pay a project with tokens.\n    /// @param projectId The ID of the project being paid.\n    /// @param token The address of the token which the project is being paid with.\n    /// @param amount The amount of terminal tokens being received, as a fixed point number with the same number of\n    /// decimals as this terminal. If this terminal's token is the native token, `amount` is ignored and `msg.value` is\n    /// used in its place.\n    /// @param payer The address making the payment.\n    /// @param beneficiary The address to mint tokens to, and pass along to the ruleset's data hook and pay hook if\n    /// applicable.\n    /// @param memo A memo to pass along to the emitted event.\n    /// @param metadata Bytes to send along to the emitted event, as well as the data hook and pay hook if applicable.\n    /// @return beneficiaryTokenCount The number of tokens minted and sent to the beneficiary, as a fixed point number\n    /// with 18 decimals.\n    function _pay(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        address payer,\n        address beneficiary,\n        string memory memo,\n        bytes memory metadata\n    )\n        internal\n        returns (uint256 beneficiaryTokenCount)\n    {\n        // Keep a reference to the ruleset the payment is being made during.\n        JBRuleset memory ruleset;\n\n        // Keep a reference to the pay hook specifications.\n        JBPayHookSpecification[] memory hookSpecifications;\n\n        // Keep a reference to the token count that'll be minted as a result of the payment.\n        uint256 tokenCount;\n\n        // Keep a reference to the token amount to forward to the store.\n        JBTokenAmount memory tokenAmount;\n\n        // Scoped section prevents stack too deep. `context` only used within scope.\n        {\n            // Get a reference to the token's accounting context.\n            JBAccountingContext memory context = _accountingContextForTokenOf[projectId][token];\n\n            // Bundle the amount info into a `JBTokenAmount` struct.\n            tokenAmount = JBTokenAmount(token, amount, context.decimals, context.currency);\n        }\n\n        // Record the payment.\n        (ruleset, tokenCount, hookSpecifications) = STORE.recordPaymentFrom({\n            payer: payer,\n            amount: tokenAmount,\n            projectId: projectId,\n            beneficiary: beneficiary,\n            metadata: metadata\n        });\n\n        // Mint tokens if needed.\n        if (tokenCount != 0) {\n            // Set the token count to be the number of tokens minted for the beneficiary instead of the total\n            // amount.\n            beneficiaryTokenCount = IJBController(address(DIRECTORY.controllerOf(projectId))).mintTokensOf({\n                projectId: projectId,\n                tokenCount: tokenCount,\n                beneficiary: beneficiary,\n                memo: \"\",\n                useReservedRate: true\n            });\n        }\n\n        // If the data hook returned pay hook specifications, fulfill them.\n        if (hookSpecifications.length != 0) {\n            _fulfillPayHookSpecificationsFor(\n                projectId, hookSpecifications, tokenAmount, payer, ruleset, beneficiary, beneficiaryTokenCount, metadata\n            );\n        }\n\n        emit Pay(\n            ruleset.id,\n            ruleset.cycleNumber,\n            projectId,\n            payer,\n            beneficiary,\n            amount,\n            beneficiaryTokenCount,\n            memo,\n            metadata,\n            _msgSender()\n        );\n    }\n\n    /// @notice Adds funds to a project's balance without minting tokens.\n    /// @param projectId The ID of the project to add funds to the balance of.\n    /// @param token The address of the token being added to the project's balance.\n    /// @param amount The amount of tokens to add as a fixed point number with the same number of decimals as this\n    /// terminal. If this is a native token terminal, this is ignored and `msg.value` is used instead.\n    /// @param shouldReturnHeldFees A flag indicating if held fees should be returned based on the amount being added.\n    /// @param memo A memo to pass along to the emitted event.\n    /// @param metadata Extra data to pass along to the emitted event.\n    function _addToBalanceOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        bool shouldReturnHeldFees,\n        string memory memo,\n        bytes memory metadata\n    )\n        internal\n    {\n        // Return held fees if desired. This mechanism means projects don't pay fees multiple times when funds go out of\n        // and back into the protocol.\n        uint256 returnedFees = shouldReturnHeldFees ? _returnHeldFees(projectId, token, amount) : 0;\n\n        // Record the added funds with any returned fees.\n        STORE.recordAddedBalanceFor({projectId: projectId, token: token, amount: amount + returnedFees});\n\n        emit AddToBalance(projectId, amount, returnedFees, memo, metadata, _msgSender());\n    }\n\n    /// @notice Holders can redeem their tokens to claim some of a project's surplus, or to trigger rules determined by\n    /// the project's current ruleset's data hook.\n    /// @dev Only a token holder or a an operator with the `REDEEM_TOKENS` permission from that holder can redeem those\n    /// tokens.\n    /// @param holder The account redeeming tokens.\n    /// @param projectId The ID of the project whose tokens are being redeemed.\n    /// @param tokenToReclaim The address of the token which is being reclaimed.\n    /// @param redeemCount The number of project tokens to redeem, as a fixed point number with 18 decimals.\n    /// @param beneficiary The address to send the reclaimed terminal tokens to.\n    /// @param metadata Bytes to send along to the emitted event, as well as the data hook and redeem hook if\n    /// applicable.\n    /// @return reclaimAmount The number of terminal tokens reclaimed for the `beneficiary`, as a fixed point number\n    /// with 18 decimals.\n\n    function _redeemTokensOf(\n        address holder,\n        uint256 projectId,\n        address tokenToReclaim,\n        uint256 redeemCount,\n        address payable beneficiary,\n        bytes memory metadata\n    )\n        internal\n        returns (uint256 reclaimAmount)\n    {\n        // Keep a reference to the ruleset the redemption is being made during.\n        JBRuleset memory ruleset;\n\n        // Keep a reference to the redeem hook specifications.\n        JBRedeemHookSpecification[] memory hookSpecifications;\n\n        // Keep a reference to the redemption rate being used.\n        uint256 redemptionRate;\n\n        // Keep a reference to the accounting context of the token being reclaimed.\n        JBAccountingContext memory accountingContext = _accountingContextForTokenOf[projectId][tokenToReclaim];\n\n        // Scoped section prevents stack too deep.\n        {\n            JBAccountingContext[] memory balanceAccountingContexts = _accountingContextsOf[projectId];\n\n            // Record the redemption.\n            (ruleset, reclaimAmount, redemptionRate, hookSpecifications) = STORE.recordRedemptionFor({\n                holder: holder,\n                projectId: projectId,\n                accountingContext: accountingContext,\n                balanceAccountingContexts: balanceAccountingContexts,\n                redeemCount: redeemCount,\n                metadata: metadata\n            });\n        }\n\n        // Burn the project tokens.\n        if (redeemCount != 0) {\n            IJBController(address(DIRECTORY.controllerOf(projectId))).burnTokensOf({\n                holder: holder,\n                projectId: projectId,\n                tokenCount: redeemCount,\n                memo: \"\"\n            });\n        }\n\n        // Keep a reference to the amount being reclaimed that is subject to fees.\n        uint256 amountEligibleForFees;\n\n        // Send the reclaimed funds to the beneficiary.\n        if (reclaimAmount != 0) {\n            // Determine if a fee should be taken. Fees are not exercised if the redemption rate is at its max (100%),\n            // if the beneficiary is feeless, or if the fee beneficiary doesn't accept the given token.\n            if (!FEELESS_ADDRESSES.isFeeless(beneficiary) && redemptionRate != JBConstants.MAX_REDEMPTION_RATE) {\n                amountEligibleForFees += reclaimAmount;\n                // Subtract the fee for the reclaimed amount.\n                reclaimAmount -= JBFees.feeAmountIn(reclaimAmount, FEE);\n            }\n\n            // Subtract the fee from the reclaim amount.\n            if (reclaimAmount != 0) {\n                _transferFrom({from: address(this), to: beneficiary, token: tokenToReclaim, amount: reclaimAmount});\n            }\n        }\n\n        // If the data hook returned redeem hook specifications, fulfill them.\n        if (hookSpecifications.length != 0) {\n            // Fulfill the redeem hook specifications.\n            amountEligibleForFees += _fulfillRedeemHookSpecificationsFor({\n                projectId: projectId,\n                holder: holder,\n                redeemCount: redeemCount,\n                ruleset: ruleset,\n                redemptionRate: redemptionRate,\n                beneficiary: beneficiary,\n                beneficiaryReclaimAmount: JBTokenAmount(\n                    tokenToReclaim, reclaimAmount, accountingContext.decimals, accountingContext.currency\n                ),\n                specifications: hookSpecifications,\n                metadata: metadata\n            });\n        }\n\n        // Take the fee from all outbound reclaimings.\n        amountEligibleForFees != 0\n            ? _takeFeeFrom({\n                projectId: projectId,\n                token: tokenToReclaim,\n                amount: amountEligibleForFees,\n                beneficiary: beneficiary,\n                shouldHoldFees: false\n            })\n            : 0;\n\n        emit RedeemTokens(\n            ruleset.id,\n            ruleset.cycleNumber,\n            projectId,\n            holder,\n            beneficiary,\n            redeemCount,\n            redemptionRate,\n            reclaimAmount,\n            metadata,\n            _msgSender()\n        );\n    }\n\n    /// @notice Sends payouts to a project's current payout split group, according to its ruleset, up to its current\n    /// payout limit.\n    /// @dev If the percentages of the splits in the project's payout split group do not add up to 100%, the remainder\n    /// is sent to the project's owner.\n    /// @dev Anyone can send payouts on a project's behalf. Projects can include a wildcard split (a split with no\n    /// `hook`, `projectId`, or `beneficiary`) to send funds to the `_msgSender()` which calls this function. This can\n    /// be used to incentivize calling this function.\n    /// @dev Payouts sent to addresses which aren't feeless incur the protocol fee.\n    /// @param projectId The ID of the project to send the payouts of.\n    /// @param token The token being paid out.\n    /// @param amount The number of terminal tokens to pay out, as a fixed point number with same number of decimals as\n    /// this terminal.\n    /// @param currency The expected currency of the amount being paid out. Must match the currency of one of the\n    /// project's current ruleset's payout limits.\n    /// @return amountPaidOut The total amount that was paid out.\n    function _sendPayoutsOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        uint256 currency\n    )\n        internal\n        returns (uint256 amountPaidOut)\n    {\n        // Keep a reference to the ruleset.\n        JBRuleset memory ruleset;\n\n        // Record the payout.\n        (ruleset, amountPaidOut) = STORE.recordPayoutFor({\n            projectId: projectId,\n            accountingContext: _accountingContextForTokenOf[projectId][token],\n            amount: amount,\n            currency: currency\n        });\n\n        // Get a reference to the project's owner.\n        // The owner will receive tokens minted by paying the platform fee and receive any leftover funds not sent to\n        // payout splits.\n        address payable projectOwner = payable(PROJECTS.ownerOf(projectId));\n\n        // Send payouts to the splits and get a reference to the amount left over after the splits have been paid.\n        // Also get a reference to the amount which was paid out to splits that is eligible for fees.\n        (uint256 leftoverPayoutAmount, uint256 amountEligibleForFees) =\n            _sendPayoutsToSplitGroupOf(projectId, token, ruleset.id, amountPaidOut);\n\n        // Take the fee.\n        uint256 feeTaken = _takeFeeFrom({\n            projectId: projectId,\n            token: token,\n            amount: amountEligibleForFees + leftoverPayoutAmount,\n            beneficiary: projectOwner,\n            shouldHoldFees: ruleset.holdFees()\n        });\n\n        /// The leftover amount that was sent to the project owner.\n        uint256 netLeftoverPayoutAmount;\n\n        // Send any leftover funds to the project owner and update the net leftover (which is returned) accordingly.\n        if (leftoverPayoutAmount != 0) {\n            // Subtract the fee from the net leftover amount.\n            netLeftoverPayoutAmount = leftoverPayoutAmount - JBFees.feeAmountIn(leftoverPayoutAmount, FEE);\n\n            // Transfer the amount to the project owner.\n            _transferFrom({from: address(this), to: projectOwner, token: token, amount: netLeftoverPayoutAmount});\n        }\n\n        emit SendPayouts(\n            ruleset.id,\n            ruleset.cycleNumber,\n            projectId,\n            projectOwner,\n            amount,\n            amountPaidOut,\n            feeTaken,\n            netLeftoverPayoutAmount,\n            _msgSender()\n        );\n    }\n\n    /// @notice Allows a project to send out funds from its surplus up to the current surplus allowance.\n    /// @dev Only a project's owner or an operator with the `USE_ALLOWANCE` permission from that owner can use the\n    /// surplus allowance.\n    /// @dev Incurs the protocol fee unless the caller is a feeless address.\n    /// @param projectId The ID of the project to use the surplus allowance of.\n    /// @param token The token being paid out from the surplus.\n    /// @param amount The amount of terminal tokens to use from the project's current surplus allowance, as a fixed\n    /// point number with the same amount of decimals as this terminal.\n    /// @param currency The expected currency of the amount being paid out. Must match the currency of one of the\n    /// project's current ruleset's surplus allowances.\n    /// @param beneficiary The address to send the funds to.\n    /// @param memo A memo to pass along to the emitted event.\n    /// @return amountPaidOut The amount of tokens paid out.\n    function _useAllowanceOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        uint256 currency,\n        address payable beneficiary,\n        string memory memo\n    )\n        internal\n        returns (uint256 amountPaidOut)\n    {\n        // Keep a reference to the ruleset.\n        JBRuleset memory ruleset;\n\n        // Record the use of the allowance.\n        (ruleset, amountPaidOut) = STORE.recordUsedAllowanceOf({\n            projectId: projectId,\n            accountingContext: _accountingContextForTokenOf[projectId][token],\n            amount: amount,\n            currency: currency\n        });\n\n        // Take a fee from the `amountPaidOut`, if needed.\n        // The net amount is the final amount withdrawn after the fee has been taken.\n        uint256 netAmountPaidOut = amountPaidOut\n            - (\n                FEELESS_ADDRESSES.isFeeless(_msgSender())\n                    ? 0\n                    : _takeFeeFrom({\n                        projectId: projectId,\n                        token: token,\n                        amount: amountPaidOut,\n                        // The project owner will receive tokens minted by paying the platform fee.\n                        beneficiary: PROJECTS.ownerOf(projectId),\n                        shouldHoldFees: ruleset.holdFees()\n                    })\n            );\n\n        // Transfer any remaining balance to the beneficiary.\n        if (netAmountPaidOut != 0) {\n            _transferFrom({from: address(this), to: beneficiary, token: token, amount: netAmountPaidOut});\n        }\n\n        emit UseAllowance(\n            ruleset.id,\n            ruleset.cycleNumber,\n            projectId,\n            beneficiary,\n            amount,\n            amountPaidOut,\n            netAmountPaidOut,\n            memo,\n            _msgSender()\n        );\n    }\n\n    /// @notice Sends payouts to the payout splits group specified in a project's ruleset.\n    /// @param projectId The ID of the project to send the payouts of.\n    /// @param token The address of the token being paid out.\n    /// @param rulesetId The ID of the ruleset of the split group being paid.\n    /// @param amount The total amount being paid out, as a fixed point number with the same number of decimals as this\n    /// terminal.\n    /// @return amount The leftover amount (zero if the splits add up to 100%).\n    /// @return amountEligibleForFees The total amount of funds which were paid out and are eligible for fees.\n    function _sendPayoutsToSplitGroupOf(\n        uint256 projectId,\n        address token,\n        uint256 rulesetId,\n        uint256 amount\n    )\n        internal\n        returns (uint256, uint256 amountEligibleForFees)\n    {\n        // The total percentage available to split\n        uint256 leftoverPercentage = JBConstants.SPLITS_TOTAL_PERCENT;\n\n        // Get a reference to the project's payout splits.\n        JBSplit[] memory splits = SPLITS.splitsOf(projectId, rulesetId, uint256(uint160(token)));\n\n        // Keep a reference to the number of splits being iterated on.\n        uint256 numberOfSplits = splits.length;\n\n        // Keep a reference to the split being iterated on.\n        JBSplit memory split;\n\n        // Transfer between all splits.\n        for (uint256 i; i < numberOfSplits; i++) {\n            // Get a reference to the split being iterated on.\n            split = splits[i];\n\n            // The amount to send to the split.\n            uint256 payoutAmount = mulDiv(amount, split.percent, leftoverPercentage);\n\n            // The final payout amount after taking out any fees.\n            uint256 netPayoutAmount = _sendPayoutToSplit(split, projectId, token, payoutAmount);\n\n            // If the split hook is a feeless address, this payout doesn't incur a fee.\n            if (netPayoutAmount != 0 && netPayoutAmount != payoutAmount) {\n                amountEligibleForFees += payoutAmount;\n            }\n\n            if (payoutAmount != 0) {\n                // Subtract from the amount to be sent to the beneficiary.\n                unchecked {\n                    amount -= payoutAmount;\n                }\n            }\n\n            unchecked {\n                // Decrement the leftover percentage.\n                leftoverPercentage -= split.percent;\n            }\n\n            emit SendPayoutToSplit(\n                projectId, rulesetId, uint256(uint160(token)), split, payoutAmount, netPayoutAmount, _msgSender()\n            );\n        }\n\n        return (amount, amountEligibleForFees);\n    }\n\n    /// @notice Sends a payout to a split.\n    /// @param split The split to pay.\n    /// @param projectId The ID of the project the split was specified by.\n    /// @param token The address of the token being paid out.\n    /// @param amount The total amount that the split is being paid, as a fixed point number with the same number of\n    /// decimals as this terminal.\n    /// @return netPayoutAmount The amount sent to the split after subtracting fees.\n    function _sendPayoutToSplit(\n        JBSplit memory split,\n        uint256 projectId,\n        address token,\n        uint256 amount\n    )\n        internal\n        returns (uint256)\n    {\n        // Attempt to distribute this split.\n        try this.executePayout(split, projectId, token, amount, _msgSender()) returns (uint256 netPayoutAmount) {\n            return netPayoutAmount;\n        } catch (bytes memory failureReason) {\n            // Add balance back to the project.\n            STORE.recordAddedBalanceFor(projectId, token, amount);\n            // Emit event.\n            emit PayoutReverted(projectId, split, amount, failureReason, _msgSender());\n            // Since the payout failed the netPayoutAmount is zero.\n            return 0;\n        }\n    }\n\n    /// @notice Fulfills a list of pay hook specifications.\n    /// @param projectId The ID of the project being paid.\n    /// @param specifications The pay hook specifications to be fulfilled.\n    /// @param tokenAmount The amount of tokens that the project was paid.\n    /// @param payer The address that sent the payment.\n    /// @param ruleset The ruleset the payment is being accepted during.\n    /// @param beneficiary The address which will receive any tokens that the payment yields.\n    /// @param beneficiaryTokenCount The amount of tokens that are being minted and sent to the beneificary.\n    /// @param metadata Bytes to send along to the emitted event and pay hooks as applicable.\n    function _fulfillPayHookSpecificationsFor(\n        uint256 projectId,\n        JBPayHookSpecification[] memory specifications,\n        JBTokenAmount memory tokenAmount,\n        address payer,\n        JBRuleset memory ruleset,\n        address beneficiary,\n        uint256 beneficiaryTokenCount,\n        bytes memory metadata\n    )\n        internal\n    {\n        // Keep a reference to payment context for the pay hooks.\n        JBAfterPayRecordedContext memory context = JBAfterPayRecordedContext({\n            payer: payer,\n            projectId: projectId,\n            rulesetId: ruleset.id,\n            amount: tokenAmount,\n            forwardedAmount: tokenAmount,\n            weight: ruleset.weight,\n            projectTokenCount: beneficiaryTokenCount,\n            beneficiary: beneficiary,\n            hookMetadata: bytes(\"\"),\n            payerMetadata: metadata\n        });\n\n        // Keep a reference to the number of pay hook specifications to iterate through.\n        uint256 numberOfSpecifications = specifications.length;\n\n        // Keep a reference to the specification being iterated on.\n        JBPayHookSpecification memory specification;\n\n        // Fulfill each specification through their pay hooks.\n        for (uint256 i; i < numberOfSpecifications; i++) {\n            // Set the specification being iterated on.\n            specification = specifications[i];\n\n            // Pass the correct token `forwardedAmount` to the hook.\n            context.forwardedAmount = JBTokenAmount({\n                value: specification.amount,\n                token: tokenAmount.token,\n                decimals: tokenAmount.decimals,\n                currency: tokenAmount.currency\n            });\n\n            // Pass the correct metadata from the data hook's specification.\n            context.hookMetadata = specification.metadata;\n\n            // Trigger any inherited pre-transfer logic.\n            _beforeTransferTo({to: address(specification.hook), token: tokenAmount.token, amount: specification.amount});\n\n            // Keep a reference to the amount that'll be paid as a `msg.value`.\n            uint256 payValue = tokenAmount.token == JBConstants.NATIVE_TOKEN ? specification.amount : 0;\n\n            // Fulfill the specification.\n            specification.hook.afterPayRecordedWith{value: payValue}(context);\n\n            emit HookAfterRecordPay(specification.hook, context, specification.amount, _msgSender());\n        }\n    }\n\n    /// @notice Fulfills a list of redeem hook specification.\n    /// @param projectId The ID of the project being redeemed from.\n    /// @param beneficiaryReclaimAmount The number of tokens that are being reclaimed from the project.\n    /// @param holder The address that holds the tokens being redeemed.\n    /// @param redeemCount The number of tokens being redeemed.\n    /// @param metadata Bytes to send along to the emitted event and redeem hooks as applicable.\n    /// @param ruleset The ruleset the redemption is being made during as a `JBRuleset` struct.\n    /// @param redemptionRate The redemption rate influencing the reclaim amount.\n    /// @param beneficiary The address which will receive any terminal tokens that are reclaimed by this redemption.\n    /// @param specifications The hook specifications being fulfilled.\n    /// @return amountEligibleForFees The amount of funds which were allocated to redeem hooks and are eligible for\n    /// fees.\n    function _fulfillRedeemHookSpecificationsFor(\n        uint256 projectId,\n        JBTokenAmount memory beneficiaryReclaimAmount,\n        address holder,\n        uint256 redeemCount,\n        bytes memory metadata,\n        JBRuleset memory ruleset,\n        uint256 redemptionRate,\n        address payable beneficiary,\n        JBRedeemHookSpecification[] memory specifications\n    )\n        internal\n        returns (uint256 amountEligibleForFees)\n    {\n        // Keep a reference to redemption context for the redeem hooks.\n        JBAfterRedeemRecordedContext memory context = JBAfterRedeemRecordedContext({\n            holder: holder,\n            projectId: projectId,\n            rulesetId: ruleset.id,\n            redeemCount: redeemCount,\n            reclaimedAmount: beneficiaryReclaimAmount,\n            forwardedAmount: beneficiaryReclaimAmount,\n            redemptionRate: redemptionRate,\n            beneficiary: beneficiary,\n            hookMetadata: \"\",\n            redeemerMetadata: metadata\n        });\n\n        // Keep a reference to the number of redeem hook specifications being iterated through.\n        uint256 numberOfSpecifications = specifications.length;\n\n        // Keep a reference to the specification being iterated on.\n        JBRedeemHookSpecification memory specification;\n\n        for (uint256 i; i < numberOfSpecifications; i++) {\n            // Set the specification being iterated on.\n            specification = specifications[i];\n\n            // Get the fee for the specified amount.\n            uint256 specificationAmountFee = FEELESS_ADDRESSES.isFeeless(address(specification.hook))\n                ? 0\n                : JBFees.feeAmountIn(specification.amount, FEE);\n\n            // Add the specification's amount to the amount eligible for fees.\n            if (specificationAmountFee != 0) {\n                amountEligibleForFees += specification.amount;\n                specification.amount -= specificationAmountFee;\n            }\n\n            // Pass the correct token `forwardedAmount` to the hook.\n            context.forwardedAmount = JBTokenAmount({\n                value: specification.amount,\n                token: beneficiaryReclaimAmount.token,\n                decimals: beneficiaryReclaimAmount.decimals,\n                currency: beneficiaryReclaimAmount.currency\n            });\n\n            // Pass the correct metadata from the data hook's specification.\n            context.hookMetadata = specification.metadata;\n\n            // Trigger any inherited pre-transfer logic.\n            _beforeTransferTo({\n                to: address(specification.hook),\n                token: beneficiaryReclaimAmount.token,\n                amount: specification.amount\n            });\n\n            // Keep a reference to the amount that'll be paid as a `msg.value`.\n            uint256 payValue = beneficiaryReclaimAmount.token == JBConstants.NATIVE_TOKEN ? specification.amount : 0;\n\n            // Fulfill the specification.\n            specification.hook.afterRedeemRecordedWith{value: payValue}(context);\n\n            emit HookAfterRecordRedeem(\n                specification.hook, context, specification.amount, specificationAmountFee, _msgSender()\n            );\n        }\n    }\n\n    /// @notice Takes a fee into the platform's project (with the `_FEE_BENEFICIARY_PROJECT_ID`).\n    /// @param projectId The ID of the project paying the fee.\n    /// @param token The address of the token that the fee is being paid in.\n    /// @param amount The fee's token amount, as a fixed point number with 18 decimals.\n    /// @param beneficiary The address to mint the platform's project's tokens for.\n    /// @param shouldHoldFees If fees should be tracked and held instead of being exercised immediately.\n    /// @return feeAmount The amount of the fee taken.\n    function _takeFeeFrom(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        address beneficiary,\n        bool shouldHoldFees\n    )\n        internal\n        returns (uint256 feeAmount)\n    {\n        // Get a reference to the fee amount.\n        feeAmount = JBFees.feeAmountIn(amount, FEE);\n\n        if (shouldHoldFees) {\n            // Store the held fee.\n            _heldFeesOf[projectId][token].push(\n                JBFee({\n                    amount: amount,\n                    beneficiary: beneficiary,\n                    unlockTimestamp: block.timestamp + _FEE_HOLDING_SECONDS\n                })\n            );\n\n            emit HoldFee(projectId, token, amount, FEE, beneficiary, _msgSender());\n        } else {\n            // Get the terminal that'll receive the fee if one wasn't provided.\n            IJBTerminal feeTerminal = DIRECTORY.primaryTerminalOf(_FEE_BENEFICIARY_PROJECT_ID, token);\n\n            // Process the fee.\n            _processFee({\n                projectId: projectId,\n                token: token,\n                amount: feeAmount,\n                beneficiary: beneficiary,\n                feeTerminal: feeTerminal,\n                wasHeld: false\n            });\n        }\n    }\n\n    /// @notice Process any fees that are being held for the project.\n    /// @param projectId The ID of the project to process held fees for.\n    /// @param token The token to process held fees for.\n    /// @param forced If locked held fees should be force processed.\n    function _processHeldFeesOf(uint256 projectId, address token, bool forced) internal {\n        // Get a reference to the project's held fees.\n        JBFee[] memory heldFees = _heldFeesOf[projectId][token];\n\n        // Delete the held fees.\n        delete _heldFeesOf[projectId][token];\n\n        // Keep a reference to the number of held fees.\n        uint256 numberOfHeldFees = heldFees.length;\n\n        // Keep a reference to the fee being iterated on.\n        JBFee memory heldFee;\n\n        // Keep a reference to the terminal that'll receive the fees.\n        IJBTerminal feeTerminal = DIRECTORY.primaryTerminalOf(_FEE_BENEFICIARY_PROJECT_ID, token);\n\n        // Process each fee.\n        for (uint256 i; i < numberOfHeldFees; i++) {\n            // Keep a reference to the held fee being iterated on.\n            heldFee = heldFees[i];\n\n            // Can't process fees that aren't yet unlocked.\n            if (!forced && heldFee.unlockTimestamp > block.timestamp) {\n                // Add the fee back to storage.\n                _heldFeesOf[projectId][token].push(heldFee);\n                continue;\n            }\n\n            // Process the fee.\n            _processFee({\n                projectId: projectId,\n                token: token,\n                amount: heldFee.amount,\n                beneficiary: heldFee.beneficiary,\n                feeTerminal: feeTerminal,\n                wasHeld: true\n            });\n        }\n    }\n\n    /// @notice Process a fee of the specified amount from a project.\n    /// @param projectId The ID of the project paying the fee.\n    /// @param token The token the fee is being paid in.\n    /// @param amount The fee amount, as a fixed point number with 18 decimals.\n    /// @param beneficiary The address which will receive any platform tokens minted.\n    /// @param feeTerminal The terminal that'll receive the fee.\n    /// @param wasHeld A flag indicating if the fee being processed was being held by this terminal.\n    function _processFee(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        address beneficiary,\n        IJBTerminal feeTerminal,\n        bool wasHeld\n    )\n        internal\n    {\n        // slither-disable-start reentrancy-no-eth\n        try this.executeProcessFee(projectId, token, amount, beneficiary, feeTerminal) {\n            emit ProcessFee(projectId, token, amount, wasHeld, beneficiary, _msgSender());\n        } catch (bytes memory reason) {\n            STORE.recordAddedBalanceFor(projectId, token, amount);\n\n            emit FeeReverted(projectId, token, _FEE_BENEFICIARY_PROJECT_ID, amount, reason, _msgSender());\n        }\n        // slither-disable-end reentrancy-no-eth\n    }\n\n    /// @notice Returns held fees to the project who paid them based on the specified amount.\n    /// @param projectId The project held fees are being returned to.\n    /// @param token The token that the held fees are in.\n    /// @param amount The amount to base the calculation on, as a fixed point number with the same number of decimals\n    /// as this terminal.\n    /// @return returnedFees The amount of held fees that were returned, as a fixed point number with the same number of\n    /// decimals as this terminal\n    function _returnHeldFees(\n        uint256 projectId,\n        address token,\n        uint256 amount\n    )\n        internal\n        returns (uint256 returnedFees)\n    {\n        // Get a reference to the project's held fees.\n        JBFee[] memory heldFees = _heldFeesOf[projectId][token];\n\n        // Delete the current held fees.\n        delete _heldFeesOf[projectId][token];\n\n        // Get a reference to the leftover amount once all fees have been settled.\n        uint256 leftoverAmount = amount;\n\n        // Keep a reference to the number of held fees.\n        uint256 numberOfHeldFees = heldFees.length;\n\n        // Keep a reference to the fee being iterated on.\n        JBFee memory heldFee;\n\n        // Process each fee.\n        for (uint256 i; i < numberOfHeldFees; i++) {\n            // Save the fee being iterated on.\n            heldFee = heldFees[i];\n\n            // slither-disable-next-line incorrect-equality\n            if (leftoverAmount == 0) {\n                _heldFeesOf[projectId][token].push(heldFee);\n            } else {\n                // Notice here we take `feeAmountIn` on the stored `.amount`.\n                uint256 feeAmount = JBFees.feeAmountIn(heldFee.amount, FEE);\n\n                // Keep a reference to the amount from which the fee was taken.\n                uint256 amountFromFee = heldFee.amount - feeAmount;\n\n                if (leftoverAmount >= amountFromFee) {\n                    unchecked {\n                        leftoverAmount = leftoverAmount - amountFromFee;\n                        returnedFees += feeAmount;\n                    }\n                } else {\n                    // And here we overwrite with `feeAmountFrom` the `leftoverAmount`\n                    feeAmount = JBFees.feeAmountFrom(leftoverAmount, FEE);\n\n                    unchecked {\n                        _heldFeesOf[projectId][token].push(\n                            JBFee({\n                                amount: amountFromFee - leftoverAmount,\n                                beneficiary: heldFee.beneficiary,\n                                unlockTimestamp: heldFee.unlockTimestamp\n                            })\n                        );\n                        returnedFees += feeAmount;\n                    }\n                    leftoverAmount = 0;\n                }\n            }\n        }\n\n        emit ReturnHeldFees(projectId, token, amount, returnedFees, leftoverAmount, _msgSender());\n    }\n\n    /// @notice Transfers tokens.\n    /// @param from The address the transfer should originate from.\n    /// @param to The address the transfer should go to.\n    /// @param token The token being transfered.\n    /// @param amount The number of tokens being transferred, as a fixed point number with the same number of decimals\n    /// as this terminal.\n    function _transferFrom(address from, address payable to, address token, uint256 amount) internal {\n        // If the token is the native token, transfer natively.\n        if (token == JBConstants.NATIVE_TOKEN) return Address.sendValue(to, amount);\n\n        if (from == address(this)) return IERC20(token).safeTransfer(to, amount);\n\n        // If there's sufficient approval, transfer normally.\n        if (IERC20(token).allowance(address(from), address(this)) >= amount) {\n            return IERC20(token).safeTransferFrom(from, to, amount);\n        }\n\n        // Make sure the amount being paid is less than the maximum permit2 allowance.\n        if (amount > type(uint160).max) revert OVERFLOW_ALERT();\n\n        // Otherwise we attempt to use the PERMIT2 method.\n        PERMIT2.transferFrom(from, to, uint160(amount), token);\n    }\n\n    /// @notice Logic to be triggered before transferring tokens from this terminal.\n    /// @param to The address the transfer is going to.\n    /// @param token The token being transferred.\n    /// @param amount The number of tokens being transferred, as a fixed point number with the same number of decimals\n    /// as this terminal.\n    function _beforeTransferTo(address to, address token, uint256 amount) internal {\n        // If the token is the native token, no allowance needed.\n        if (token == JBConstants.NATIVE_TOKEN) return;\n        IERC20(token).safeIncreaseAllowance(to, amount);\n    }\n}\n"
			},
			"src/interfaces/IJBFeeTerminal.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBFee} from \"../structs/JBFee.sol\";\nimport {IJBFeelessAddresses} from \"./IJBFeelessAddresses.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\n\n/// @notice A terminal that can process and hold fees.\ninterface IJBFeeTerminal is IJBTerminal {\n    event HoldFee(\n        uint256 indexed projectId,\n        address indexed token,\n        uint256 indexed amount,\n        uint256 fee,\n        address beneficiary,\n        address caller\n    );\n\n    event ProcessFee(\n        uint256 indexed projectId,\n        address indexed token,\n        uint256 indexed amount,\n        bool wasHeld,\n        address beneficiary,\n        address caller\n    );\n\n    event ReturnHeldFees(\n        uint256 indexed projectId,\n        address indexed token,\n        uint256 indexed amount,\n        uint256 returnedFees,\n        uint256 leftoverAmount,\n        address caller\n    );\n\n    event FeeReverted(\n        uint256 indexed projectId,\n        address indexed token,\n        uint256 indexed feeProjectId,\n        uint256 amount,\n        bytes reason,\n        address caller\n    );\n\n    function FEE() external view returns (uint256);\n\n    function FEELESS_ADDRESSES() external view returns (IJBFeelessAddresses);\n\n    function heldFeesOf(uint256 projectId, address token) external view returns (JBFee[] memory);\n\n    function processHeldFeesOf(uint256 projectId, address token) external;\n\n    function executeProcessFee(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        address beneficiary,\n        IJBTerminal feeTerminal\n    )\n        external;\n}\n"
			},
			"src/interfaces/IJBMultiTerminal.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IJBDirectory} from \"./IJBDirectory.sol\";\nimport {IJBFeeTerminal} from \"./IJBFeeTerminal.sol\";\nimport {IJBPayoutTerminal} from \"./IJBPayoutTerminal.sol\";\nimport {IJBPermitTerminal} from \"./IJBPermitTerminal.sol\";\nimport {IJBProjects} from \"./IJBProjects.sol\";\nimport {IJBRedeemTerminal} from \"./IJBRedeemTerminal.sol\";\nimport {IJBSplits} from \"./IJBSplits.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\nimport {IJBTerminalStore} from \"./IJBTerminalStore.sol\";\n\ninterface IJBMultiTerminal is IJBTerminal, IJBFeeTerminal, IJBRedeemTerminal, IJBPayoutTerminal, IJBPermitTerminal {\n    function STORE() external view returns (IJBTerminalStore);\n\n    function PROJECTS() external view returns (IJBProjects);\n\n    function DIRECTORY() external view returns (IJBDirectory);\n\n    function SPLITS() external view returns (IJBSplits);\n}\n"
			},
			"src/interfaces/IJBPayoutTerminal.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBSplit} from \"../structs/JBSplit.sol\";\nimport {IJBSplits} from \"./IJBSplits.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\n\n/// @notice A terminal that can send payouts.\ninterface IJBPayoutTerminal is IJBTerminal {\n    event SendPayouts(\n        uint256 indexed rulesetId,\n        uint256 indexed rulesetCycleNumber,\n        uint256 indexed projectId,\n        address beneficiary,\n        uint256 amount,\n        uint256 amountPaidOut,\n        uint256 fee,\n        uint256 beneficiaryDistributionAmount,\n        address caller\n    );\n\n    event SendPayoutToSplit(\n        uint256 indexed projectId,\n        uint256 indexed rulesetId,\n        uint256 indexed group,\n        JBSplit split,\n        uint256 amount,\n        uint256 netAmount,\n        address caller\n    );\n\n    event UseAllowance(\n        uint256 indexed rulesetId,\n        uint256 indexed rulesetCycleNumber,\n        uint256 indexed projectId,\n        address beneficiary,\n        uint256 amount,\n        uint256 amountPaidOut,\n        uint256 netAmountPaidOut,\n        string memo,\n        address caller\n    );\n\n    event PayoutReverted(uint256 indexed projectId, JBSplit split, uint256 amount, bytes reason, address caller);\n\n    /// @notice Only callable by itself, included for testing.\n    function executePayout(\n        JBSplit calldata split,\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        address originalMessageSender\n    )\n        external\n        returns (uint256 netPayoutAmount);\n\n    function sendPayoutsOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        uint256 currency,\n        uint256 minTokensPaidOut\n    )\n        external\n        returns (uint256 netLeftoverPayoutAmount);\n\n    function useAllowanceOf(\n        uint256 projectId,\n        address token,\n        uint256 amount,\n        uint256 currency,\n        uint256 minTokensPaidOut,\n        address payable beneficiary,\n        string calldata memo\n    )\n        external\n        returns (uint256 netAmountPaidOut);\n}\n"
			},
			"src/interfaces/IJBPermitTerminal.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IPermit2} from \"@uniswap/permit2/src/interfaces/IPermit2.sol\";\n\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\n\ninterface IJBPermitTerminal is IJBTerminal {\n    function PERMIT2() external returns (IPermit2);\n}\n"
			},
			"src/interfaces/IJBRedeemTerminal.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {JBAfterRedeemRecordedContext} from \"../structs/JBAfterRedeemRecordedContext.sol\";\nimport {IJBRedeemHook} from \"./IJBRedeemHook.sol\";\nimport {IJBTerminal} from \"./IJBTerminal.sol\";\n\n/// @notice A terminal that can be redeemed from.\ninterface IJBRedeemTerminal is IJBTerminal {\n    event RedeemTokens(\n        uint256 indexed rulesetId,\n        uint256 indexed rulesetCycleNumber,\n        uint256 indexed projectId,\n        address holder,\n        address beneficiary,\n        uint256 tokenCount,\n        uint256 redemptionRate,\n        uint256 reclaimedAmount,\n        bytes metadata,\n        address caller\n    );\n\n    event HookAfterRecordRedeem(\n        IJBRedeemHook indexed hook,\n        JBAfterRedeemRecordedContext context,\n        uint256 specificationAmount,\n        uint256 fee,\n        address caller\n    );\n\n    function redeemTokensOf(\n        address holder,\n        uint256 projectId,\n        address tokenToReclaim,\n        uint256 redeemCount,\n        uint256 minTokensReclaimed,\n        address payable beneficiary,\n        bytes calldata metadata\n    )\n        external\n        returns (uint256 reclaimAmount);\n}\n"
			},
			"src/libraries/JBFees.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {mulDiv} from \"@prb/math/src/Common.sol\";\n\nimport {JBConstants} from \"./../libraries/JBConstants.sol\";\n\n/// @notice Fee calculations.\nlibrary JBFees {\n    /// @notice Returns the amount of tokens to pay as a fee out of the specified `amount`.\n    /// @dev The resulting fee will be `feePercent` of the REMAINING `amount` after subtracting the fee, not the full\n    /// `amount`.\n    /// @param amount The amount that the fee is based on, as a fixed point number.\n    /// @param feePercent The fee percent, out of `JBConstants.MAX_FEE`.\n    /// @return The amount of tokens to pay as a fee, as a fixed point number with the same number of decimals as the\n    /// provided `amount`.\n    function feeAmountIn(uint256 amount, uint256 feePercent) internal pure returns (uint256) {\n        // The amount of tokens from the `amount` to pay as a fee. If reverse, the fee taken from a payout of\n        // `amount`.\n        return amount - mulDiv(amount, JBConstants.MAX_FEE, feePercent + JBConstants.MAX_FEE);\n    }\n\n    /// @notice Returns the fee that would have been paid based on an `amount` which has already had the fee subtracted\n    /// from it.\n    /// @dev The resulting fee will be `feePercent` of the full `amount`.\n    /// @param amount The amount that the fee is based on, as a fixed point number with the same amount of decimals as\n    /// this terminal.\n    /// @param feePercent The fee percent, out of `JBConstants.MAX_FEE`.\n    /// @return The amount of the fee, as a fixed point number with the same amount of decimals as this terminal.\n    function feeAmountFrom(uint256 amount, uint256 feePercent) internal pure returns (uint256) {\n        // The amount of tokens from the `amount` to pay as a fee. If reverse, the fee taken from a payout of\n        // `amount`.\n        return mulDiv(amount, feePercent, JBConstants.MAX_FEE);\n    }\n}\n"
			},
			"src/libraries/JBMetadataResolver.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/**\n * @notice Library to parse and create metadata to store {id: data} entries.\n *\n * @dev    Metadata are built as:\n *         - 32B of reserved space for the protocol\n *         - a lookup table `Id: offset`, defining the offset of the data for a given 4 bytes id.\n *           The offset fits 1 bytes, the ID 4 bytes. This table is padded to 32B.\n *         - the data for each id, padded to 32B each\n *\n *            +-----------------------+ offset: 0\n *            | 32B reserved          |\n *            +-----------------------+ offset: 1 = end of first 32B\n *            |      (ID1,offset1)    |\n *            |      (ID2,offset2)    |\n *            |       0's padding     |\n *            +-----------------------+ offset: offset1 = 1 + number of words taken by the padded table\n *            |       id1 data1       |\n *            | 0's padding           |\n *            +-----------------------+ offset: offset2 = offset1 + number of words taken by the data1\n *            |       id2 data2       |\n *            | 0's padding           |\n *            +-----------------------+\n */\nlibrary JBMetadataResolver {\n    error DATA_NOT_PADDED();\n    error LENGTH_MISMATCH();\n    error METADATA_TOO_LONG();\n    error METADATA_TOO_SHORT();\n\n    // The various sizes used in bytes.\n    uint256 constant ID_SIZE = 4;\n    uint256 constant ID_OFFSET_SIZE = 1;\n    uint256 constant WORD_SIZE = 32;\n\n    // The size that an ID takes in the lookup table (Identifier + Offset).\n    uint256 constant TOTAL_ID_SIZE = 5; // ID_SIZE + ID_OFFSET_SIZE;\n\n    // The amount of bytes to go forward to get to the offset of the next ID (aka. the end of the offset of the current\n    // ID).\n    uint256 constant NEXT_ID_OFFSET = 9; // TOTAL_ID_SIZE + ID_SIZE;\n\n    // 1 word (32B) is reserved for the protocol .\n    uint256 constant RESERVED_SIZE = 32; // 1 * WORD_SIZE;\n    uint256 constant MIN_METADATA_LENGTH = 37; // RESERVED_SIZE + ID_SIZE + ID_OFFSET_SIZE;\n\n    /**\n     * @notice Parse the metadata to find the data for a specific ID\n     *\n     * @dev    Returns false and an empty bytes if no data is found\n     *\n     * @param  id             The ID to find\n     * @param  metadata       The metadata to parse\n     *\n     * @return found          Whether the {id:data} was found\n     * @return targetData The data for the ID (can be empty)\n     */\n    function getDataFor(bytes4 id, bytes memory metadata) internal pure returns (bool found, bytes memory targetData) {\n        // Either no data or empty one with only one selector (32+4+1)\n        if (metadata.length <= MIN_METADATA_LENGTH) return (false, \"\");\n\n        // Get the first data offset - upcast to avoid overflow (same for other offset)\n        uint256 firstOffset = uint8(metadata[RESERVED_SIZE + ID_SIZE]);\n\n        // Parse the id's to find id, stop when next offset == 0 or current = first offset\n        for (uint256 i = RESERVED_SIZE; metadata[i + ID_SIZE] != bytes1(0) && i < firstOffset * WORD_SIZE;) {\n            uint256 currentOffset = uint256(uint8(metadata[i + ID_SIZE]));\n\n            bytes4 parsedId;\n            assembly {\n                parsedId := mload(add(add(metadata, 0x20), i))\n            }\n\n            // _id found?\n            if (parsedId == id) {\n                // Are we at the end of the lookup table (either at the start of data's or next offset is 0/in the\n                // padding)\n                // If not, only return until from this offset to the begining of the next offset\n                uint256 end = (i + NEXT_ID_OFFSET >= firstOffset * WORD_SIZE || metadata[i + NEXT_ID_OFFSET] == 0)\n                    ? metadata.length\n                    : uint256(uint8(metadata[i + NEXT_ID_OFFSET])) * WORD_SIZE;\n\n                return (true, _sliceBytes(metadata, currentOffset * WORD_SIZE, end));\n            }\n            unchecked {\n                i += TOTAL_ID_SIZE;\n            }\n        }\n    }\n\n    /**\n     * @notice Add an {id: data} entry to an existing metadata. This is an append-only mechanism.\n     *\n     * @param originalMetadata The original metadata\n     * @param idToAdd          The id to add\n     * @param dataToAdd        The data to add\n     *\n     * @return newMetadata    The new metadata with the entry added\n     */\n    function addToMetadata(\n        bytes memory originalMetadata,\n        bytes4 idToAdd,\n        bytes memory dataToAdd\n    )\n        internal\n        pure\n        returns (bytes memory newMetadata)\n    {\n        // Empty original metadata and maybe something in the first 32 bytes: create new metadata\n        if (originalMetadata.length <= RESERVED_SIZE) {\n            return abi.encodePacked(bytes32(originalMetadata), bytes32(abi.encodePacked(idToAdd, uint8(2))), dataToAdd);\n        }\n\n        // There is something in the table offset, but not a valid entry - avoid overwriting\n        if (originalMetadata.length < RESERVED_SIZE + ID_SIZE + 1) revert METADATA_TOO_SHORT();\n\n        // Make sure the data is padded to 32 bytes.\n        if (dataToAdd.length < 32) revert DATA_NOT_PADDED();\n\n        // Get the first data offset - upcast to avoid overflow (same for other offset)...\n        uint256 firstOffset = uint8(originalMetadata[RESERVED_SIZE + ID_SIZE]);\n\n        // ...go back to the beginning of the previous word (ie the last word of the table, as it can be padded)\n        uint256 lastWordOfTable = firstOffset - 1;\n\n        // The last offset stored in the table and its index\n        uint256 lastOffset;\n\n        uint256 lastOffsetIndex;\n\n        // The number of words taken by the last data stored\n        uint256 numberOfWordslastData;\n\n        // Iterate to find the last entry of the table, lastOffset - we start from the end as the first value\n        // encountered\n        // will be the last offset\n        for (uint256 i = firstOffset * WORD_SIZE - 1; i > lastWordOfTable * WORD_SIZE - 1; i--) {\n            // If the byte is not 0, this is the last offset we're looking for\n            if (originalMetadata[i] != 0) {\n                lastOffset = uint8(originalMetadata[i]);\n                lastOffsetIndex = i;\n\n                // No rounding as this should be padded to 32B\n                numberOfWordslastData = (originalMetadata.length - lastOffset * WORD_SIZE) / WORD_SIZE;\n\n                // Copy the reserved word and the table and remove the previous padding\n                newMetadata = _sliceBytes(originalMetadata, 0, lastOffsetIndex + 1);\n\n                // Check if the new entry is still fitting in this word\n                if (i + TOTAL_ID_SIZE >= firstOffset * WORD_SIZE) {\n                    // Increment every offset by 1 (as the table now takes one more word)\n                    for (uint256 j = RESERVED_SIZE + ID_SIZE; j < lastOffsetIndex + 1; j += TOTAL_ID_SIZE) {\n                        newMetadata[j] = bytes1(uint8(originalMetadata[j]) + 1);\n                    }\n\n                    // Increment the last offset so the new offset will be properly set too\n                    lastOffset++;\n                }\n\n                break;\n            }\n        }\n\n        // Add the new entry after the last entry of the table, the new offset is the last offset + the number of words\n        // taken by the last data\n        newMetadata = abi.encodePacked(newMetadata, idToAdd, bytes1(uint8(lastOffset + numberOfWordslastData)));\n\n        // Pad as needed - inlined for gas saving\n        uint256 paddedLength =\n            newMetadata.length % WORD_SIZE == 0 ? newMetadata.length : (newMetadata.length / WORD_SIZE + 1) * WORD_SIZE;\n        assembly {\n            mstore(newMetadata, paddedLength)\n        }\n\n        // Add existing data at the end\n        newMetadata = abi.encodePacked(\n            newMetadata, _sliceBytes(originalMetadata, firstOffset * WORD_SIZE, originalMetadata.length)\n        );\n\n        // Pad as needed\n        paddedLength =\n            newMetadata.length % WORD_SIZE == 0 ? newMetadata.length : (newMetadata.length / WORD_SIZE + 1) * WORD_SIZE;\n        assembly {\n            mstore(newMetadata, paddedLength)\n        }\n\n        // Append new data at the end\n        newMetadata = abi.encodePacked(newMetadata, dataToAdd);\n\n        // Pad again again as needed\n        paddedLength =\n            newMetadata.length % WORD_SIZE == 0 ? newMetadata.length : (newMetadata.length / WORD_SIZE + 1) * WORD_SIZE;\n\n        assembly {\n            mstore(newMetadata, paddedLength)\n        }\n    }\n\n    /**\n     * @notice Create the metadata for a list of {id:data}\n     *\n     * @dev    Intended for offchain use (gas heavy)\n     *\n     * @param _ids             The list of ids\n     * @param _datas       The list of corresponding datas\n     *\n     * @return metadata       The resulting metadata\n     */\n    function createMetadata(\n        bytes4[] memory _ids,\n        bytes[] memory _datas\n    )\n        internal\n        pure\n        returns (bytes memory metadata)\n    {\n        if (_ids.length != _datas.length) revert LENGTH_MISMATCH();\n\n        // Add a first empty 32B for the protocol reserved word\n        metadata = abi.encodePacked(bytes32(0));\n\n        // First offset for the data is after the first reserved word...\n        uint256 _offset = 1;\n\n        // ... and after the id/offset lookup table, rounding up to 32 bytes words if not a multiple\n        _offset += ((_ids.length * JBMetadataResolver.TOTAL_ID_SIZE) - 1) / JBMetadataResolver.WORD_SIZE + 1;\n\n        // For each id, add it to the lookup table with the next free offset, then increment the offset by the data\n        // length (rounded up)\n        for (uint256 _i; _i < _ids.length; ++_i) {\n            if (_datas[_i].length < 32) revert DATA_NOT_PADDED();\n\n            metadata = abi.encodePacked(metadata, _ids[_i], bytes1(uint8(_offset)));\n            _offset += _datas[_i].length / JBMetadataResolver.WORD_SIZE;\n\n            // Overflowing a bytes1?\n            if (_offset > 255) revert METADATA_TOO_LONG();\n        }\n\n        // Pad the table to a multiple of 32B\n        uint256 _paddedLength = metadata.length % JBMetadataResolver.WORD_SIZE == 0\n            ? metadata.length\n            : (metadata.length / JBMetadataResolver.WORD_SIZE + 1) * JBMetadataResolver.WORD_SIZE;\n        assembly {\n            mstore(metadata, _paddedLength)\n        }\n\n        // Add each metadata to the array, each padded to 32 bytes\n        for (uint256 _i; _i < _datas.length; _i++) {\n            metadata = abi.encodePacked(metadata, _datas[_i]);\n            _paddedLength = metadata.length % JBMetadataResolver.WORD_SIZE == 0\n                ? metadata.length\n                : (metadata.length / JBMetadataResolver.WORD_SIZE + 1) * JBMetadataResolver.WORD_SIZE;\n\n            assembly {\n                mstore(metadata, _paddedLength)\n            }\n        }\n    }\n\n    /**\n     * @notice Returns an unique id following a suggested format\n     *         (`xor(address(this), purpose name)` where purpose name is a string\n     *         giving context to the id (Permit2, quoteForSwap, etc)\n     *\n     * @param purpose   A string describing the purpose associated with the id\n     *\n     * @return id       The resulting id\n     */\n    function getId(string memory purpose) internal view returns (bytes4) {\n        return getId(purpose, address(this));\n    }\n\n    /**\n     * @notice Returns an unique id following a suggested format\n     *         (`xor(address(this), purpose name)` where purpose name is a string\n     *         giving context to the id (Permit2, quoteForSwap, etc)\n     *\n     * @param purpose   A string describing the purpose associated with the id\n     * @param target          The target which will use the metadata\n     *\n     * @return id       The resulting id\n     */\n    function getId(string memory purpose, address target) internal pure returns (bytes4) {\n        return bytes4(bytes20(target) ^ bytes20(keccak256(bytes(purpose))));\n    }\n\n    /// @notice Slice bytes from a start index to an end index.\n    /// @param data The bytes array to slice\n    /// @param start The start index to slice at.\n    /// @param end The end index to slice at.\n    /// @param slicedBytes The sliced array.\n    function _sliceBytes(\n        bytes memory data,\n        uint256 start,\n        uint256 end\n    )\n        internal\n        pure\n        returns (bytes memory slicedBytes)\n    {\n        assembly {\n            let length := sub(end, start)\n\n            // Allocate memory at the freemem(add 0x20 to include the length)\n            slicedBytes := mload(0x40)\n            mstore(0x40, add(add(slicedBytes, length), 0x20))\n\n            // Store the length (first element)\n            mstore(slicedBytes, length)\n\n            // compute the actual data first offset only once\n            let startBytes := add(add(data, 0x20), start)\n\n            // same for the out array\n            let sliceBytesStartOfData := add(slicedBytes, 0x20)\n\n            // store dem data\n            for { let i := 0 } lt(i, end) { i := add(i, 0x20) } {\n                mstore(add(sliceBytesStartOfData, i), mload(add(startBytes, i)))\n            }\n        }\n    }\n}\n"
			},
			"src/structs/JBFee.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member amount The total amount the fee was taken from, as a fixed point number with the same number of\n/// decimals as the terminal in which this struct was created.\n/// @custom:member beneficiary The address that will receive the tokens that are minted as a result of the fee payment.\n/// @custom:member unlockTimestamp The timestamp at which the fee is unlocked and can be processed.\nstruct JBFee {\n    uint256 amount;\n    address beneficiary;\n    uint256 unlockTimestamp;\n}\n"
			},
			"src/structs/JBSingleAllowanceContext.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @custom:member sigDeadline Deadline on the permit signature.\n/// @custom:member amount The maximum amount allowed to spend.\n/// @custom:member expiration Timestamp at which a spender's token allowances become invalid.\n/// @custom:member nonce An incrementing value indexed per owner,token,and spender for each signature.\n/// @custom:member signature The signature over the permit data. Supports EOA signatures, compact signatures defined by\n/// EIP-2098, and contract signatures defined by EIP-1271.\nstruct JBSingleAllowanceContext {\n    uint256 sigDeadline;\n    uint160 amount;\n    uint48 expiration;\n    uint48 nonce;\n    bytes signature;\n}\n"
			}
		}
	}
}